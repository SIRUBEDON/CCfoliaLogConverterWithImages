<!DOCTYPE html>
<html lang="ja">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-Q7E160JNKC"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-Q7E160JNKC');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã‚³ã‚³ãƒ•ã‚©ãƒªã‚¢/Tekeyãƒ­ã‚°æ•´å½¢ãƒ„ãƒ¼ãƒ«(ç”»åƒåŸ‹ã‚è¾¼ã¿æ©Ÿèƒ½ä»˜ã)</title> <!-- Title updated -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Noto+Sans+JP:wght@400;700&family=Noto+Serif+JP:wght@400;700&family=M+PLUS+Rounded+1c:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* --- Font Definitions --- */
        .font-inter { font-family: 'Inter', sans-serif; }
        .font-noto-sans { font-family: 'Noto Sans JP', sans-serif; }
        .font-noto-serif { font-family: 'Noto Serif JP', serif; }
        .font-mplus-rounded { font-family: "'M PLUS Rounded 1c'", sans-serif; }
        .font-system-sans { font-family: sans-serif; }
        .font-system-serif { font-family: serif; }
        .font-system-mono { font-family: monospace; }

        /* Basic styling */
        body {
            background-color: #f3f4f6; /* bg-gray-100 */
        }
        #log-display {
             line-height: 1.7;
        }

        /* Custom scrollbar for log display */
        #log-display::-webkit-scrollbar { width: 8px; }
        #log-display::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
        #log-display::-webkit-scrollbar-thumb { background: #888; border-radius: 10px; }
        #log-display::-webkit-scrollbar-thumb:hover { background: #555; }
        /* Icon styling */
        .icon-border {
            border-width: 3px;
            border-style: solid;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }
        .message-item .icon-container img.message-icon {
             cursor: pointer;
        }
        .character-icon-preview {
             cursor: pointer;
        }
        /* Chat bubble styling */
        .bubble {
            position: relative;
            padding: 10px 15px;
            border-radius: 15px;
            max-width: var(--bubble-max-width, 80%);
            word-wrap: break-word;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            background-color: var(--bubble-bg-color, #ffffff);
        }
        .bubble::before {
            content: "";
            position: absolute;
            top: 10px;
            width: 0;
            height: 0;
            border-style: solid;
        }
        .bubble-left {
            margin-right: auto;
            margin-left: calc(var(--icon-size, 64px) + 12px); /* Default icon size 64px */
        }
        .bubble-left::before {
            left: -8px;
            border-width: 8px 10px 8px 0;
            border-color: transparent var(--bubble-arrow-color, #ffffff) transparent transparent;
        }

        /* --- Message Display Modes --- */
        .message-item { position: relative; padding-top: 1.5px; padding-bottom: 1.5px; }
        .message-container { display: flex; align-items: flex-start; }
        .icon-container { flex-shrink: 0; position: relative; width: var(--icon-size); height: var(--icon-size); margin-right: 12px; }
        .content-container { flex-grow: 1; min-width: 0; }
        .speaker-name-default { display: block; font-size: 0.9em; font-weight: bold; color: #333; margin-bottom: 2px; }
        .tab-name-below-icon { display: none; font-size: 0.8em; color: #666; margin-bottom: 2px; }
        .speaker-name-below-icon { display: none; font-size: 0.85em; font-weight: bold; color: #333; text-align: center; text-shadow: -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff, 1px 1px 0 #fff, -1.5px -1.5px 0 #fff, 1.5px -1.5px 0 #fff, -1.5px 1.5px 0 #fff, 1.5px 1.5px 0 #fff; position: absolute; bottom: -1.5em; left: 50%; transform: translateX(-50%); width: max-content; max-width: calc(var(--icon-size, 64px) + 20px); line-height: 1.1; pointer-events: none; }

        /* Narration Mode Styles */
        .narration-container { padding: 2px 4px; margin-left: 0; font-size: inherit; line-height: inherit; color: #333; }
        .message-item[data-display-mode="narration"] .narration-tab,
        .message-item[data-display-mode="narration"] .narration-speaker { display: none; }
        .narration-tab { font-size: 0.8em; color: #666; margin-right: 0.5em; }
        .narration-speaker { font-weight: bold; margin-right: 0.25em; }
        .narration-message { display: block; }
        .message-item[data-display-mode="narration"] .message-container { display: none; }
        .message-item[data-display-mode="bubble"] .narration-container { display: none; }

        /* åå‰ã‚’ã‚¢ã‚¤ã‚³ãƒ³ä¸‹ã«è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰ æœ‰åŠ¹æ™‚ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .name-below-icon-active .icon-container { margin-bottom: 1.8em; overflow: visible; }
        .name-below-icon-active .speaker-name-default { display: none; }
        .name-below-icon-active .tab-name-below-icon { display: block; }
        .name-below-icon-active .speaker-name-below-icon { display: block; }
        .name-below-icon-active .bubble-left { margin-left: 0; }
        .name-below-icon-active .bubble-left::before { left: -8px; }
        .name-below-icon-active .action-button-container { margin-left: 0; }

        /* Display Mode Toggle Button */
        .display-mode-toggle { position: absolute; top: 1px; right: 1px; padding: 3px 5px; font-size: 1rem; line-height: 1; border-radius: 4px; border: 1px solid #bbb; background-color: #f0f0f0; color: #333; cursor: pointer; opacity: 0.85; transition: opacity 0.2s, background-color 0.2s; z-index: 10; }
        .display-mode-toggle:hover { background-color: #ddd; border-color: #999; }

        /* Icon Selection Dropdown */
        .icon-select-dropdown { position: absolute; background-color: white; border: 1px solid #ccc; box-shadow: 0 2px 5px rgba(0,0,0,0.2); border-radius: 4px; padding: 5px 0; min-width: 150px; z-index: 100; }
        .icon-select-dropdown button { display: block; width: 100%; padding: 6px 12px; text-align: left; background: none; border: none; cursor: pointer; font-size: 0.9em; white-space: nowrap; }
        .icon-select-dropdown button:hover { background-color: #f0f0f0; }
        .icon-select-separator { border-top: 1px solid #eee; margin: 4px 0; }
        .icon-select-dropdown button img { width: 20px; height: 20px; border-radius: 50%; object-fit: cover; margin-right: 8px; vertical-align: middle; border: 1px solid #ddd; }

        /* Character Settings Expression UI */
        .expression-section { margin-top: 1rem; padding-top: 0.75rem; border-top: 1px solid #e5e7eb; }
        .expression-item { display: flex; align-items: center; gap: 0.75rem; padding: 0.5rem 0; border-bottom: 1px solid #f3f4f6; }
        .expression-item:last-child { border-bottom: none; }
        .expression-preview { width: 2rem; height: 2rem; border-radius: 9999px; object-fit: cover; border: 1px solid #d1d5db; }
        .expression-name { flex-grow: 1; font-size: 0.875rem; color: #374151; }
        .expression-delete-btn { flex-shrink: 0; padding: 0.125rem 0.375rem; font-size: 0.75rem; background-color: #fee2e2; color: #dc2626; border-radius: 0.25rem; border: 1px solid #fecaca; cursor: pointer; }
        .expression-delete-btn:hover { background-color: #fecaca; }
        .add-expression-form { display: flex; align-items: center; gap: 0.5rem; margin-top: 0.75rem; }
        .add-expression-form input[type="text"] { flex-grow: 1; padding: 0.375rem 0.625rem; font-size: 0.875rem; border: 1px solid #d1d5db; border-radius: 0.375rem; min-width: 80px; }
        .add-expression-form input[type="file"] { position: absolute; width: 1px; height: 1px; margin: -1px; padding: 0; overflow: hidden; clip: rect(0, 0, 0, 0); border: 0; }
        .add-expression-form label { padding: 0.375rem 0.75rem; font-size: 0.875rem; background-color: #e5e7eb; color: #374151; border: 1px solid #d1d5db; border-radius: 0.375rem; cursor: pointer; white-space: nowrap; }
        .add-expression-form label:hover { background-color: #d1d5db; }

        /* Other Styles */
        .inserted-image-container { margin-top: 8px; margin-bottom: 8px; text-align: center; }
        .inserted-image { max-width: 80%; max-height: 400px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); display: block; margin-left: auto; margin-right: auto; }
        .image-caption { font-size: 0.85em; color: #555; margin-top: 4px; padding: 0 10%; line-height: 1.4; }
        .tab-separator { border: 0; border-top: 2px dotted #ccc; margin: 15px 5%; }
        #loading-overlay { position: fixed; inset: 0; background-color: rgba(0, 0, 0, 0.6); display: flex; justify-content: center; align-items: center; z-index: 9999; opacity: 0; transition: opacity 0.3s ease-out; pointer-events: none; }
        #loading-overlay.visible { opacity: 1; pointer-events: auto; }
        .loader { border: 8px solid #f3f3f3; border-top: 8px solid #3498db; border-radius: 50%; width: 60px; height: 60px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .visually-hidden { position: absolute; width: 1px; height: 1px; margin: -1px; padding: 0; overflow: hidden; clip: rect(0, 0, 0, 0); border: 0; }
        .file-input-label { display: inline-block; padding: 0.5rem 1rem; cursor: pointer; border-radius: 0.375rem; background-color: #4f46e5; color: white; font-weight: 600; transition: background-color 0.2s; }
        .file-input-label:hover { background-color: #4338ca; }
        .action-button-container { margin-top: 4px; display: flex; justify-content: flex-start; gap: 8px; flex-wrap: wrap; }
        .action-button { font-size: 0.75rem; padding: 0.125rem 0.5rem; border-radius: 0.25rem; transition: background-color 0.15s ease-in-out, color 0.15s ease-in-out; border: none; cursor: pointer; line-height: 1.5; }
        .action-button:focus { outline: none; box-shadow: 0 0 0 2px rgba(96, 165, 250, 0.5); }
        .action-button-insert { background-color: #e5e7eb; color: #374151; } .action-button-insert:hover { background-color: #d1d5db; }
        .action-button-delete { background-color: #fee2e2; color: #b91c1c; } .action-button-delete:hover { background-color: #fecaca; }
        .action-button-edit { background-color: #dbeafe; color: #1d4ed8; } .action-button-edit:hover { background-color: #bfdbfe; }
        .switch { position: relative; display: inline-block; width: 50px; height: 24px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 24px; }
        .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #2196F3; } input:checked + .slider:before { transform: translateX(26px); }

        /* Footer Styling */
        .app-footer { margin-top: 2rem; padding-top: 1.5rem; border-top: 1px solid #e5e7eb; font-size: 0.875rem; color: #6b7280; }
        .app-footer h4 { font-size: 1rem; font-weight: 600; color: #4b5563; margin-bottom: 0.5rem; }
        .app-footer ul { list-style-type: disc; list-style-position: inside; margin-bottom: 1rem; padding-left: 0.5rem; }
        .app-footer li { margin-bottom: 0.25rem; }
        .app-footer a { color: #4f46e5; text-decoration: underline; transition: color 0.2s; }
        .app-footer a:hover { color: #4338ca; }
        .footer-credits { margin-top: 1rem; text-align: center; }
    </style>
</head>
<body class="bg-gray-100 p-4 md:p-8">
    <div class="container mx-auto max-w-7xl bg-white rounded-lg shadow-xl p-5 md:p-8">
        <h1 class="text-2xl md:text-3xl font-bold mb-4 text-center text-gray-800">ã‚³ã‚³ãƒ•ã‚©ãƒªã‚¢/Tekeyãƒ­ã‚°æ•´å½¢ãƒ„ãƒ¼ãƒ« (ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä¿å­˜å¯¾å¿œ)</h1>
        <div class="mb-6 p-4 border border-blue-200 rounded-lg bg-blue-50 text-sm text-blue-800">
            <h3 class="font-semibold mb-1">ä½¿ã„æ–¹:</h3>
            <ol class="list-decimal list-inside space-y-1">
                <li>ã€Œã‚³ã‚³ãƒ•ã‚©ãƒªã‚¢ãƒ­ã‚°é¸æŠ...ã€ã¾ãŸã¯ã€ŒTekeyãƒ­ã‚°é¸æŠ...ã€ã§HTMLãƒ­ã‚°ã‚’èª­ã¿è¾¼ã‚€ã‹ã€ã€Œãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ(.cclogproj)é¸æŠ...ã€ã§ä»¥å‰ä¿å­˜ã—ãŸä½œæ¥­çŠ¶æ…‹ã‚’èª­ã¿è¾¼ã¿ã¾ã™ã€‚</li>
                <li>ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼è¨­å®šã‚¿ãƒ–ã§è¡¨ç¤ºå/ã‚¢ã‚¤ã‚³ãƒ³/è¡¨æƒ…å·®åˆ†ã‚’è¨­å®šã—ã¾ã™ï¼ˆè¨­å®šã¯LocalStorageã«ä¸€æ™‚ä¿å­˜/èª­è¾¼å¯èƒ½ï¼‰ã€‚</li>
                <li>è¡¨ç¤ºã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã‚¿ãƒ–ã§ãƒ•ã‚©ãƒ³ãƒˆã‚„è‰²ã€è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰ãªã©ã‚’èª¿æ•´ã—ã¾ã™ã€‚</li>
                <li>ãƒ­ã‚°è¡¨ç¤ºã‚¨ãƒªã‚¢ã§ã€ã‚¿ãƒ–/ç™ºè¨€è€…ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã€å…ˆé ­/ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å¾Œã¸ã®ç”»åƒæŒ¿å…¥ã€è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰(ğŸ’¬/ğŸ“)/ã‚¢ã‚¤ã‚³ãƒ³(ã‚¯ãƒªãƒƒã‚¯ã§é¸æŠ)ã®å€‹åˆ¥å¤‰æ›´ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç·¨é›†ãŒå¯èƒ½ã§ã™ã€‚</li>
                <li>ã€Œãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ä¿å­˜ (.cclogproj)ã€ã§ç·¨é›†çŠ¶æ…‹å…¨ä½“ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜ã§ãã¾ã™ã€‚</li>
                <li>ã€Œæ•´å½¢æ¸ˆã¿ãƒ­ã‚°ã‚’ZIPã§å‡ºåŠ›ã€ã§ã€é–²è¦§ãƒ»å…±æœ‰ç”¨ã®HTMLãƒ­ã‚°ã‚»ãƒƒãƒˆã‚’å‡ºåŠ›ã—ã¾ã™ã€‚</li>
            </ol>
        </div>

        <!-- ======[ ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠã‚»ã‚¯ã‚·ãƒ§ãƒ³ ]====== -->
        <div class="mb-6 p-4 border border-dashed border-gray-300 rounded-lg bg-gray-50">
            <div class="flex flex-wrap items-center gap-x-6 gap-y-4">
                <!-- ã‚³ã‚³ãƒ•ã‚©ãƒªã‚¢ãƒ­ã‚°é¸æŠ -->
                <div>
                    <label for="cocofolia-log-input" class="block text-lg font-semibold mb-1 text-gray-700">1a. ã‚³ã‚³ãƒ•ã‚©ãƒªã‚¢ãƒ­ã‚°:</label>
                    <input type="file" id="cocofolia-log-input" accept=".html" class="visually-hidden">
                    <label for="cocofolia-log-input" class="file-input-label">ã‚³ã‚³ãƒ•ã‚©ãƒªã‚¢ãƒ­ã‚°é¸æŠ...</label>
                </div>
                <!-- Tekeyãƒ­ã‚°é¸æŠ -->
                <div>
                    <label for="tekey-log-input" class="block text-lg font-semibold mb-1 text-gray-700">1b. Tekeyãƒ­ã‚°:</label>
                    <input type="file" id="tekey-log-input" accept=".html" class="visually-hidden">
                    <label for="tekey-log-input" class="file-input-label bg-purple-600 hover:bg-purple-700">Tekeyãƒ­ã‚°é¸æŠ...</label>
                </div>
                <!-- ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆèª­ã¿è¾¼ã¿ -->
                <div class="border-l pl-4">
                     <label for="project-load-input" class="block text-lg font-semibold mb-1 text-gray-700">1c. ã¾ãŸã¯ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆèª­è¾¼:</label>
                    <input type="file" id="project-load-input" accept=".cclogproj" class="visually-hidden">
                    <label for="project-load-input" class="file-input-label bg-green-600 hover:bg-green-700">ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ(.cclogproj)é¸æŠ...</label>
                </div>
            </div>
            <div class="mt-3">
                 <span id="file-info" class="text-sm font-medium text-blue-600 align-middle">ãƒ•ã‚¡ã‚¤ãƒ«ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“</span>
                 <span id="project-load-info" class="ml-3 text-sm font-medium text-green-600 align-middle"></span>
            </div>
             <p class="mt-2 text-sm text-gray-500">ã‚³ã‚³ãƒ•ã‚©ãƒªã‚¢HTMLãƒ­ã‚°ã€Tekey HTMLãƒ­ã‚° (v2å½¢å¼æ¨å¥¨)ã€ã¾ãŸã¯ä»¥å‰ä¿å­˜ã—ãŸæ•´å½¢ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«(.cclogproj)ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚</p>
        </div>
        <!-- ================================ -->

        <div class="mb-6">
             <div class="border-b border-gray-200">
                <nav class="-mb-px flex space-x-6" aria-label="Tabs">
                    <button id="tab-btn-settings" data-tab-target="settings" class="whitespace-nowrap py-3 px-1 border-b-2 font-medium text-sm border-indigo-500 text-indigo-600" aria-current="page">ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼è¨­å®š</button>
                    <button id="tab-btn-customize" data-tab-target="customize" class="whitespace-nowrap py-3 px-1 border-b-2 font-medium text-sm border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300">è¡¨ç¤ºã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º</button>
                </nav>
            </div>

            <div id="settings-panel-settings" class="mt-4 p-4 border rounded-lg bg-gray-50" role="tabpanel" aria-labelledby="tab-btn-settings">
                <h3 class="text-lg font-semibold mb-3 text-gray-700">2. ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼è¨­å®š:</h3>
                <p class="text-sm text-gray-600 mb-4">ãƒ­ã‚°ã‹ã‚‰æ¤œå‡ºã•ã‚ŒãŸç™ºè¨€è€…åã§ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®è¡¨ç¤ºå/ã‚¢ã‚¤ã‚³ãƒ³ã€è¡¨æƒ…å·®åˆ†ã‚¢ã‚¤ã‚³ãƒ³ã‚’è¨­å®šã—ã¦ãã ã•ã„ã€‚</p>
                <div id="character-settings" class="space-y-4"><p class="text-gray-500 italic">ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã¾ãŸã¯ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€ã¨è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</p></div>
                 <button id="save-settings-button" class="mt-4 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed" disabled>è¨­å®šã‚’ä¸€æ™‚ä¿å­˜(LocalStorage)</button>
                 <button id="load-settings-button" class="mt-4 ml-2 px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed" disabled>è¨­å®šã‚’èª­ã¿è¾¼ã¿(LocalStorage)</button>
                 <p class="text-xs text-gray-500 mt-1">â€»ã“ã®ä¿å­˜/èª­è¾¼ã¯ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã¨ã¯åˆ¥ã§ã™ã€‚</p>
            </div>

            <div id="settings-panel-customize" class="hidden mt-4 p-4 border rounded-lg bg-gray-50" role="tabpanel" aria-labelledby="tab-btn-customize">
                 <h3 class="text-lg font-semibold mb-3 text-gray-700">è¡¨ç¤ºã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º:</h3>
                 <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div><label for="bubble-normal-color" class="block text-sm font-medium text-gray-700">å¹ãå‡ºã—è‰²:</label><input type="color" id="bubble-normal-color" value="#ffffff" class="mt-1 block w-full h-8 rounded border border-gray-300 cursor-pointer p-0.5"></div>
                    <div><label for="font-size-slider" class="block text-sm font-medium text-gray-700">ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚º: <span id="font-size-value">16</span>px</label><input type="range" id="font-size-slider" min="10" max="24" value="16" class="mt-1 block w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"></div>
                    <div><label for="background-color" class="block text-sm font-medium text-gray-700">èƒŒæ™¯è‰²:</label><input type="color" id="background-color" value="#f3f4f6" class="mt-1 block w-full h-8 rounded border border-gray-300 cursor-pointer p-0.5"></div>
                    <div><label for="icon-size-slider" class="block text-sm font-medium text-gray-700">ã‚¢ã‚¤ã‚³ãƒ³ã‚µã‚¤ã‚º: <span id="icon-size-value">64</span>px</label><input type="range" id="icon-size-slider" min="24" max="64" value="64" class="mt-1 block w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"></div>
                    <div class="md:col-span-2"><label for="bubble-width-slider" class="block text-sm font-medium text-gray-700">å¹ãå‡ºã—æœ€å¤§å¹…: <span id="bubble-width-value">80</span>%</label><input type="range" id="bubble-width-slider" min="30" max="100" value="80" class="mt-1 block w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"></div>
                    <div class="md:col-span-2"><label for="font-family-select" class="block text-sm font-medium text-gray-700">ãƒ•ã‚©ãƒ³ãƒˆ:</label><select id="font-family-select" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 bg-white focus:border-indigo-500 focus:ring-indigo-500"><option value="font-noto-sans" selected>'Noto Sans JP' (æ¨å¥¨)</option><option value="font-inter">'Inter' (UIæ¨™æº–)</option><option value="font-noto-serif">'Noto Serif JP' (æ˜æœ)</option><option value="font-mplus-rounded">'M PLUS Rounded 1c' (ä¸¸ã‚´ã‚·ãƒƒã‚¯)</option><option value="font-system-sans">ã‚·ã‚¹ãƒ†ãƒ æ¨™æº–ã‚´ã‚·ãƒƒã‚¯</option><option value="font-system-serif">ã‚·ã‚¹ãƒ†ãƒ æ¨™æº–æ˜æœ</option><option value="font-system-mono">ã‚·ã‚¹ãƒ†ãƒ æ¨™æº–ç­‰å¹…</option></select></div>
                    <div class="md:col-span-2 flex items-center space-x-2"><label for="name-below-icon-toggle" class="text-sm font-medium text-gray-700">åå‰ã‚’ã‚¢ã‚¤ã‚³ãƒ³ä¸‹ã«è¡¨ç¤º:</label><label class="switch"><input type="checkbox" id="name-below-icon-toggle"><span class="slider"></span></label></div>
                    <div class="md:col-span-2"><label for="log-height-slider" class="block text-sm font-medium text-gray-700">ãƒ­ã‚°è¡¨ç¤ºé«˜ã•: <span id="log-height-value">384</span>px</label><input type="range" id="log-height-slider" min="200" max="800" value="384" class="mt-1 block w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"></div>
                    <div class="md:col-span-2 flex items-center space-x-2">
                        <label for="skip-delete-confirm-toggle" class="text-sm font-medium text-gray-700">å‰Šé™¤ç¢ºèªã‚’çœç•¥:</label>
                        <label class="switch">
                            <input type="checkbox" id="skip-delete-confirm-toggle">
                            <span class="slider"></span>
                        </label>
                    </div>
                 </div>
                 <button id="apply-customization" class="mt-4 px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600">ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºé©ç”¨</button>
                 <button id="reset-customization" class="mt-4 ml-2 px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600">ãƒªã‚»ãƒƒãƒˆ</button>
            </div>
        </div>

        <div class="mb-6">
            <h3 class="text-lg font-semibold mb-3 text-gray-700">3. ãƒ­ã‚°è¡¨ç¤º:</h3>
            <div class="mb-4 p-3 border rounded-lg bg-gray-50 flex flex-wrap items-center justify-between gap-4">
                 <div class="flex flex-wrap items-center gap-x-4 gap-y-2">
                     <div><label for="speaker-filter" class="block text-sm font-medium text-gray-700">ç™ºè¨€è€…:</label><select id="speaker-filter" class="mt-1 block w-full md:w-auto rounded-md border-gray-300 shadow-sm p-2 text-sm bg-white focus:border-indigo-500 focus:ring-indigo-500" disabled><option value="all">ã™ã¹ã¦ã®ç™ºè¨€è€…</option></select></div>
                     <div><span class="block text-sm font-medium text-gray-700">ã‚¿ãƒ–:</span><nav id="log-tabs" class="mt-1 -mb-px flex space-x-2 overflow-x-auto pb-1" aria-label="Log Tabs"><span class="whitespace-nowrap py-2 px-1 text-gray-500 text-sm italic">ãƒ­ã‚°èª­è¾¼ä¸­</span></nav></div>
                 </div>
                 <div><button id="add-header-image-button" class="mt-2 md:mt-0 px-3 py-1.5 bg-teal-500 text-white text-sm font-medium rounded-md hover:bg-teal-600 disabled:opacity-50 disabled:cursor-not-allowed" disabled>å…ˆé ­ã«ç”»åƒã‚’è¿½åŠ </button></div>
            </div>

            <div id="log-display" class="overflow-y-auto border border-gray-300 rounded-lg p-4 bg-white space-y-1 font-noto-sans" style="--bubble-max-width: 80%; --bubble-bg-color: #ffffff; --bubble-arrow-color: #ffffff; --icon-size: 64px;" aria-live="polite">
                <p class="text-gray-500 text-center italic">ã“ã“ã«æ•´å½¢ã•ã‚ŒãŸãƒ­ã‚°ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</p>
            </div>
        </div>

        <div class="mt-8 text-center">
             <h3 class="text-lg font-semibold mb-3 text-gray-700">4. ä¿å­˜ / ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ:</h3>
             <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4 max-w-lg mx-auto text-left">
                 <div>
                     <label for="export-html-title" class="block text-sm font-medium text-gray-700">HTMLã‚¿ã‚¤ãƒˆãƒ« / ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå:</label>
                     <input type="text" id="export-html-title" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-1.5 focus:border-indigo-500 focus:ring-indigo-500 text-sm" placeholder="ä¾‹: ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ­ã‚°" disabled>
                 </div>
                 <div>
                     <label for="export-zip-filename" class="block text-sm font-medium text-gray-700">ZIPãƒ•ã‚¡ã‚¤ãƒ«å / ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«å:</label>
                     <input type="text" id="export-zip-filename" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-1.5 focus:border-indigo-500 focus:ring-indigo-500 text-sm" placeholder="ä¾‹: log_export" disabled>
                 </div>
             </div>
             <div class="flex flex-wrap justify-center items-center gap-4">
                 <button id="save-project-button" class="px-6 py-3 bg-green-600 text-white font-semibold rounded-lg shadow hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed" disabled>ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ä¿å­˜ (.cclogproj)</button>
                 <button id="export-zip-button" class="px-6 py-3 bg-indigo-600 text-white font-semibold rounded-lg shadow hover:bg-indigo-700 disabled:opacity-50 disabled:cursor-not-allowed" disabled>æ•´å½¢æ¸ˆã¿ãƒ­ã‚°ã‚’ZIPã§å‡ºåŠ›</button>
             </div>
             <p class="mt-2 text-sm text-gray-500">ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã«ã¯ç·¨é›†çŠ¶æ…‹å…¨ä½“ãŒä¿å­˜ã•ã‚Œã¾ã™ã€‚</p>
             <p class="mt-2 text-sm text-gray-500">æ•´å½¢æ¸ˆã¿ãƒ­ã‚°ZIPã«ã¯ã€è¡¨ç¤ºç”¨ã®HTML/CSS/ç”»åƒãŒå«ã¾ã‚Œã¾ã™ã€‚</p>
             <p class="text-xs text-gray-500">ï¼ˆæ³¨æ„: Google Fontsã¯ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã§ã¯è¡¨ç¤ºã•ã‚Œã¾ã›ã‚“ï¼‰</p>
        </div>

        <footer class="app-footer">
            <h4>æ›´æ–°å±¥æ­´</h4>
            <ul>
                 <li>2025/05/06: å…ˆé ­ç”»åƒæŒ¿å…¥æ©Ÿèƒ½ã€å·®åˆ†æ©Ÿèƒ½ã€ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãƒ»ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿèƒ½è¿½åŠ ã€Tekeyãƒ­ã‚°èª­ã¿è¾¼ã¿æ©Ÿèƒ½è¿½åŠ </li>
                 <li>2025/05/03: å…¬é–‹</li>
            </ul>
            <div class="footer-credits">
                ä½œæˆè€…: ã—ã‚‹ã¹ (<a href="https://x.com/qxoiUioxp" target="_blank" rel="noopener noreferrer">@qxoiUioxp</a>)
            </div>
        </footer>
    </div>

    <!-- Hidden Inputs -->
    <input type="file" id="insert-image-input" accept="image/*" class="visually-hidden">
    <input type="file" id="message-icon-change-input" accept="image/*" class="visually-hidden">
    <input type="file" id="expression-icon-input-generic-placeholder" accept="image/*" class="visually-hidden">

    <!-- Loading Overlay -->
    <div id="loading-overlay" aria-hidden="true" aria-label="å‡¦ç†ä¸­"><div class="loader"></div></div>

    <!-- Icon Selection Dropdown Placeholder -->
    <div id="icon-select-dropdown" class="icon-select-dropdown hidden"></div>

    <script>
      // Wrap entire script in an IIFE (Immediately Invoked Function Expression)
      (function() {
        "use strict"; // Enable strict mode

        // --- State Variables ---
        let displayLogData = []; // Holds the unified log data being edited
        let characterSettings = {};
        let customizationSettings = {
            normalBubbleColor: '#ffffff', fontSize: 16, backgroundColor: '#f3f4f6',
            iconSize: 64, bubbleMaxWidth: 80, nameBelowIconMode: false,
            fontFamily: 'font-noto-sans', logDisplayHeight: 384,
            skipDeleteConfirm: false
         };
         let currentTabFilter = 'all';
         let currentSpeakerFilter = 'all';
         let uploadedFiles = {}; // key: File object (or Blob)
         let isProcessingFile = false;
         let speakerFrequencies = {};
         let imageInsertTargetIndex = -2;
         let nextUniqueId = 0;
         let logFileNameBase = 'session_log'; // Changed default
         let uniqueTabsFound = new Set();
         let speakerDataForExport = {};
         let messageIconChangeTargetId = null;
         let currentDropdown = null;
         let expressionAddContext = { speaker: null, inputElement: null };

         // Project file constants
         const PROJECT_FILE_EXTENSION = '.cclogproj';
         const PROJECT_DATA_FILENAME = 'project_data.json';
         const PROJECT_IMAGES_FOLDER = 'images/';
         const PROJECT_FILE_FORMAT_VERSION = '1.1'; // Version bump for Tekey support marker (optional)
         const APP_VERSION = '9.0-tekey-support-tabfix'; // Updated version

        // --- DOM Elements ---
        // ======[ ãƒ•ã‚¡ã‚¤ãƒ«å…¥åŠ›è¦ç´ ã®å–å¾— ]======
        const cocofoliaFileInput = document.getElementById('cocofolia-log-input');
        const tekeyFileInput = document.getElementById('tekey-log-input');
        const projectLoadInput = document.getElementById('project-load-input');
        const fileInfoSpan = document.getElementById('file-info');
        const projectLoadInfoSpan = document.getElementById('project-load-info');
        // ===================================================
        const characterSettingsDiv = document.getElementById('character-settings');
        const logTabsNav = document.getElementById('log-tabs');
        const speakerFilterSelect = document.getElementById('speaker-filter');
        const logDisplayDiv = document.getElementById('log-display');
        const exportButton = document.getElementById('export-zip-button');
        const saveProjectButton = document.getElementById('save-project-button');
        const loadingOverlay = document.getElementById('loading-overlay');
        const saveSettingsButton = document.getElementById('save-settings-button');
        const loadSettingsButton = document.getElementById('load-settings-button');
        const settingsTabButton = document.getElementById('tab-btn-settings');
        const customizeTabButton = document.getElementById('tab-btn-customize');
        const settingsPanel = document.getElementById('settings-panel-settings');
        const customizePanel = document.getElementById('settings-panel-customize');
        const normalColorInput = document.getElementById('bubble-normal-color');
        const fontSizeSlider = document.getElementById('font-size-slider');
        const fontSizeValueSpan = document.getElementById('font-size-value');
        const backgroundColorInput = document.getElementById('background-color');
        const iconSizeSlider = document.getElementById('icon-size-slider');
        const iconSizeValueSpan = document.getElementById('icon-size-value');
        const bubbleWidthSlider = document.getElementById('bubble-width-slider');
        const bubbleWidthValueSpan = document.getElementById('bubble-width-value');
        const nameBelowIconToggle = document.getElementById('name-below-icon-toggle');
        const fontFamilySelect = document.getElementById('font-family-select');
        const applyCustomizationButton = document.getElementById('apply-customization');
        const resetCustomizationButton = document.getElementById('reset-customization');
        const insertImageInput = document.getElementById('insert-image-input');
        const exportHtmlTitleInput = document.getElementById('export-html-title');
        const exportZipFilenameInput = document.getElementById('export-zip-filename');
        const logHeightSlider = document.getElementById('log-height-slider');
        const logHeightValueSpan = document.getElementById('log-height-value');
        const iconChangeInput = document.getElementById('message-icon-change-input');
        const iconSelectDropdown = document.getElementById('icon-select-dropdown');
        const addHeaderImageButton = document.getElementById('add-header-image-button');
        const skipDeleteConfirmToggle = document.getElementById('skip-delete-confirm-toggle');

        // --- Constants ---
        const PLACEHOLDER_ICON_URL = 'https://placehold.co/64x64/e0e0e0/757575?text=?';
        const LOCALSTORAGE_SETTINGS_KEY = 'logToolSettings_v9.0'; // Version up
        const LOCALSTORAGE_CUSTOMIZATION_KEY = 'logToolCustomization_v9.0'; // Version up
        const FONT_CLASSES = [
             'font-inter', 'font-noto-sans', 'font-noto-serif',
             'font-mplus-rounded', 'font-system-sans', 'font-system-serif',
             'font-system-mono'
        ];
        const MAX_FILE_SIZE_MB = 5;
        const MAX_INSERT_IMAGE_SIZE_MB = 10;
        const MAX_FILE_SIZE_BYTES = MAX_FILE_SIZE_MB * 1024 * 1024;
        const MAX_INSERT_IMAGE_SIZE_BYTES = MAX_INSERT_IMAGE_SIZE_MB * 1024 * 1024;
        const HEADER_IMAGE_INDEX = -1;


        // --- Utility Functions ---
        function escapeHtml(unsafe) { if (typeof unsafe !== 'string') return ''; return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;"); }
        function escapeCssSelector(str) { if (!str) return ''; return str.replace(/([!"#$%&'()*+,.\/:;<=>?@[\\\]^`{|}~])/g, '\\$1'); }
        function showLoading() { if (loadingOverlay) { loadingOverlay.classList.add('visible'); loadingOverlay.setAttribute('aria-hidden', 'false'); } }
        function hideLoading() { if (loadingOverlay) { loadingOverlay.classList.remove('visible'); loadingOverlay.setAttribute('aria-hidden', 'true'); } }
        function readFileAsText(file) { return new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = () => resolve(reader.result); reader.onerror = () => reject(reader.error || new Error(`Failed to read file: ${file.name}`)); reader.readAsText(file, 'UTF-8'); }); }
        function readFileAsDataURL(file) { return new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = () => resolve(reader.result); reader.onerror = () => reject(reader.error || new Error(`Failed to read file as Data URL: ${file.name}`)); reader.readAsDataURL(file); }); }
        function generateUniqueId(prefix = 'item') { return `${prefix}_${nextUniqueId++}`; }
        function generateBaseFilename(filename) {
            if (!filename) return 'session_log';
            let base = filename.replace(/\.[^/.]+$/, "");
            // Remove common log type indicators from filename if present
            base = base.replace(/\[.*?\]/g, '').replace(/\(all\)/i, '').trim();
            base = base.replace(/[\\/:*?"<>|]/g, '_');
            return base || 'session_log';
        }
        function sanitizeForFilename(name) {
             if (!name) return '';
             return String(name).trim().replace(/[\\/:*?"<>|\s#\.\[\]\{\}%&+,;=]/g, '_').replace(/_+/g, '_');
        }
        function getImagePathForKey(key, fileObject) {
            if (!fileObject || !(fileObject instanceof Blob)) { console.warn(`getImagePathForKey: Invalid fileObject for key ${key}`); return null; }
            let outputFilename = null;
            const fileExtension = fileObject.name?.split('.').pop()?.toLowerCase() || 'png';

            if (key.startsWith('img_')) { const safeKeyBase = sanitizeForFilename(key); outputFilename = `${safeKeyBase}.${fileExtension}`; }
            else if (key.startsWith('icon_msg_')) { const msgIdPart = key.substring(9); const safeMsgIdPart = sanitizeForFilename(msgIdPart); outputFilename = `${safeMsgIdPart}_override.${fileExtension}`; } // icon_msg_ instead of icon_
            else if (key.startsWith('exp_')) { const parts = key.match(/^exp_(.+?)_(.+)$/); if (parts && parts.length === 3) { const safeSpeakerName = sanitizeForFilename(parts[1]); const safeExpName = sanitizeForFilename(parts[2]); outputFilename = `${safeSpeakerName}_${safeExpName}.${fileExtension}`; } }
            else { const safeSpeakerName = sanitizeForFilename(key); outputFilename = `${safeSpeakerName}_icon.${fileExtension}`; }
            return outputFilename ? `${PROJECT_IMAGES_FOLDER}${outputFilename}` : null;
        }
        function createFileFromBlob(blob, filename) { try { return new File([blob], filename, { type: blob.type || 'application/octet-stream', lastModified: Date.now() }); } catch (e) { console.warn("File constructor failed, creating simple Blob with name property.", e); try { blob.name = filename; blob.lastModifiedDate = new Date(); return blob; } catch (blobError){ console.error("Could not create File or add name to Blob.", blobError); return null; } } }


        // --- Core Logic Functions ---

        // ======[ ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†é–‹å§‹/çµ‚äº†/ãƒãƒ³ãƒ‰ãƒ©ã®åˆ†é›¢ ]======
        function startFileProcessing(file, logTypeLabel) {
            if (isProcessingFile) { console.warn("Processing already in progress."); return false; }
            isProcessingFile = true;
            fileInfoSpan.textContent = `èª­è¾¼ä¸­ (${logTypeLabel}): ${escapeHtml(file.name)}...`;
            projectLoadInfoSpan.textContent = ''; // Clear project load info
            logFileNameBase = generateBaseFilename(file.name);
            exportHtmlTitleInput.value = logFileNameBase;
            exportZipFilenameInput.value = logFileNameBase;
            console.log(`[${new Date().toISOString()}] Starting ${logTypeLabel} file processing: ${file.name}`);
            showLoading();
            resetAppState();
            return true;
        }

        function endFileProcessing(file, success, errorMessage) {
            hideLoading();
            isProcessingFile = false;
            if (success) {
                fileInfoSpan.textContent = `èª­è¾¼å®Œäº†: ${escapeHtml(file.name)} (${displayLogData.length}ä»¶)`;
                enableControls();
                console.log(`[${new Date().toISOString()}] File processing finished successfully.`);
            } else {
                console.error(`[${new Date().toISOString()}] Error during file processing:`, errorMessage);
                alert(`å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${errorMessage}`);
                fileInfoSpan.textContent = 'å‡¦ç†ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ';
                logDisplayDiv.innerHTML = '<p class="text-red-500 text-center font-semibold">ãƒ­ã‚°ã®å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚</p>';
                disableControls();
                resetAppState();
            }
            // Clear the specific file input that triggered the load
            if (cocofoliaFileInput) cocofoliaFileInput.value = null;
            if (tekeyFileInput) tekeyFileInput.value = null;
        }

        async function handleCocofoliaFileSelect(event) {
            const file = event.target.files?.[0];
            if (!file) { fileInfoSpan.textContent = 'ãƒ•ã‚¡ã‚¤ãƒ«ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“'; return; }
            if (!file.name.toLowerCase().endsWith('.html')) { alert('ã‚³ã‚³ãƒ•ã‚©ãƒªã‚¢HTMLãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚'); fileInfoSpan.textContent = 'HTMLãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„'; event.target.value = null; return; }

            if (!startFileProcessing(file, "ã‚³ã‚³ãƒ•ã‚©ãƒªã‚¢")) { event.target.value = null; return; }

            let success = false; let errorMessage = '';
            try {
                const fileContent = await readFileAsText(file);
                if (!fileContent || fileContent.trim().length === 0) throw new Error("ãƒ•ã‚¡ã‚¤ãƒ«ãŒç©ºã‹ã€å†…å®¹ã‚’èª­ã¿å–ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚");
                console.log(`   [handleCocofoliaFileSelect] File read complete. Parsing HTML...`);
                await new Promise(resolve => setTimeout(resolve, 50)); // Short delay for UI update

                const parsedData = parseCocofoliaLogHtml(fileContent); // Parse into temporary array
                console.log(`   [handleCocofoliaFileSelect] Parsing complete. Found ${parsedData.length} items.`);
                initializeAfterParse(parsedData); // Initialize state from parsed data
                success = true;

            } catch (error) {
                errorMessage = error.message || 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼';
                success = false;
            } finally {
                endFileProcessing(file, success, errorMessage);
            }
        }

        async function handleTekeyFileSelect(event) {
            const file = event.target.files?.[0];
            if (!file) { fileInfoSpan.textContent = 'ãƒ•ã‚¡ã‚¤ãƒ«ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“'; return; }
            if (!file.name.toLowerCase().endsWith('.html')) { alert('Tekey HTMLãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚'); fileInfoSpan.textContent = 'HTMLãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„'; event.target.value = null; return; }

            if (!startFileProcessing(file, "Tekey")) { event.target.value = null; return; }

            let success = false; let errorMessage = '';
            try {
                const fileContent = await readFileAsText(file);
                if (!fileContent || fileContent.trim().length === 0) throw new Error("ãƒ•ã‚¡ã‚¤ãƒ«ãŒç©ºã‹ã€å†…å®¹ã‚’èª­ã¿å–ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚");
                console.log(`   [handleTekeyFileSelect] File read complete. Parsing HTML...`);
                await new Promise(resolve => setTimeout(resolve, 50)); // Short delay for UI update

                const parsedData = parseTekeyLogHtml(fileContent); // Parse into temporary array
                console.log(`   [handleTekeyFileSelect] Parsing complete. Found ${parsedData.length} items.`);
                initializeAfterParse(parsedData); // Initialize state from parsed data
                success = true;

            } catch (error) {
                errorMessage = error.message || 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼';
                success = false;
            } finally {
                endFileProcessing(file, success, errorMessage);
            }
        }

        async function handleProjectLoadFile(event) {
            // This remains mostly the same, but call endFileProcessing at the end
            if (isProcessingFile) { console.warn("Processing already in progress."); event.target.value = null; return; }
            const file = event.target.files?.[0];
            if (!file) { projectLoadInfoSpan.textContent = 'ãƒ•ã‚¡ã‚¤ãƒ«ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“'; return; }
            if (!file.name.toLowerCase().endsWith(PROJECT_FILE_EXTENSION)) { alert(`ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ« (${PROJECT_FILE_EXTENSION}) ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚`); projectLoadInfoSpan.textContent = `ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„`; event.target.value = null; return; }

            isProcessingFile = true;
            projectLoadInfoSpan.textContent = `ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆèª­è¾¼ä¸­: ${escapeHtml(file.name)}...`;
            fileInfoSpan.textContent = ''; showLoading();
            resetAppState();

            let success = false; let errorMessage = '';
            try {
                await loadProject(file); // Call the project loading function
                projectLoadInfoSpan.textContent = `ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆèª­è¾¼å®Œäº†: ${escapeHtml(file.name)}`;
                 // Set title/filename inputs based on loaded project name
                 const baseName = file.name.replace(PROJECT_FILE_EXTENSION, '');
                 exportHtmlTitleInput.value = logFileNameBase || baseName; // Use logFileNameBase if available in project data
                 exportZipFilenameInput.value = logFileNameBase || baseName;
                 success = true;

            } catch (error) {
                 errorMessage = error.message || 'ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼';
                 success = false;
            } finally {
                 hideLoading(); // Hide loading inside endFileProcessing now
                 isProcessingFile = false; // Set inside endFileProcessing now
                 if (projectLoadInput) projectLoadInput.value = null;
                 // Use a slightly different message structure for project load
                 if (success) {
                     enableControls();
                     console.log(`[${new Date().toISOString()}] Project loaded successfully.`);
                 } else {
                     console.error(`[${new Date().toISOString()}] Error loading project:`, errorMessage);
                     alert(`ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®èª­ã¿è¾¼ã¿ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:\n${errorMessage}`);
                     projectLoadInfoSpan.textContent = 'ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼';
                     logDisplayDiv.innerHTML = '<p class="text-red-500 text-center font-semibold">ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚</p>';
                     disableControls();
                     resetAppState();
                 }
            }
        }
        // ===================================================================

        // ======[ è§£æå¾Œã®å…±é€šåˆæœŸåŒ–å‡¦ç† ]======
        function initializeAfterParse(parsedData) {
             // Calculate frequencies and tabs from parsed data
             speakerFrequencies = {}; uniqueTabsFound = new Set();
             parsedData.forEach(item => {
                 if (item.type === 'message') {
                     if(item.speaker && item.speaker !== 'system' && item.speaker !== 'ä¸æ˜') { speakerFrequencies[item.speaker] = (speakerFrequencies[item.speaker] || 0) + 1; }
                     if (item.tab) { uniqueTabsFound.add(item.tab); }
                 } else if (item.type === 'image') {
                     // For newly parsed data, images don't exist yet, so skip tab finding for them
                 }
             });
             if (uniqueTabsFound.size > 0 && !uniqueTabsFound.has('all')) uniqueTabsFound.add('all');
             else if (uniqueTabsFound.size === 0) uniqueTabsFound = new Set(['all']);

             // Initialize displayLogData (crucial step)
             displayLogData = parsedData.map(item => {
                 if (item.type === 'message') {
                     const initialDisplayMode = (item.speaker === 'system') ? 'narration' : 'bubble';
                     return { ...item, displayMode: initialDisplayMode, iconKey: 'default', overrideIconSrc: null };
                 }
                 // Add other types if needed, e.g., handling errors during parsing
                 else if (item.type === 'error') {
                     return { ...item, displayMode: 'narration', iconKey: 'default', overrideIconSrc: null };
                 }
                 return item; // Should only be 'message' or 'error' from parsing functions
             });
             console.log(`   [initializeAfterParse] Initialized displayLogData with ${displayLogData.length} items.`);

             initializeCharacterSettings(); // Based on calculated speakerFrequencies
             updateSpeakerDataForExport();
             populateCharacterSettingsUI();
             populateTabsUI(); // Based on calculated uniqueTabsFound
             populateSpeakerFilterUI(); // Based on calculated speakerFrequencies
             renderLog(); // Apply initial customization and render
         }
         // ===================================================

        function resetAppState() {
             displayLogData = []; characterSettings = {};
             currentTabFilter = 'all'; currentSpeakerFilter = 'all'; uploadedFiles = {};
             speakerFrequencies = {}; uniqueTabsFound = new Set(['all']);
             nextUniqueId = 0; imageInsertTargetIndex = -2; speakerDataForExport = {};
             messageIconChangeTargetId = null; expressionAddContext = { speaker: null, inputElement: null };
             logFileNameBase = 'session_log'; exportHtmlTitleInput.value = logFileNameBase; exportZipFilenameInput.value = logFileNameBase;
             projectLoadInfoSpan.textContent = ''; fileInfoSpan.textContent = 'ãƒ•ã‚¡ã‚¤ãƒ«ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“';
             characterSettingsDiv.innerHTML = '<p class="text-gray-500 italic">ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã¾ãŸã¯ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€ã¨è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</p>';
             logTabsNav.innerHTML = '<span class="whitespace-nowrap py-2 px-1 text-gray-500 text-sm italic">ãƒ­ã‚°èª­è¾¼ä¸­</span>';
             speakerFilterSelect.innerHTML = '<option value="all">ã™ã¹ã¦ã®ç™ºè¨€è€…</option>';
             logDisplayDiv.innerHTML = '<p class="text-gray-500 text-center italic">ã“ã“ã«æ•´å½¢ã•ã‚ŒãŸãƒ­ã‚°ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</p>';
             resetCustomizationDefaults(); updateCustomizationUI(); disableControls();
             if (iconChangeInput) iconChangeInput.value = null; if (insertImageInput) insertImageInput.value = null;
             // ======[ ãƒ•ã‚¡ã‚¤ãƒ«å…¥åŠ›ã®ã‚¯ãƒªã‚¢ ]======
             if (cocofoliaFileInput) cocofoliaFileInput.value = null;
             if (tekeyFileInput) tekeyFileInput.value = null;
             if (projectLoadInput) projectLoadInput.value = null;
             // ============================================
             closeIconDropdown(); console.log("Application state reset.");
        }

        function enableControls() {
             exportButton.disabled = false; saveProjectButton.disabled = false; saveSettingsButton.disabled = false; loadSettingsButton.disabled = false;
             speakerFilterSelect.disabled = Object.keys(speakerFrequencies).length === 0;
             exportHtmlTitleInput.disabled = false; exportZipFilenameInput.disabled = false; addHeaderImageButton.disabled = false; console.log("Controls enabled.");
        }
        function disableControls() {
            exportButton.disabled = true; saveProjectButton.disabled = true; saveSettingsButton.disabled = true; loadSettingsButton.disabled = true;
            speakerFilterSelect.disabled = true; exportHtmlTitleInput.disabled = true; exportZipFilenameInput.disabled = true; addHeaderImageButton.disabled = true; console.log("Controls disabled.");
        }

        // ======[ ãƒ­ã‚°è§£æé–¢æ•° ]======
        function parseCocofoliaLogHtml(htmlContent) {
            console.log("   [parseCocofoliaLogHtml] Starting HTML parsing...");
            const parser = new DOMParser(); const doc = parser.parseFromString(htmlContent, 'text/html');
            if (!doc || !doc.body) throw new Error("ã‚³ã‚³ãƒ•ã‚©ãƒªã‚¢HTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®è§£æã«å¤±æ•—ã—ã¾ã—ãŸã€‚");
            const paragraphs = doc.body.querySelectorAll('p');
            console.log(`   [parseCocofoliaLogHtml] Found ${paragraphs.length} potential message elements.`);
            const tempData = [];
            let currentUniqueId = 0;
            paragraphs.forEach((p, index) => {
                if (!p.textContent?.trim()) return;
                try {
                    const spans = p.querySelectorAll('span');
                    if (spans.length >= 3) {
                        const tabMatch = spans[0]?.textContent?.match(/\[(.*?)\]/);
                        const tab = tabMatch?.[1]?.trim() || 'main';
                        const speaker = spans[1]?.textContent?.trim().replace(/[:ï¼š]$/, '').trim() || 'ä¸æ˜';
                        const message = spans[2]?.innerHTML?.trim() ?? ''; // Use innerHTML to keep formatting like <br>
                        const colorMatch = p.getAttribute('style')?.match(/color:\s*(#[0-9a-fA-F]{3,6}|rgba?\([^)]+\)|[a-zA-Z]+)/);
                        const color = colorMatch?.[1]?.trim() || '#000000';
                        tempData.push({
                            type: 'message', id: generateUniqueId('msg'), // Generate ID here
                            originalIndex: index, tab: tab, speaker: speaker, color: color, message: message
                        });
                        currentUniqueId++; // Increment counter for nextUniqueId usage elsewhere
                    } else console.warn(`   [parseCocofoliaLogHtml] Skipping paragraph at index ${index} due to unexpected span count (${spans.length}).`);
                } catch (parseError) {
                    console.error(`   [parseCocofoliaLogHtml] Error parsing paragraph at index ${index}:`, parseError, p.outerHTML);
                    tempData.push({ type: 'error', id: generateUniqueId('err'), originalIndex: index, message: `ãƒ­ã‚°ã®è§£æã‚¨ãƒ©ãƒ¼ (è¡Œ ${index + 1})`, details: p.textContent?.substring(0, 100) || 'å†…å®¹ä¸æ˜' });
                    currentUniqueId++;
                }
            });
            nextUniqueId = currentUniqueId; // Set global counter after parsing
            console.log(`   [parseCocofoliaLogHtml] Parsing finished. Parsed ${tempData.length} items.`);
            return tempData;
        }

        function parseTekeyLogHtml(htmlContent) {
            console.log("   [parseTekeyLogHtml] Starting Tekey HTML parsing...");
            const parser = new DOMParser(); const doc = parser.parseFromString(htmlContent, 'text/html');
            const chatlogDiv = doc.querySelector('.chatlog');
            if (!chatlogDiv) throw new Error("Tekeyãƒ­ã‚°ã® '.chatlog' è¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚Tekey v2å½¢å¼ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚");

            // --- è¿½åŠ : ã‚¿ãƒ–åã¨IDã®ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’ä½œæˆ ---
            const tabNameMap = {};
            const tabLabels = doc.querySelectorAll('.tab-list label.tab-checkbox');
            console.log(`   [parseTekeyLogHtml] Found ${tabLabels.length} tab definitions.`);
            tabLabels.forEach(label => {
                const input = label.querySelector('input[id^="tab"]');
                if (input && input.id) {
                    // inputè¦ç´ ã‚’é™¤ã„ãŸãƒ†ã‚­ã‚¹ãƒˆéƒ¨åˆ†ã‚’å–å¾—ï¼ˆã“ã‚ŒãŒã‚¿ãƒ–åï¼‰
                    // label.textContent ã ã¨ input ã®ä¸­èº«ã¾ã§å–ã£ã¦ã—ã¾ã†å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ã€ã‚ˆã‚Šå®‰å…¨ãªæ–¹æ³•ã«ä¿®æ­£
                    let tabName = '';
                    label.childNodes.forEach(node => {
                        if (node.nodeType === Node.TEXT_NODE) {
                            tabName += node.textContent;
                        }
                    });
                    tabName = tabName.trim();

                    if (tabName) {
                         tabNameMap[input.id] = tabName;
                         console.log(`       Mapping tab ID "${input.id}" to name "${tabName}"`);
                    } else {
                         // ã‚‚ã—ãƒ†ã‚­ã‚¹ãƒˆãƒãƒ¼ãƒ‰ãŒãªã‘ã‚Œã°ã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¨ã—ã¦è¦ç´ å…¨ä½“ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’ä½¿ã†ï¼ˆinputã‚¿ã‚°ã¯å¾Œã§å‰Šé™¤ã•ã‚Œã‚‹ã¯ãšï¼‰
                         const fallbackName = label.textContent.trim();
                         if(fallbackName){
                            tabNameMap[input.id] = fallbackName;
                            console.warn(`       Could not extract precise tab name for ID "${input.id}". Using label content "${fallbackName}" as name.`);
                         } else {
                            console.warn(`       Could not extract tab name for ID "${input.id}". Using ID as name.`);
                            tabNameMap[input.id] = input.id; // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¨ã—ã¦IDã‚’ä½¿ç”¨
                         }
                    }
                }
            });
            // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã® 'tab1' ãŒãƒãƒƒãƒ—ã«ãªã„å ´åˆï¼ˆ<label> ãŒå­˜åœ¨ã—ãªã„å ´åˆãªã©ï¼‰ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            if (!tabNameMap['tab1']) {
                 console.log("       No explicit definition for 'tab1' found, defaulting name to 'tab1'.");
                 tabNameMap['tab1'] = 'tab1';
            }
            console.log("   [parseTekeyLogHtml] Final Tab Name Map:", tabNameMap);
            // --- ã“ã“ã¾ã§è¿½åŠ  ---

            const messageDivs = chatlogDiv.querySelectorAll(':scope > div'); // Direct children divs
            console.log(`   [parseTekeyLogHtml] Found ${messageDivs.length} potential message elements.`);
            const tempData = [];
            let currentUniqueId = 0;

            messageDivs.forEach((div, index) => {
                if (!div.textContent?.trim()) return;
                try {
                    // --- ä¿®æ­£: ã‚¿ãƒ–IDã‚’ç‰¹å®šã—ã€ãƒãƒƒãƒ—ã‹ã‚‰ã‚¿ãƒ–åã‚’å–å¾— ---
                    let tabId = 'tab1'; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
                    if (div.classList.contains('tab2')) tabId = 'tab2';
                    else if (div.classList.contains('tab3')) tabId = 'tab3';
                    // å°†æ¥çš„ã« tab4, tab5... ã«å¯¾å¿œã™ã‚‹å ´åˆã¯ã“ã“ã«è¿½åŠ 
                    // else if (div.classList.contains('tabN')) tabId = 'tabN';

                    // ãƒãƒƒãƒ—ã‹ã‚‰å®Ÿéš›ã®ã‚¿ãƒ–åã‚’å–å¾—ã€‚è¦‹ã¤ã‹ã‚‰ãªã‘ã‚Œã°IDã‚’ãã®ã¾ã¾ä½¿ã†
                    const tab = tabNameMap[tabId] || tabId;
                    // --- ã“ã“ã¾ã§ä¿®æ­£ ---

                    const speakerElement = div.querySelector('b');
                    const speaker = speakerElement?.textContent?.trim().replace(/[:ï¼š]$/, '').trim() || 'ä¸æ˜';

                    // Clone the div to manipulate it without affecting the original DOM structure during iteration
                    const messageContentContainer = div.cloneNode(true);
                    const bElementToRemove = messageContentContainer.querySelector('b');
                    const spanElementToRemove = messageContentContainer.querySelector('span'); // Tekey timestamp span
                    if (bElementToRemove) messageContentContainer.removeChild(bElementToRemove);
                    if (spanElementToRemove) messageContentContainer.removeChild(spanElementToRemove);
                    const message = messageContentContainer.innerHTML.trim();

                    const colorMatch = div.getAttribute('style')?.match(/color:\s*(#[0-9a-fA-F]{3,6}|rgba?\([^)]+\)|[a-zA-Z]+)/);
                    const color = colorMatch?.[1]?.trim() || '#000000'; // Default to black if no color style

                    const isDiceRoll = div.classList.contains('diceroll');

                    tempData.push({
                        type: 'message', id: generateUniqueId('msg'), // Generate ID here
                        originalIndex: index,
                        tab: tab, // å–å¾—ã—ãŸå®Ÿéš›ã®ã‚¿ãƒ–åã‚’è¨­å®š
                        speaker: speaker, color: color, message: message,
                        isDiceRoll: isDiceRoll // Store dice roll info (optional)
                    });
                    currentUniqueId++; // Increment counter

                } catch (parseError) {
                    console.error(`   [parseTekeyLogHtml] Error parsing div at index ${index}:`, parseError, div.outerHTML);
                    tempData.push({ type: 'error', id: generateUniqueId('err'), originalIndex: index, message: `Tekeyãƒ­ã‚°ã®è§£æã‚¨ãƒ©ãƒ¼ (è¡Œ ${index + 1})`, details: div.textContent?.substring(0, 100) || 'å†…å®¹ä¸æ˜' });
                    currentUniqueId++;
                }
            });
            nextUniqueId = currentUniqueId; // Set global counter after parsing
            console.log(`   [parseTekeyLogHtml] Parsing finished. Parsed ${tempData.length} items.`);
            return tempData;
        }
        // ===================================================

        function initializeCharacterSettings() {
            characterSettings = {};
            // speakerFrequencies should be calculated *before* calling this
            Object.keys(speakerFrequencies).forEach(speaker => {
                if (speaker !== 'system' && !characterSettings[speaker]) {
                    characterSettings[speaker] = { displayName: speaker, icon: null, expressions: {} };
                }
            });
            console.log("   [initializeCharacterSettings] Initialized settings for:", Object.keys(characterSettings));
        }
        function updateSpeakerDataForExport() { speakerDataForExport = {}; Object.entries(characterSettings).forEach(([original, setting]) => { if (original !== 'system') speakerDataForExport[original] = setting.displayName; }); }

        function populateCharacterSettingsUI() {
            characterSettingsDiv.innerHTML = '';
            const sortedSpeakers = Object.keys(characterSettings).filter(s => s !== 'system').sort((a, b) => (speakerFrequencies[b] || 0) - (speakerFrequencies[a] || 0));
            if (sortedSpeakers.length === 0) { characterSettingsDiv.innerHTML = '<p class="text-gray-500 italic">ãƒ­ã‚°å†…ã«èªè­˜å¯èƒ½ãªç™ºè¨€è€…ãŒã„ã¾ã›ã‚“ã§ã—ãŸã€‚</p>'; return; }

            const fragment = document.createDocumentFragment();
            sortedSpeakers.forEach(speaker => {
                try {
                    const setting = characterSettings[speaker]; if (!setting) { console.warn(`Setting not found for ${speaker}.`); return; }
                    const count = speakerFrequencies[speaker] || 0;
                    const uniqueSpeakerIdSuffix = sanitizeForFilename(speaker);

                    const container = document.createElement('div'); container.className = 'p-3 border rounded-md bg-white shadow-sm';
                    const mainInfoDiv = document.createElement('div'); mainInfoDiv.className = 'flex items-center space-x-4';

                    const iconDiv = document.createElement('div'); iconDiv.className = 'flex-shrink-0';
                    const imgPreview = document.createElement('img'); imgPreview.id = `icon-preview-${uniqueSpeakerIdSuffix}`;
                    imgPreview.src = setting.icon || PLACEHOLDER_ICON_URL.replace('64x64', '40x40'); // Assumes setting.icon is DataURL
                    imgPreview.alt = `${setting.displayName} ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¢ã‚¤ã‚³ãƒ³`; imgPreview.className = 'w-10 h-10 rounded-full object-cover border border-gray-300 character-icon-preview';
                    imgPreview.loading = 'lazy';
                    imgPreview.onerror = () => { if (imgPreview.src !== PLACEHOLDER_ICON_URL.replace('64x64', '40x40')) imgPreview.src = PLACEHOLDER_ICON_URL.replace('64x64', '40x40'); if (characterSettings[speaker]) characterSettings[speaker].icon = null; };
                    const iconInput = document.createElement('input'); iconInput.type = 'file'; iconInput.accept = 'image/*'; iconInput.id = `icon-input-${uniqueSpeakerIdSuffix}`; iconInput.className = 'visually-hidden'; iconInput.setAttribute('aria-labelledby', `icon-label-${uniqueSpeakerIdSuffix}`);
                    iconInput.addEventListener('change', (e) => handleDefaultIconUpload(e, speaker));
                    const iconLabel = document.createElement('label'); iconLabel.htmlFor = `icon-input-${uniqueSpeakerIdSuffix}`; iconLabel.id = `icon-label-${uniqueSpeakerIdSuffix}`; iconLabel.className = 'cursor-pointer'; iconLabel.setAttribute('title', `ã‚¯ãƒªãƒƒã‚¯ã—ã¦ ${setting.displayName} ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¢ã‚¤ã‚³ãƒ³ã‚’å¤‰æ›´`); iconLabel.appendChild(imgPreview); iconDiv.appendChild(iconLabel); iconDiv.appendChild(iconInput);

                    const nameDiv = document.createElement('div'); nameDiv.className = 'flex-grow min-w-0';
                    const nameLabel = document.createElement('label'); nameLabel.htmlFor = `name-input-${uniqueSpeakerIdSuffix}`; nameLabel.className = 'block text-sm font-medium text-gray-700 mb-1'; nameLabel.innerHTML = `ã€Œ${escapeHtml(speaker)}ã€ <span class="text-xs text-gray-500">(${count}å›)</span> è¡¨ç¤ºå:`;
                    const nameInput = document.createElement('input'); nameInput.type = 'text'; nameInput.id = `name-input-${uniqueSpeakerIdSuffix}`; nameInput.value = setting.displayName; nameInput.className = 'block w-full rounded-md border-gray-300 shadow-sm p-1.5 focus:border-indigo-500 focus:ring-indigo-500 text-sm'; nameInput.setAttribute('aria-label', `${escapeHtml(speaker)} ã®è¡¨ç¤ºå`);
                    nameInput.addEventListener('input', (e) => {
                        const newDisplayName = e.target.value;
                        if (characterSettings[speaker]) {
                            characterSettings[speaker].displayName = newDisplayName;
                            updateSpeakerFilterOptionText(speaker, newDisplayName);
                            updateSpeakerDataForExport();
                            renderLog();
                        }
                    });
                    nameDiv.appendChild(nameLabel); nameDiv.appendChild(nameInput);
                    mainInfoDiv.appendChild(iconDiv); mainInfoDiv.appendChild(nameDiv);
                    container.appendChild(mainInfoDiv);

                    const expressionSection = document.createElement('div');
                    expressionSection.className = 'expression-section'; expressionSection.id = `expressions-${uniqueSpeakerIdSuffix}`;
                    const expressionTitle = document.createElement('h4'); expressionTitle.textContent = 'è¡¨æƒ…å·®åˆ†ã‚¢ã‚¤ã‚³ãƒ³:'; expressionTitle.className = 'text-sm font-medium text-gray-600 mb-2'; expressionSection.appendChild(expressionTitle);
                    const expressionList = document.createElement('div'); expressionList.className = 'space-y-1 mb-3'; expressionSection.appendChild(expressionList);
                    populateExpressionList(expressionList, speaker); // Populate list dynamically

                    const addForm = document.createElement('div'); addForm.className = 'add-expression-form';
                    const expressionNameInput = document.createElement('input'); expressionNameInput.type = 'text'; expressionNameInput.placeholder = 'å·®åˆ†å (ä¾‹: ç¬‘é¡”)'; expressionNameInput.className = 'add-expression-name-input'; expressionNameInput.id = `exp-name-input-${uniqueSpeakerIdSuffix}`;
                    const expressionFileLabel = document.createElement('label'); const hiddenInputId = `exp-file-input-${uniqueSpeakerIdSuffix}`; expressionFileLabel.htmlFor = hiddenInputId; expressionFileLabel.textContent = 'ç”»åƒé¸æŠ';
                    const expressionFileInput = document.createElement('input'); expressionFileInput.type = 'file'; expressionFileInput.accept = 'image/*'; expressionFileInput.className = 'visually-hidden'; expressionFileInput.id = hiddenInputId;
                    expressionFileInput.addEventListener('change', (e) => { expressionAddContext = { speaker: speaker, inputElement: e.target }; handleAddExpressionFile(); });
                    addForm.appendChild(expressionNameInput); addForm.appendChild(expressionFileLabel); addForm.appendChild(expressionFileInput);
                    expressionSection.appendChild(addForm);
                    container.appendChild(expressionSection);

                    fragment.appendChild(container);
                } catch (uiError) { console.error(`Error creating UI element for speaker "${speaker}":`, uiError); const errorDiv = document.createElement('div'); errorDiv.className = 'p-3 border rounded-md bg-red-50 text-red-700'; errorDiv.textContent = `ã€Œ${escapeHtml(speaker)}ã€ã®è¨­å®šè¡¨ç¤ºä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚`; fragment.appendChild(errorDiv); }
            });
            characterSettingsDiv.appendChild(fragment);
        }

        function populateExpressionList(listElement, speaker) {
             listElement.innerHTML = '';
             const expressions = characterSettings[speaker]?.expressions || {};
             const sortedNames = Object.keys(expressions).sort();
             if (sortedNames.length === 0) { listElement.innerHTML = '<p class="text-xs text-gray-500 italic">å·®åˆ†ã‚¢ã‚¤ã‚³ãƒ³æœªç™»éŒ²</p>'; return; }
             sortedNames.forEach(expName => {
                 const expDataUrl = expressions[expName]; // Assumes DataURL
                 const itemDiv = document.createElement('div'); itemDiv.className = 'expression-item';
                 const img = document.createElement('img'); img.src = expDataUrl || PLACEHOLDER_ICON_URL.replace('64x64', '32x32'); img.alt = expName; img.className = 'expression-preview'; img.loading = 'lazy'; img.onerror = () => { img.src = PLACEHOLDER_ICON_URL.replace('64x64', '32x32'); };
                 const nameSpan = document.createElement('span'); nameSpan.className = 'expression-name'; nameSpan.textContent = escapeHtml(expName);
                 const deleteBtn = document.createElement('button'); deleteBtn.textContent = 'å‰Šé™¤'; deleteBtn.className = 'expression-delete-btn'; deleteBtn.onclick = () => handleDeleteExpression(speaker, expName);
                 itemDiv.appendChild(img); itemDiv.appendChild(nameSpan); itemDiv.appendChild(deleteBtn);
                 listElement.appendChild(itemDiv);
             });
        }

        function updateSpeakerFilterOptionText(originalSpeaker, newDisplayName) { try { const escapedSpeaker = escapeCssSelector(originalSpeaker); const option = speakerFilterSelect.querySelector(`option[value="${escapedSpeaker}"]`); if (option) { const count = speakerFrequencies[originalSpeaker] || 0; const displayName = newDisplayName?.trim() || originalSpeaker; option.textContent = `${escapeHtml(displayName)} (${count}å›)`; } } catch (e) { console.error(`Error updating speaker filter option for "${originalSpeaker}":`, e); } }

        async function handleDefaultIconUpload(event, speaker) {
            const file = event.target.files?.[0]; if (!file) return;
            if (!file.type.startsWith('image/')) { alert('ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚'); event.target.value = null; return; }
            if (file.size > MAX_FILE_SIZE_BYTES) { alert(`ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãŒå¤§ãã™ãã¾ã™ (${(file.size / 1024 / 1024).toFixed(1)}MB)ã€‚${MAX_FILE_SIZE_MB}MBä»¥ä¸‹ã«ã—ã¦ãã ã•ã„ã€‚`); event.target.value = null; return; }

            const uniqueSpeakerIdSuffix = sanitizeForFilename(speaker);
            const imgPreview = document.getElementById(`icon-preview-${uniqueSpeakerIdSuffix}`);

            try {
                const dataUrl = await readFileAsDataURL(file);
                if (imgPreview) imgPreview.src = dataUrl;
                if (!characterSettings[speaker]) { characterSettings[speaker] = { displayName: speaker, icon: null, expressions: {} }; }
                characterSettings[speaker].icon = dataUrl; // Store Data URL
                uploadedFiles[speaker] = file; // Store File object
                console.log(`Default icon updated for speaker ${speaker}. Re-rendering log.`);
                renderLog();
            } catch (error) { console.error(`Error processing default speaker icon upload for ${speaker}:`, error); alert(`ã‚¢ã‚¤ã‚³ãƒ³ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`); if (imgPreview && characterSettings[speaker]?.icon) imgPreview.src = characterSettings[speaker].icon; else if (imgPreview) imgPreview.src = PLACEHOLDER_ICON_URL.replace('64x64', '40x40'); }
            finally { if (event.target) event.target.value = null; }
        }

        async function handleAddExpressionFile() {
             const { speaker, inputElement } = expressionAddContext;
             if (!speaker || !inputElement || !inputElement.files || inputElement.files.length === 0) { expressionAddContext = { speaker: null, inputElement: null }; return; }
             const file = inputElement.files[0];
             const uniqueSpeakerIdSuffix = sanitizeForFilename(speaker);
             const nameInput = document.getElementById(`exp-name-input-${uniqueSpeakerIdSuffix}`);
             const expressionName = nameInput ? nameInput.value.trim() : '';

             const currentSpeaker = speaker; // Keep reference
             if (inputElement) inputElement.value = null;
             expressionAddContext = { speaker: null, inputElement: null };

             if (!expressionName) { alert('å·®åˆ†åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚'); return; }
             if (characterSettings[currentSpeaker]?.expressions?.[expressionName]) { alert(`å·®åˆ†åã€Œ${expressionName}ã€ã¯æ—¢ã«ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™ã€‚`); return; }
             if (!file.type.startsWith('image/')) { alert('ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚'); return; }
             if (file.size > MAX_FILE_SIZE_BYTES) { alert(`ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãŒå¤§ãã™ãã¾ã™ (${(file.size / 1024 / 1024).toFixed(1)}MB)ã€‚${MAX_FILE_SIZE_MB}MBä»¥ä¸‹ã«ã—ã¦ãã ã•ã„ã€‚`); return; }

             showLoading();
             try {
                 const dataUrl = await readFileAsDataURL(file);
                 if (!characterSettings[currentSpeaker]) { characterSettings[currentSpeaker] = { displayName: currentSpeaker, icon: null, expressions: {} }; }
                 if (!characterSettings[currentSpeaker].expressions) { characterSettings[currentSpeaker].expressions = {}; }
                 characterSettings[currentSpeaker].expressions[expressionName] = dataUrl; // Store Data URL

                 const uploadKey = `exp_${currentSpeaker}_${expressionName}`;
                 uploadedFiles[uploadKey] = file; // Store File object

                 if (nameInput) nameInput.value = ''; // Reset name input
                 console.log(`Expression '${expressionName}' added for speaker ${currentSpeaker}.`);
                 const expressionListDiv = document.getElementById(`expressions-${uniqueSpeakerIdSuffix}`)?.querySelector('.space-y-1');
                 if (expressionListDiv) populateExpressionList(expressionListDiv, currentSpeaker);
             } catch (error) { console.error(`Error adding expression icon for ${currentSpeaker}:`, error); alert(`å·®åˆ†ã‚¢ã‚¤ã‚³ãƒ³ã®èª­ã¿è¾¼ã¿/è¿½åŠ ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`); }
             finally { hideLoading(); }
        }

        function handleDeleteExpression(speaker, expressionName) {
             if (!characterSettings[speaker]?.expressions?.[expressionName]) return;
             const confirmation = customizationSettings.skipDeleteConfirm || confirm(`ã€Œ${speaker}ã€ã®å·®åˆ†ã‚¢ã‚¤ã‚³ãƒ³ã€Œ${expressionName}ã€ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`);
             if (!confirmation) return;

             delete characterSettings[speaker].expressions[expressionName];
             const uploadKey = `exp_${speaker}_${expressionName}`;
             if (uploadedFiles[uploadKey]) { delete uploadedFiles[uploadKey]; console.log(`Removed file cache for expression ${uploadKey}.`); }

             const uniqueSpeakerIdSuffix = sanitizeForFilename(speaker);
             const expressionListDiv = document.getElementById(`expressions-${uniqueSpeakerIdSuffix}`)?.querySelector('.space-y-1');
             if (expressionListDiv) populateExpressionList(expressionListDiv, speaker);

             let updatedMessages = false;
             displayLogData.forEach(item => {
                 if (item.type === 'message' && item.speaker === speaker && item.iconKey === expressionName) { item.iconKey = 'default'; updatedMessages = true; }
             });
             if (updatedMessages) { console.log(`Reset messages using deleted expression '${expressionName}'. Re-rendering.`); renderLog(); }
             else { console.log(`Expression '${expressionName}' deleted for speaker ${speaker}.`); }
        }

        function saveCharacterSettings() {
            if (Object.keys(characterSettings).length === 0) { alert('ä¿å­˜ã™ã‚‹è¨­å®šãŒã‚ã‚Šã¾ã›ã‚“ã€‚'); return; }
            try {
                 const settingsToSave = {};
                 for (const [speaker, setting] of Object.entries(characterSettings)) {
                     settingsToSave[speaker] = { displayName: setting.displayName, icon: setting.icon, expressions: setting.expressions };
                 }
                localStorage.setItem(LOCALSTORAGE_SETTINGS_KEY, JSON.stringify(settingsToSave));
                alert('ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼è¨­å®šï¼ˆè¡¨ç¤ºå/ã‚¢ã‚¤ã‚³ãƒ³DataURLï¼‰ã‚’LocalStorageã«ä¸€æ™‚ä¿å­˜ã—ã¾ã—ãŸã€‚');
            }
            catch (error) { console.error("Error saving character settings to LocalStorage:", error); alert(`LocalStorageã¸ã®è¨­å®šä¿å­˜ä¸­ã«ã‚¨ãƒ©ãƒ¼: ${error.message}`); }
        }
         function loadCharacterSettings() {
            if (Object.keys(characterSettings).length === 0) { alert('è¨­å®šã‚’é©ç”¨ã™ã‚‹ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãŒã„ã¾ã›ã‚“ã€‚'); return; }
            try {
                const savedSettingsJson = localStorage.getItem(LOCALSTORAGE_SETTINGS_KEY); if (!savedSettingsJson) { alert('LocalStorageã«ä¿å­˜ã•ã‚ŒãŸè¨­å®šãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚'); return; }
                const loadedSettings = JSON.parse(savedSettingsJson);
                let settingsAppliedCount = 0;
                 Object.keys(characterSettings).forEach(speaker => {
                    if (loadedSettings[speaker]) {
                        const oldIcon = characterSettings[speaker].icon; const oldExpressions = characterSettings[speaker].expressions;
                        characterSettings[speaker].displayName = loadedSettings[speaker].displayName; characterSettings[speaker].icon = loadedSettings[speaker].icon || null; characterSettings[speaker].expressions = loadedSettings[speaker].expressions || {};
                        if (characterSettings[speaker].icon !== oldIcon && uploadedFiles[speaker]) { delete uploadedFiles[speaker]; console.log(`Removed default icon file cache for ${speaker} due to LocalStorage load.`); }
                        const currentExpKeys = new Set(Object.keys(characterSettings[speaker].expressions));
                        if (oldExpressions) { for (const expName in oldExpressions) { if (!currentExpKeys.has(expName)) { const expKey = `exp_${speaker}_${expName}`; if (uploadedFiles[expKey]) { delete uploadedFiles[expKey]; console.log(`Removed expression file cache for ${expKey} due to LocalStorage load.`); } } } }
                        settingsAppliedCount++;
                    }
                });
                if (settingsAppliedCount > 0) { updateSpeakerDataForExport(); populateCharacterSettingsUI(); populateSpeakerFilterUI(); renderLog(); alert(`${settingsAppliedCount}ä»¶ã®è¨­å®šã‚’LocalStorageã‹ã‚‰èª­ã¿è¾¼ã¿ã¾ã—ãŸã€‚(ã‚¢ã‚¤ã‚³ãƒ³å®Ÿãƒ•ã‚¡ã‚¤ãƒ«ã¯å¾©å…ƒã•ã‚Œã¾ã›ã‚“)`); }
                 else alert('LocalStorageã«ä¸€è‡´ã™ã‚‹ä¿å­˜è¨­å®šãŒã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚');
            } catch (error) { console.error("Error loading character settings from LocalStorage:", error); alert(`LocalStorageã‹ã‚‰ã®è¨­å®šèª­ã¿è¾¼ã¿ä¸­ã«ã‚¨ãƒ©ãƒ¼: ${error.message}`); }
        }


        function populateTabsUI() {
            logTabsNav.innerHTML = '';
            const sortedTabs = ['all', ...[...uniqueTabsFound].filter(t=> t !== 'all').sort((a, b) => a.localeCompare(b))];
            if (sortedTabs.length <= 1) { logTabsNav.innerHTML = '<span class="whitespace-nowrap py-2 px-1 text-gray-500 text-sm italic">ã‚¿ãƒ–æƒ…å ±ãªã—</span>'; return; }
            const fragment = document.createDocumentFragment();
            sortedTabs.forEach(tab => {
                const button = document.createElement('button'); button.textContent = `[${escapeHtml(tab)}]`; button.dataset.tab = tab;
                const baseClasses = 'whitespace-nowrap py-2 px-3 border-b-2 font-medium text-sm focus:outline-none focus:ring-2 focus:ring-offset-1 focus:ring-indigo-500 transition-colors duration-150 ease-in-out';
                const activeClasses = 'border-indigo-500 text-indigo-600'; const inactiveClasses = 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300';
                const isActive = tab === currentTabFilter;
                button.className = `${baseClasses} ${isActive ? activeClasses : inactiveClasses}`;
                button.setAttribute('role', 'tab'); button.setAttribute('aria-selected', isActive ? 'true' : 'false');
                fragment.appendChild(button);
            });
            logTabsNav.appendChild(fragment); logTabsNav.setAttribute('role', 'tablist');
        }


        function populateSpeakerFilterUI() {
            speakerFilterSelect.innerHTML = '<option value="all">ã™ã¹ã¦ã®ç™ºè¨€è€…</option>';
            const sortedSpeakers = Object.keys(speakerFrequencies).filter(s => s !== 'system').sort((a, b) => (speakerFrequencies[b] || 0) - (speakerFrequencies[a] || 0));
            if (sortedSpeakers.length === 0) { speakerFilterSelect.disabled = true; return; }
            const fragment = document.createDocumentFragment();
            sortedSpeakers.forEach(speaker => { const option = document.createElement('option'); option.value = escapeCssSelector(speaker); const count = speakerFrequencies[speaker] || 0; const displayName = characterSettings[speaker]?.displayName || speaker; option.textContent = `${escapeHtml(displayName)} (${count}å›)`; fragment.appendChild(option); });
            speakerFilterSelect.appendChild(fragment);
            try { speakerFilterSelect.value = currentSpeakerFilter === 'all' ? 'all' : escapeCssSelector(currentSpeakerFilter); } catch { speakerFilterSelect.value = 'all'; }
            speakerFilterSelect.disabled = false;
        }

        function handleTabChange(tabName) { if (currentTabFilter === tabName) return; console.log(`Switching main display tab to: [${tabName}]`); currentTabFilter = tabName; const baseClasses = 'whitespace-nowrap py-2 px-3 border-b-2 font-medium text-sm focus:outline-none focus:ring-2 focus:ring-offset-1 focus:ring-indigo-500 transition-colors duration-150 ease-in-out'; const activeClasses = 'border-indigo-500 text-indigo-600'; const inactiveClasses = 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'; logTabsNav.querySelectorAll('button').forEach(button => { const isActive = button.dataset.tab === tabName; button.className = `${baseClasses} ${isActive ? activeClasses : inactiveClasses}`; button.setAttribute('aria-selected', isActive ? 'true' : 'false'); }); renderLog(); }
        function handleSpeakerFilterChange() { const selectedValue = speakerFilterSelect.value; const newFilter = selectedValue === 'all' ? 'all' : Object.keys(speakerFrequencies).find(sp => escapeCssSelector(sp) === selectedValue) || 'all'; if (currentSpeakerFilter === newFilter) return; console.log(`Filtering main display by speaker: ${newFilter}`); currentSpeakerFilter = newFilter; renderLog(); }

        function renderLog() {
             console.log(`   [renderLog] Rendering main display. Tab: ${currentTabFilter}, Speaker: ${currentSpeakerFilter}, NameBelowIcon: ${customizationSettings.nameBelowIconMode}, Font: ${customizationSettings.fontFamily}`);
             const startTime = performance.now();
             logDisplayDiv.innerHTML = '';

             FONT_CLASSES.forEach(cls => logDisplayDiv.classList.remove(cls)); logDisplayDiv.classList.add(customizationSettings.fontFamily);
             logDisplayDiv.style.fontSize = `${customizationSettings.fontSize}px`; logDisplayDiv.style.height = `${customizationSettings.logDisplayHeight}px`; logDisplayDiv.style.backgroundColor = customizationSettings.backgroundColor; document.body.style.backgroundColor = customizationSettings.backgroundColor;
             logDisplayDiv.style.setProperty('--bubble-max-width', `${customizationSettings.bubbleMaxWidth}%`); logDisplayDiv.style.setProperty('--bubble-bg-color', customizationSettings.normalBubbleColor); logDisplayDiv.style.setProperty('--bubble-arrow-color', customizationSettings.normalBubbleColor); logDisplayDiv.style.setProperty('--icon-size', `${customizationSettings.iconSize}px`);
             logDisplayDiv.classList.toggle('name-below-icon-active', customizationSettings.nameBelowIconMode);

             let filteredItems = displayLogData.filter(item => {
                 if (item.type === 'image' && item.afterOriginalIndex === HEADER_IMAGE_INDEX) return true;
                 if (item.type === 'error') return currentTabFilter === 'all' && currentSpeakerFilter === 'all';
                 let itemTab = 'main', itemSpeaker = 'ä¸æ˜';
                 if (item.type === 'message') { itemTab = item.tab || 'main'; itemSpeaker = item.speaker || 'ä¸æ˜'; }
                  else if (item.type === 'image') { const precedingMessage = findPrecedingMessage(item.afterOriginalIndex); if (precedingMessage) { itemTab = precedingMessage.tab || 'main'; itemSpeaker = precedingMessage.speaker || 'ä¸æ˜'; } else { return currentTabFilter === 'all' && currentSpeakerFilter === 'all'; } }
                  else { return false; }
                 const tabMatch = currentTabFilter === 'all' || itemTab === currentTabFilter;
                 const speakerMatch = currentSpeakerFilter === 'all' || itemSpeaker === currentSpeakerFilter;
                 return tabMatch && speakerMatch;
             });

             const dataToSort = filteredItems.map(item => ({ ...item, sortIndex: item.type === 'image' ? (item.afterOriginalIndex === HEADER_IMAGE_INDEX ? -Infinity : (item.originalIndex ?? item.afterOriginalIndex ?? -1) + 0.5) : (item.originalIndex ?? -1) })).sort((a, b) => a.sortIndex - b.sortIndex);
             console.log(`   [renderLog] Filtered/Sorted down to ${dataToSort.length} items to render.`);

             if (dataToSort.length === 0) { logDisplayDiv.innerHTML = '<p class="text-gray-500 text-center italic">è¡¨ç¤ºã™ã‚‹ãƒ­ã‚°ãŒã‚ã‚Šã¾ã›ã‚“ã€‚(ãƒ•ã‚£ãƒ«ã‚¿æ¡ä»¶ã‚’ç¢ºèªã—ã¦ãã ã•ã„)</p>'; const endTime = performance.now(); console.log(`   [renderLog] Rendered empty log in ${endTime - startTime} ms.`); return; }

             const fragment = document.createDocumentFragment();
             dataToSort.forEach((item, index) => {
                 try {
                     const isMultiTabView = currentTabFilter === 'all';
                     if (isMultiTabView && item.type === 'message' && index > 0) {
                         let prevMessageItem = null;
                         for (let j = index - 1; j >= 0; j--) { if (dataToSort[j].type === 'message') { prevMessageItem = dataToSort[j]; break; } }
                         if (prevMessageItem && (item.tab || 'main') !== (prevMessageItem.tab || 'main')) {
                             const separator = document.createElement('hr'); separator.className = 'tab-separator'; fragment.appendChild(separator);
                         }
                     }
                     let element;
                     if (item.type === 'message') { element = createMessageElement(item); }
                     else if (item.type === 'image') { element = createInsertedImageElement(item); }
                     else if (item.type === 'error') { element = createErrorElement(item); }
                     if (element) fragment.appendChild(element);
                 } catch (elementError) { console.error(`   [renderLog] Error creating element for item (ID: ${item.id}, Index: ${index}):`, elementError, item); const errorDiv = document.createElement('div'); errorDiv.className = 'p-2 my-1 bg-red-100 border border-red-400 text-red-700 rounded text-sm'; errorDiv.textContent = `è¡¨ç¤ºã‚¨ãƒ©ãƒ¼: ã‚¢ã‚¤ãƒ†ãƒ (${item.id})ã®è¡¨ç¤ºä¸­ã«å•é¡ŒãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚`; fragment.appendChild(errorDiv); }
             });
             logDisplayDiv.appendChild(fragment);
             const endTime = performance.now(); console.log(`   [renderLog] Rendered ${dataToSort.length} items in ${endTime - startTime} ms.`);
        }

        function findPrecedingMessage(originalIndex) {
             if (typeof originalIndex !== 'number' || originalIndex < 0) return null;
             for (let i = displayLogData.length - 1; i >= 0; i--) { if (displayLogData[i].type === 'message' && displayLogData[i].originalIndex === originalIndex) return displayLogData[i]; }
             return null;
         }

        function createMessageElement(logItem) {
            if (!logItem || logItem.type !== 'message') return null;
            const container = document.createElement('div'); container.className = 'message-item'; container.dataset.itemId = logItem.id; container.dataset.tab = logItem.tab || 'main'; container.dataset.speaker = logItem.speaker || 'ä¸æ˜';
            const currentDisplayMode = logItem.displayMode || 'bubble'; container.dataset.displayMode = currentDisplayMode;
            const setting = characterSettings[logItem.speaker] || { displayName: logItem.speaker, icon: null, expressions: {} };
            const placeholderSrc = PLACEHOLDER_ICON_URL.replace('64x64', `${customizationSettings.iconSize}x${customizationSettings.iconSize}`); // Use dynamic size for placeholder
            let currentIconSrc = placeholderSrc; const iconKey = logItem.iconKey || 'default';

            if (iconKey === 'override' && logItem.overrideIconSrc) { currentIconSrc = logItem.overrideIconSrc; }
            else if (iconKey !== 'default' && setting.expressions?.[iconKey]) { currentIconSrc = setting.expressions[iconKey]; }
            else if (setting.icon) { currentIconSrc = setting.icon; }

            const bubbleContainer = document.createElement('div'); bubbleContainer.className = 'message-container';
            const iconContainer = document.createElement('div'); iconContainer.className = 'icon-container';
            const iconImg = document.createElement('img'); iconImg.src = currentIconSrc; iconImg.alt = `${setting.displayName} icon (${iconKey})`; iconImg.className = 'w-full h-full rounded-full object-cover icon-border bg-gray-200 message-icon'; iconImg.style.borderColor = logItem.color || '#000000'; iconImg.loading = 'lazy'; iconImg.style.objectPosition = '50% 0%'; iconImg.title = 'ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚¢ã‚¤ã‚³ãƒ³ã‚’å¤‰æ›´';
            iconImg.onerror = (e) => { const target = e.target; const failedSrc = target.src; if (failedSrc === placeholderSrc) return; let intendedSrc = placeholderSrc; const currentKey = logItem.iconKey || 'default'; if (currentKey === 'override' && logItem.overrideIconSrc) intendedSrc = logItem.overrideIconSrc; else if (currentKey !== 'default' && setting.expressions?.[currentKey]) intendedSrc = setting.expressions[currentKey]; else if (setting.icon) intendedSrc = setting.icon; if (failedSrc === intendedSrc) { if (currentKey === 'override') target.src = setting.icon || placeholderSrc; else if (currentKey !== 'default') target.src = setting.icon || placeholderSrc; else target.src = placeholderSrc; } else { target.src = placeholderSrc; } };
            iconImg.addEventListener('click', (event) => { event.stopPropagation(); triggerIconSelectionDropdown(logItem.id, logItem.speaker, event.currentTarget); });
            iconContainer.appendChild(iconImg);
            const nameBelowIconSpan = document.createElement('span'); nameBelowIconSpan.className = 'speaker-name-below-icon'; nameBelowIconSpan.textContent = escapeHtml(setting.displayName); iconContainer.appendChild(nameBelowIconSpan);
            bubbleContainer.appendChild(iconContainer);

            const contentContainer = document.createElement('div'); contentContainer.className = 'content-container';
            const speakerNameSpan = document.createElement('span'); speakerNameSpan.className = 'speaker-name-default'; speakerNameSpan.innerHTML = `${escapeHtml(setting.displayName)} <span class="text-xs font-normal text-gray-500">[${escapeHtml(logItem.tab || 'main')}]</span>`;
            const tabBelowIconSpan = document.createElement('span'); tabBelowIconSpan.className = 'tab-name-below-icon'; tabBelowIconSpan.textContent = `[${escapeHtml(logItem.tab || 'main')}]`;
            const bubbleDiv = document.createElement('div'); bubbleDiv.className = 'bubble bubble-left bubble-normal'; bubbleDiv.innerHTML = logItem.message; bubbleDiv.contentEditable = "true"; bubbleDiv.dataset.itemId = logItem.id; bubbleDiv.addEventListener('blur', handleMessageEdit);
            contentContainer.appendChild(speakerNameSpan); contentContainer.appendChild(tabBelowIconSpan); contentContainer.appendChild(bubbleDiv);
            const actionButtonContainer = document.createElement('div'); actionButtonContainer.className = 'action-button-container';
            const insertButton = document.createElement('button'); insertButton.textContent = 'ç”»åƒæŒ¿å…¥'; insertButton.className = 'action-button action-button-insert'; insertButton.onclick = () => triggerImageInsert(logItem.originalIndex); actionButtonContainer.appendChild(insertButton);
            const deleteButtonBubble = createDeleteButton(logItem.id, 'ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸'); actionButtonContainer.appendChild(deleteButtonBubble);
            contentContainer.appendChild(actionButtonContainer);
            bubbleContainer.appendChild(contentContainer);
            container.appendChild(bubbleContainer);

            const narrationContainer = document.createElement('div'); narrationContainer.className = 'narration-container';
            const narrationTab = document.createElement('span'); narrationTab.className = 'narration-tab'; narrationTab.textContent = `[${escapeHtml(logItem.tab || 'main')}]`;
            const narrationSpeaker = document.createElement('span'); narrationSpeaker.className = 'narration-speaker'; narrationSpeaker.textContent = `${escapeHtml(setting.displayName)}:`;
            const narrationMessage = document.createElement('span'); narrationMessage.className = 'narration-message'; narrationMessage.innerHTML = logItem.message; narrationMessage.contentEditable = "true"; narrationMessage.dataset.itemId = logItem.id; narrationMessage.addEventListener('blur', handleMessageEdit);
            narrationContainer.appendChild(narrationTab); narrationContainer.appendChild(narrationSpeaker); narrationContainer.appendChild(narrationMessage);
            const narrationActionButtonContainer = document.createElement('div'); narrationActionButtonContainer.style.display = 'inline-block'; narrationActionButtonContainer.style.marginLeft = '10px';
            const narrationDeleteButton = createDeleteButton(logItem.id, 'ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸'); narrationActionButtonContainer.appendChild(narrationDeleteButton);
            narrationContainer.appendChild(narrationActionButtonContainer);
            container.appendChild(narrationContainer);

            const toggleButton = document.createElement('button'); toggleButton.className = 'display-mode-toggle'; toggleButton.title = 'è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿ (ãƒ•ã‚­ãƒ€ã‚·/æå†™)'; toggleButton.textContent = (currentDisplayMode === 'narration') ? 'ğŸ’¬' : 'ğŸ“'; toggleButton.onclick = () => toggleMessageDisplayMode(logItem.id);
            container.appendChild(toggleButton);
            return container;
        }

        function toggleMessageDisplayMode(itemId) {
            const itemIndex = displayLogData.findIndex(item => item.id === itemId && item.type === 'message'); if (itemIndex === -1) return;
            const currentMode = displayLogData[itemIndex].displayMode || 'bubble'; const newMode = (currentMode === 'bubble') ? 'narration' : 'bubble'; displayLogData[itemIndex].displayMode = newMode;
            const elementToUpdate = logDisplayDiv.querySelector(`.message-item[data-item-id="${itemId}"]`);
            if (elementToUpdate) { elementToUpdate.dataset.displayMode = newMode; const toggleButton = elementToUpdate.querySelector('.display-mode-toggle'); if (toggleButton) toggleButton.textContent = (newMode === 'narration') ? 'ğŸ’¬' : 'ğŸ“'; }
        }

        function createInsertedImageElement(imageItem) {
             if (!imageItem || imageItem.type !== 'image') return null;
             const container = document.createElement('div'); container.className = 'inserted-image-container my-2 image-item'; container.dataset.itemId = imageItem.id;
             const isHeaderImage = imageItem.afterOriginalIndex === HEADER_IMAGE_INDEX; const precedingMessage = isHeaderImage ? null : findPrecedingMessage(imageItem.afterOriginalIndex);
             container.dataset.tab = isHeaderImage ? 'header' : (precedingMessage?.tab || 'main'); container.dataset.speaker = isHeaderImage ? 'header' : (precedingMessage?.speaker || 'ä¸æ˜');
             const img = document.createElement('img'); img.src = imageItem.src || ''; img.alt = imageItem.caption ? escapeHtml(imageItem.caption) : `æŒ¿å…¥ç”»åƒ (ID: ${imageItem.id})`; img.className = 'inserted-image'; img.loading = 'lazy';
             img.onerror = (e) => { console.error(`Failed to load inserted image: ${e.target.src}`); container.innerHTML = `<p class="text-red-500 text-xs text-center font-semibold">[ç”»åƒ(ID: ${escapeHtml(imageItem.id)})ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ]</p>`; const deleteBtn = createDeleteButton(imageItem.id, 'ç”»åƒ'); container.appendChild(deleteBtn); };
             container.appendChild(img);
             if (imageItem.caption) { const captionP = document.createElement('p'); captionP.className = 'image-caption'; captionP.textContent = imageItem.caption; container.appendChild(captionP); }
             const actionButtonContainer = document.createElement('div'); actionButtonContainer.className = 'action-button-container justify-center';
             const editCaptionButton = document.createElement('button'); editCaptionButton.textContent = 'èª¬æ˜ç·¨é›†'; editCaptionButton.className = 'action-button action-button-edit'; editCaptionButton.onclick = () => editImageCaption(imageItem.id); actionButtonContainer.appendChild(editCaptionButton);
             const deleteButton = createDeleteButton(imageItem.id, 'ç”»åƒ'); actionButtonContainer.appendChild(deleteButton); container.appendChild(actionButtonContainer);
             return container;
         }

        function createErrorElement(errorItem) {
            if (!errorItem || errorItem.type !== 'error') return null;
            const errorDiv = document.createElement('div'); errorDiv.className = 'p-2 my-1 bg-yellow-100 border border-yellow-400 text-yellow-800 rounded text-sm error-item'; errorDiv.dataset.itemId = errorItem.id; errorDiv.dataset.tab = 'all'; errorDiv.dataset.speaker = 'all';
            errorDiv.innerHTML = `<strong>è§£æã‚¨ãƒ©ãƒ¼:</strong> ${escapeHtml(errorItem.message)}<br><small class="text-gray-600">å†…å®¹: ${escapeHtml(errorItem.details)}...</small>`;
            const deleteButton = createDeleteButton(errorItem.id, 'ã‚¨ãƒ©ãƒ¼è¡¨ç¤º'); const buttonContainer = document.createElement('div'); buttonContainer.className = 'mt-1'; buttonContainer.appendChild(deleteButton); errorDiv.appendChild(buttonContainer);
            return errorDiv;
        }

        function createDeleteButton(itemId, itemTypeLabel = 'ã‚¢ã‚¤ãƒ†ãƒ ') {
            const deleteButton = document.createElement('button'); deleteButton.textContent = 'å‰Šé™¤'; deleteButton.className = 'action-button action-button-delete'; deleteButton.onclick = () => deleteSingleItem(itemId); deleteButton.setAttribute('aria-label', `${itemTypeLabel} (ID: ${itemId}) ã‚’å‰Šé™¤`);
            return deleteButton;
        }

        function triggerImageInsert(afterIndex) { console.log(`Triggering image insert for index: ${afterIndex}`); if (typeof afterIndex !== 'number' || afterIndex < HEADER_IMAGE_INDEX) return; imageInsertTargetIndex = afterIndex; insertImageInput.click(); }

        async function handleInsertImageFile(event) {
            const file = event.target.files?.[0]; const targetIndex = imageInsertTargetIndex; imageInsertTargetIndex = -2;
            if (event.target) event.target.value = null; if (!file) return; if (targetIndex < HEADER_IMAGE_INDEX) return;
            if (!file.type.startsWith('image/')) { alert('ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã®ã¿æŒ¿å…¥ã§ãã¾ã™ã€‚'); return; } if (file.size > MAX_INSERT_IMAGE_SIZE_BYTES) { alert(`ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºè¶…é (${(file.size / 1024 / 1024).toFixed(1)}MB)ã€‚${MAX_INSERT_IMAGE_SIZE_MB}MBä»¥ä¸‹ã«ã—ã¦ãã ã•ã„ã€‚`); return; }
            const caption = ""; showLoading();
            try {
                const dataUrl = await readFileAsDataURL(file); const imageId = generateUniqueId('img');
                const newImageEntry = { type: 'image', id: imageId, src: dataUrl, afterOriginalIndex: targetIndex, caption: caption };
                if (targetIndex === HEADER_IMAGE_INDEX) { displayLogData.splice(0, 0, newImageEntry); }
                 else { let insertPos = -1; for (let i = displayLogData.length - 1; i >= 0; i--) { const item = displayLogData[i]; if ((item.type === 'message' && item.originalIndex === targetIndex) || (item.type === 'image' && item.afterOriginalIndex === targetIndex)) { insertPos = i + 1; break; } if ((item.type === 'message' || item.type === 'error') && (item.originalIndex ?? -1) < targetIndex) { if (item.type === 'image' && item.afterOriginalIndex < targetIndex) {} else { insertPos = i + 1; break; } } if (item.type === 'image' && item.afterOriginalIndex < targetIndex) { insertPos = i + 1; } } if (insertPos === -1) { const nextIndex = displayLogData.findIndex(item => (item.originalIndex ?? item.afterOriginalIndex ?? -Infinity) > targetIndex); insertPos = (nextIndex === -1) ? displayLogData.length : nextIndex; } displayLogData.splice(insertPos, 0, newImageEntry); }
                uploadedFiles[imageId] = file; renderLog();
            } catch (error) { console.error("Error inserting image:", error); alert(`ç”»åƒã®æŒ¿å…¥ä¸­ã«ã‚¨ãƒ©ãƒ¼: ${error.message}`); } finally { hideLoading(); }
        }

        function editImageCaption(itemId) {
            const imageItemIndex = displayLogData.findIndex(item => item.id === itemId && item.type === 'image'); if (imageItemIndex === -1) { alert("ã‚­ãƒ£ãƒ—ã‚·ãƒ§ãƒ³ç·¨é›†å¯¾è±¡ã®ç”»åƒãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚"); return; }
            const currentCaption = displayLogData[imageItemIndex].caption || ""; const newCaption = prompt("ç”»åƒã®èª¬æ˜æ–‡ï¼ˆã‚­ãƒ£ãƒ—ã‚·ãƒ§ãƒ³ï¼‰ã‚’ç·¨é›†ã—ã¦ãã ã•ã„:", currentCaption); if (newCaption !== null) { displayLogData[imageItemIndex].caption = newCaption.trim(); renderLog(); }
        }

        function deleteSingleItem(itemId) {
            if (!itemId) return; const indexToDelete = displayLogData.findIndex(item => item.id === itemId); if (indexToDelete === -1) { alert('å‰Šé™¤å¯¾è±¡ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚'); return; }
            const itemToDelete = displayLogData[indexToDelete]; const itemTypeLabel = itemToDelete.type === 'message' ? 'ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸' : itemToDelete.type === 'image' ? 'ç”»åƒ' : 'ã‚¨ãƒ©ãƒ¼è¡¨ç¤º';
            const proceedToDelete = customizationSettings.skipDeleteConfirm || confirm(`ID: ${itemId} ã®${itemTypeLabel}ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ (å…ƒã«æˆ»ã›ã¾ã›ã‚“)`); if (!proceedToDelete) return;
            displayLogData.splice(indexToDelete, 1);
            let fileKeyToRemove = null;
            if (itemToDelete.type === 'image') { fileKeyToRemove = itemId; }
            else if (itemToDelete.type === 'message' && itemToDelete.iconKey === 'override') { fileKeyToRemove = `icon_${itemId}`; } // ã“ã“ã¯ icon_itemId ã§ã¯ãªã icon_msg_itemId ã ã£ãŸã¯ãšï¼Ÿç¢ºèªå¿…è¦ -> getImagePathForKey ã¨åˆã‚ã›ã‚‹
             // getImagePathForKey ã§ã¯ icon_msg_*** ã«ã—ã¦ã„ã‚‹ã®ã§ã€ã“ã“ã‚‚åˆã‚ã›ã‚‹
             else if (itemToDelete.type === 'message' && itemToDelete.iconKey === 'override') { fileKeyToRemove = `icon_msg_${itemId}`; }

            if (fileKeyToRemove && uploadedFiles[fileKeyToRemove]) { delete uploadedFiles[fileKeyToRemove]; console.log(`Removed file cache for ${fileKeyToRemove}.`); }
            const elementToRemove = logDisplayDiv.querySelector(`[data-item-id="${itemId}"]`); if (elementToRemove) { elementToRemove.remove(); } else { renderLog(); }
        }

        function handleMessageEdit(event) {
            const editedElement = event.target; const itemId = editedElement.dataset.itemId; const newContent = editedElement.innerHTML; if (!itemId) return;
            const itemIndex = displayLogData.findIndex(item => item.id === itemId && item.type === 'message'); if (itemIndex === -1) return;
            if (displayLogData[itemIndex].message !== newContent) { displayLogData[itemIndex].message = newContent; console.log(`Message ${itemId} content updated.`); }
        }

        // --- Icon Selection Dropdown Logic ---
        function triggerIconSelectionDropdown(messageId, speaker, clickedIconElement) {
            closeIconDropdown(); const dropdown = iconSelectDropdown; dropdown.innerHTML = ''; messageIconChangeTargetId = messageId;
            const setting = characterSettings[speaker] || { expressions: {}, icon: null }; const fragment = document.createDocumentFragment();
            const defaultBtn = createDropdownButton('default', 'ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¢ã‚¤ã‚³ãƒ³', speaker, 'default'); if (setting.icon) defaultBtn.insertBefore(createDropdownIconPreview(setting.icon), defaultBtn.firstChild); fragment.appendChild(defaultBtn);
            const expressions = setting.expressions || {}; const sortedExpNames = Object.keys(expressions).sort();
            if (sortedExpNames.length > 0) { const separator = document.createElement('div'); separator.className = 'icon-select-separator'; fragment.appendChild(separator); sortedExpNames.forEach(expName => { const btn = createDropdownButton(expName, escapeHtml(expName), speaker, 'expression'); if (expressions[expName]) btn.insertBefore(createDropdownIconPreview(expressions[expName]), btn.firstChild); fragment.appendChild(btn); }); }
            const separator2 = document.createElement('div'); separator2.className = 'icon-select-separator'; fragment.appendChild(separator2);
            const overrideBtn = createDropdownButton('override', 'ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å€‹åˆ¥è¨­å®š...', speaker, 'override'); fragment.appendChild(overrideBtn);
            dropdown.appendChild(fragment); const rect = clickedIconElement.getBoundingClientRect();
            dropdown.style.top = `${window.scrollY + rect.bottom + 5}px`; dropdown.style.left = `${window.scrollX + rect.left}px`;
            dropdown.classList.remove('hidden'); currentDropdown = dropdown; document.addEventListener('click', handleClickOutsideDropdown, true);
        }
        function createDropdownButton(key, text, speaker, type) { const button = document.createElement('button'); button.textContent = text; button.dataset.key = key; button.dataset.speaker = speaker; button.dataset.type = type; button.onclick = handleMessageIconSelection; return button; }
        function createDropdownIconPreview(src) { const img = document.createElement('img'); img.src = src; img.alt = ''; img.onerror = (e) => { e.target.style.display = 'none'; }; return img; }
        function handleMessageIconSelection(event) {
            const button = event.currentTarget; const key = button.dataset.key; const type = button.dataset.type; const messageId = messageIconChangeTargetId; closeIconDropdown(); if (!messageId) return;
            const itemIndex = displayLogData.findIndex(item => item.id === messageId && item.type === 'message'); if (itemIndex === -1) return;
            if (type === 'override') { messageIconChangeTargetId = messageId; iconChangeInput.onchange = handleOverrideIconUpload; iconChangeInput.click(); }
            else {
                 displayLogData[itemIndex].iconKey = key;
                 // overrideIconSrc ã‚’ã‚¯ãƒªã‚¢ã—ã€é–¢é€£ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‰Šé™¤
                 if (displayLogData[itemIndex].overrideIconSrc) {
                     displayLogData[itemIndex].overrideIconSrc = null;
                     const overrideFileKey = `icon_msg_${messageId}`; // deleteSingleItem ã¨åˆã‚ã›ã‚‹
                     if (uploadedFiles[overrideFileKey]) {
                         delete uploadedFiles[overrideFileKey];
                         console.log(`Removed override file cache for ${overrideFileKey} because icon was changed to default/expression.`);
                     }
                 }
                 messageIconChangeTargetId = null;
                 renderLog();
             }
        }
        async function handleOverrideIconUpload(event) {
            const file = event.target.files?.[0]; const targetMessageId = messageIconChangeTargetId; iconChangeInput.onchange = null; if (event.target) event.target.value = null; if (!file || !targetMessageId) { messageIconChangeTargetId = null; return; }
            if (!file.type.startsWith('image/')) { alert('ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚'); messageIconChangeTargetId = null; return; } if (file.size > MAX_FILE_SIZE_BYTES) { alert(`ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãŒå¤§ãã™ãã¾ã™ (${(file.size / 1024 / 1024).toFixed(1)}MB)ã€‚${MAX_FILE_SIZE_MB}MBä»¥ä¸‹ã«ã—ã¦ãã ã•ã„ã€‚`); messageIconChangeTargetId = null; return; }
            showLoading();
            try {
                const dataUrl = await readFileAsDataURL(file); const messageIndex = displayLogData.findIndex(item => item.id === targetMessageId && item.type === 'message'); if (messageIndex === -1) throw new Error(`Message item ${targetMessageId} not found.`);
                displayLogData[messageIndex].iconKey = 'override'; displayLogData[messageIndex].overrideIconSrc = dataUrl;
                const uploadKey = `icon_msg_${targetMessageId}`; // deleteSingleItem, getImagePathForKey ã¨åˆã‚ã›ã‚‹
                uploadedFiles[uploadKey] = file;
                console.log(`Override icon for ${targetMessageId} updated. Re-rendering log.`); renderLog();
            } catch (error) { console.error(`Error processing override icon upload for ${targetMessageId}:`, error); alert(`å€‹åˆ¥ã‚¢ã‚¤ã‚³ãƒ³ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`); const messageIndex = displayLogData.findIndex(item => item.id === targetMessageId); if(messageIndex !== -1 && displayLogData[messageIndex].type === 'message' && displayLogData[messageIndex].iconKey === 'override') { displayLogData[messageIndex].iconKey = 'default'; displayLogData[messageIndex].overrideIconSrc = null; renderLog(); } }
            finally { hideLoading(); messageIconChangeTargetId = null; }
        }
        function closeIconDropdown() { if (currentDropdown) { currentDropdown.classList.add('hidden'); currentDropdown.innerHTML = ''; currentDropdown = null; document.removeEventListener('click', handleClickOutsideDropdown, true); } }
        function handleClickOutsideDropdown(event) { if (currentDropdown && !currentDropdown.contains(event.target)) { const clickedOnIcon = event.target.closest('.message-icon'); if (!clickedOnIcon) closeIconDropdown(); } }

        // --- Customization Functions ---
        function applyCustomization() {
            try {
                customizationSettings.normalBubbleColor = normalColorInput.value; customizationSettings.fontSize = parseInt(fontSizeSlider.value, 10) || 16; customizationSettings.backgroundColor = backgroundColorInput.value; customizationSettings.iconSize = parseInt(iconSizeSlider.value, 10) || 64; customizationSettings.bubbleMaxWidth = parseInt(bubbleWidthSlider.value, 10) || 80; customizationSettings.nameBelowIconMode = nameBelowIconToggle.checked; customizationSettings.fontFamily = fontFamilySelect.value; customizationSettings.logDisplayHeight = parseInt(logHeightSlider.value, 10) || 384; customizationSettings.skipDeleteConfirm = skipDeleteConfirmToggle.checked;
                saveCustomization(); renderLog();
            } catch (error) { console.error("Error applying customization:", error); alert(`ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºé©ç”¨ã‚¨ãƒ©ãƒ¼: ${error.message}`); }
        }
        function resetCustomizationDefaults() { customizationSettings = { normalBubbleColor: '#ffffff', fontSize: 16, backgroundColor: '#f3f4f6', iconSize: 64, bubbleMaxWidth: 80, nameBelowIconMode: false, fontFamily: 'font-noto-sans', logDisplayHeight: 384, skipDeleteConfirm: false }; }
        function resetCustomization() { resetCustomizationDefaults(); updateCustomizationUI(); applyCustomization(); alert('è¡¨ç¤ºã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸã€‚'); }
        function updateCustomizationUI() {
            try {
                normalColorInput.value = customizationSettings.normalBubbleColor; fontSizeSlider.value = customizationSettings.fontSize; fontSizeValueSpan.textContent = customizationSettings.fontSize; backgroundColorInput.value = customizationSettings.backgroundColor; iconSizeSlider.value = customizationSettings.iconSize; iconSizeValueSpan.textContent = customizationSettings.iconSize; bubbleWidthSlider.value = customizationSettings.bubbleMaxWidth; bubbleWidthValueSpan.textContent = customizationSettings.bubbleMaxWidth; nameBelowIconToggle.checked = customizationSettings.nameBelowIconMode; fontFamilySelect.value = customizationSettings.fontFamily; logHeightSlider.value = customizationSettings.logDisplayHeight; logHeightValueSpan.textContent = customizationSettings.logDisplayHeight; skipDeleteConfirmToggle.checked = customizationSettings.skipDeleteConfirm;
             } catch (error) { console.error("Error updating customization UI:", error); }
         }
         function saveCustomization() { try { localStorage.setItem(LOCALSTORAGE_CUSTOMIZATION_KEY, JSON.stringify(customizationSettings)); } catch (error) { console.error("Error saving customization settings to LocalStorage:", error); } }
         function loadCustomization() {
            let loaded = null; try { const savedJson = localStorage.getItem(LOCALSTORAGE_CUSTOMIZATION_KEY); if (savedJson) loaded = JSON.parse(savedJson); } catch (error) { console.error("Error loading customization settings from LocalStorage:", error); localStorage.removeItem(LOCALSTORAGE_CUSTOMIZATION_KEY); }
            if (loaded) { customizationSettings.normalBubbleColor = loaded.normalBubbleColor || '#ffffff'; customizationSettings.fontSize = parseInt(loaded.fontSize, 10) || 16; customizationSettings.backgroundColor = loaded.backgroundColor || '#f3f4f6'; customizationSettings.iconSize = parseInt(loaded.iconSize, 10) || 64; customizationSettings.bubbleMaxWidth = parseInt(loaded.bubbleMaxWidth, 10) || 80; customizationSettings.nameBelowIconMode = loaded.nameBelowIconMode === true; customizationSettings.fontFamily = loaded.fontFamily || 'font-noto-sans'; customizationSettings.logDisplayHeight = parseInt(loaded.logDisplayHeight, 10) || 384; customizationSettings.skipDeleteConfirm = loaded.skipDeleteConfirm === true; }
            else { resetCustomizationDefaults(); }
        }

        // --- Project Save/Load ---
        async function saveProject() {
            if (displayLogData.length === 0) { alert('ä¿å­˜ã™ã‚‹ãƒ­ã‚°ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚'); return; } if (typeof JSZip === 'undefined') { alert('ZIPä½œæˆãƒ©ã‚¤ãƒ–ãƒ©ãƒª(JSZip)ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ...'); return; }
            const projectName = exportHtmlTitleInput.value.trim() || logFileNameBase || 'log_project'; const zipFilenameBase = exportZipFilenameInput.value.trim() || logFileNameBase || 'log_project'; const projectFilename = `${zipFilenameBase}${PROJECT_FILE_EXTENSION}`;
            console.log(`[${new Date().toISOString()}] Starting project save: ${projectFilename}`); showLoading();
            try {
                const zip = new JSZip(); const imgFolder = zip.folder(PROJECT_IMAGES_FOLDER.replace('/', '')); if (!imgFolder) throw new Error("Failed to create 'images' folder in ZIP.");
                const projectData = { fileFormatVersion: PROJECT_FILE_FORMAT_VERSION, toolVersion: APP_VERSION, createdAt: new Date().toISOString(), logFileNameBase: logFileNameBase, characterSettings: {}, customizationSettings: customizationSettings, displayLogData: [], uploadedFileManifest: {}, nextUniqueId: nextUniqueId, currentFilters: { tab: currentTabFilter, speaker: currentSpeakerFilter } };
                const imagePathMap = new Map(); const addedFiles = new Set();
                for (const [key, fileObject] of Object.entries(uploadedFiles)) {
                     if (!(fileObject instanceof Blob)) { console.warn(`Skipping non-Blob entry in uploadedFiles: ${key}`); continue; }
                    const imagePath = getImagePathForKey(key, fileObject);
                    if (imagePath && !addedFiles.has(imagePath)) { try { imgFolder.file(imagePath.substring(PROJECT_IMAGES_FOLDER.length), fileObject); addedFiles.add(imagePath); imagePathMap.set(key, imagePath); let manifestEntry = { type: 'unknown' }; if (key.startsWith('img_')) manifestEntry = { type: 'insertedImage', imageId: key }; else if (key.startsWith('icon_msg_')) manifestEntry = { type: 'overrideIcon', messageId: key.substring(9) }; else if (key.startsWith('exp_')) { const parts = key.match(/^exp_(.+?)_(.+)$/); if(parts) manifestEntry = { type: 'expressionIcon', speaker: parts[1], expressionName: parts[2] }; } else manifestEntry = { type: 'defaultIcon', speaker: key }; projectData.uploadedFileManifest[imagePath] = manifestEntry; } catch (zipError) { console.error(`Error adding image (key: ${key}, path: ${imagePath}) to zip:`, zipError); } }
                     else if (imagePath && addedFiles.has(imagePath)) { imagePathMap.set(key, imagePath); } else { console.warn(`Could not generate image path for key: ${key}`); }
                }
                console.log(`   [Project Save] Added ${addedFiles.size} unique images to ZIP.`);
                for (const [speaker, setting] of Object.entries(characterSettings)) { const newSetting = { displayName: setting.displayName, iconPath: imagePathMap.get(speaker) || null, expressions: {} }; if (setting.expressions) { for (const [expName, _] of Object.entries(setting.expressions)) { const expKey = `exp_${speaker}_${expName}`; newSetting.expressions[expName] = imagePathMap.get(expKey) || null; } } projectData.characterSettings[speaker] = newSetting; }
                projectData.displayLogData = displayLogData.map(item => { if (item.type === 'message') { const newItem = { ...item }; delete newItem.overrideIconSrc; const overrideKey = `icon_msg_${item.id}`; newItem.overrideIconPath = (item.iconKey === 'override') ? (imagePathMap.get(overrideKey) || null) : null; return newItem; } else if (item.type === 'image') { const newItem = { ...item }; delete newItem.src; newItem.srcPath = imagePathMap.get(item.id) || null; return newItem; } else if (item.type === 'error') { return { ...item }; } return null; }).filter(item => item !== null);
                zip.file(PROJECT_DATA_FILENAME, JSON.stringify(projectData, null, 2));
                console.log("   [Project Save] Generating ZIP blob...");
                const zipBlob = await zip.generateAsync({ type: "blob", compression: "DEFLATE", compressionOptions: { level: 6 } }); console.log(`   [Project Save] ZIP blob generated (Size: ${(zipBlob.size / 1024).toFixed(1)} KB).`);
                const downloadUrl = URL.createObjectURL(zipBlob); const link = document.createElement('a'); link.href = downloadUrl; link.download = projectFilename; document.body.appendChild(link); link.click(); document.body.removeChild(link); setTimeout(() => URL.revokeObjectURL(downloadUrl), 2000);
                console.log(`[${new Date().toISOString()}] Project saved successfully: ${projectFilename}`); alert(`ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ä¿å­˜ã—ã¾ã—ãŸã€‚\nãƒ•ã‚¡ã‚¤ãƒ«å: ${link.download}`);
            } catch (error) { console.error(`[${new Date().toISOString()}] Error saving project:`, error); alert(`ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ä¿å­˜ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:\n${error.message}`); } finally { hideLoading(); }
        }
        async function loadProject(projectFile) {
            if (typeof JSZip === 'undefined') { throw new Error('ZIPãƒ©ã‚¤ãƒ–ãƒ©ãƒª(JSZip)ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚'); } console.log(`[${new Date().toISOString()}] Starting project load: ${projectFile.name}`);
            const zip = await JSZip.loadAsync(projectFile); const projectDataFile = zip.file(PROJECT_DATA_FILENAME); if (!projectDataFile) { throw new Error(`${PROJECT_DATA_FILENAME} ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚`); }
            const projectDataJson = await projectDataFile.async('string'); let projectData; try { projectData = JSON.parse(projectDataJson); } catch (e) { throw new Error(`${PROJECT_DATA_FILENAME} ã®è§£æã‚¨ãƒ©ãƒ¼: ${e.message}`); }
            // Version Check (Allow compatible versions)
            const projectVersion = projectData.fileFormatVersion;
            if (!projectVersion) { console.warn("Project file is missing version info. Trying load anyway."); }
            else if (projectVersion !== PROJECT_FILE_FORMAT_VERSION) { console.warn(`Project file version mismatch. Expected ${PROJECT_FILE_FORMAT_VERSION}, got ${projectVersion}. Trying load.`); }

            logFileNameBase = projectData.logFileNameBase || 'loaded_project'; customizationSettings = projectData.customizationSettings || {}; customizationSettings = { ...{ normalBubbleColor: '#ffffff', fontSize: 16, backgroundColor: '#f3f4f6', iconSize: 64, bubbleMaxWidth: 80, nameBelowIconMode: false, fontFamily: 'font-noto-sans', logDisplayHeight: 384, skipDeleteConfirm: false }, ...customizationSettings}; nextUniqueId = projectData.nextUniqueId || 0; const filters = projectData.currentFilters || { tab: 'all', speaker: 'all' }; currentTabFilter = filters.tab; currentSpeakerFilter = filters.speaker;
            const imageFolder = zip.folder(PROJECT_IMAGES_FOLDER.replace('/', '')); const imageDataUrlMap = new Map(); const newUploadedFiles = {};
            if (imageFolder) {
                const imagePromises = [];
                imageFolder.forEach((relativePath, zipEntry) => {
                    if (zipEntry.dir) return; const fullPath = `${PROJECT_IMAGES_FOLDER}${relativePath}`;
                    const promise = zipEntry.async('blob').then(blob => { const filename = relativePath; const imageFile = createFileFromBlob(blob, filename); if (!imageFile) { throw new Error(`Failed to create File object for ${filename}`); } return readFileAsDataURL(imageFile).then(dataUrl => { imageDataUrlMap.set(fullPath, dataUrl); const manifestEntry = projectData.uploadedFileManifest?.[fullPath]; if (manifestEntry) { let key = null; if (manifestEntry.type === 'defaultIcon') key = manifestEntry.speaker; else if (manifestEntry.type === 'expressionIcon') key = `exp_${manifestEntry.speaker}_${manifestEntry.expressionName}`; else if (manifestEntry.type === 'overrideIcon') key = `icon_msg_${manifestEntry.messageId}`; else if (manifestEntry.type === 'insertedImage') key = manifestEntry.imageId; if (key) newUploadedFiles[key] = imageFile; else console.warn(`Could not determine key for image: ${fullPath}`); } else console.warn(`Manifest entry missing for: ${fullPath}`); }); }).catch(err => { console.error(`Error reading image ${relativePath}:`, err); imageDataUrlMap.set(fullPath, null); });
                    imagePromises.push(promise);
                });
                await Promise.all(imagePromises); uploadedFiles = newUploadedFiles; console.log(`   [Project Load] Loaded ${imageDataUrlMap.size} images, reconstructed ${Object.keys(uploadedFiles).length} uploadedFiles.`);
            } else { console.warn("Images folder not found."); }
            characterSettings = {};
            if (projectData.characterSettings) { for (const [speaker, loadedSetting] of Object.entries(projectData.characterSettings)) { const newSetting = { displayName: loadedSetting.displayName, icon: loadedSetting.iconPath ? (imageDataUrlMap.get(loadedSetting.iconPath) || null) : null, expressions: {} }; if (loadedSetting.expressions) { for (const [expName, expPath] of Object.entries(loadedSetting.expressions)) { newSetting.expressions[expName] = expPath ? (imageDataUrlMap.get(expPath) || null) : null; } } characterSettings[speaker] = newSetting; } }
            displayLogData = [];
            if (projectData.displayLogData) { displayLogData = projectData.displayLogData.map(item => { if (item.type === 'message') { const newItem = { ...item }; if (item.iconKey === 'override' && item.overrideIconPath) { newItem.overrideIconSrc = imageDataUrlMap.get(item.overrideIconPath) || null; } delete newItem.overrideIconPath; return newItem; } else if (item.type === 'image' && item.srcPath) { const newItem = { ...item }; newItem.src = imageDataUrlMap.get(item.srcPath) || null; delete newItem.srcPath; return newItem; } else if (item.type === 'error') { return { ...item }; } return null; }).filter(item => item !== null); }
             // Recalculate frequencies and tabs from loaded displayLogData
             speakerFrequencies = {}; uniqueTabsFound = new Set();
             displayLogData.forEach(item => {
                 if (item.type === 'message') { if(item.speaker && item.speaker !== 'system' && item.speaker !== 'ä¸æ˜') { speakerFrequencies[item.speaker] = (speakerFrequencies[item.speaker] || 0) + 1; } if (item.tab) { uniqueTabsFound.add(item.tab); } }
                  else if (item.type === 'image') { const isHeaderImage = item.afterOriginalIndex === HEADER_IMAGE_INDEX; if (!isHeaderImage) { const precedingMessage = findPrecedingMessage(item.afterOriginalIndex); if (precedingMessage?.tab) uniqueTabsFound.add(precedingMessage.tab); } }
             });
             if(uniqueTabsFound.size > 0 && !uniqueTabsFound.has('all')) uniqueTabsFound.add('all'); else if (uniqueTabsFound.size === 0) uniqueTabsFound = new Set(['all']);
            updateSpeakerDataForExport(); populateCharacterSettingsUI(); updateCustomizationUI(); populateTabsUI(); populateSpeakerFilterUI(); renderLog();
            console.log(`[${new Date().toISOString()}] Project loaded successfully.`);
        }

        // --- Export Functions (ZIP for viewing) ---
        async function handleExportZip() {
             const htmlTitle = exportHtmlTitleInput.value.trim() || logFileNameBase || 'session_log_export';
             const zipFilenameBase = exportZipFilenameInput.value.trim() || logFileNameBase || 'session_log_export';
             const zipFilename = `${zipFilenameBase}.zip`;
             const itemsToExport = displayLogData.map(item => { if (item.type === 'message') return { type: item.type, id: item.id, originalIndex: item.originalIndex, tab: item.tab, speaker: item.speaker, color: item.color, message: item.message, displayMode: item.displayMode || 'bubble', iconKey: item.iconKey || 'default' }; if (item.type === 'image') return { type: item.type, id: item.id, afterOriginalIndex: item.afterOriginalIndex, caption: item.caption }; if (item.type === 'error') return { type: item.type, id: item.id, originalIndex: item.originalIndex, message: item.message, details: item.details }; return null; }).filter(item => item !== null);
             const sortedExportData = itemsToExport.map(item => ({ ...item, sortIndex: item.type === 'image' ? (item.afterOriginalIndex === HEADER_IMAGE_INDEX ? -Infinity : (item.originalIndex ?? item.afterOriginalIndex ?? -1) + 0.5) : (item.originalIndex ?? -1) })).sort((a, b) => a.sortIndex - b.sortIndex);
             if (sortedExportData.length === 0) { alert('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚'); return; } if (typeof JSZip === 'undefined') { alert('ZIPä½œæˆãƒ©ã‚¤ãƒ–ãƒ©ãƒª(JSZip)ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ...'); return; }
             console.log(`[${new Date().toISOString()}] Starting ZIP export...`); showLoading();
             try {
                 const zip = new JSZip(); const outputCss = generateOutputCss(customizationSettings); zip.file("style.css", outputCss); const filterScriptContent = generateEmbeddedJsForExport(speakerDataForExport); const outputHtml = generateOutputHtml(sortedExportData, uniqueTabsFound, speakerDataForExport, htmlTitle, customizationSettings, filterScriptContent); zip.file("log_export.html", outputHtml);
                 console.log("   [ZIP Export] Adding images..."); const imgFolder = zip.folder("images"); if (!imgFolder) throw new Error("Failed to create 'images' folder."); let imageCount = 0; const addedFiles = new Set();
                 for (const [key, fileObject] of Object.entries(uploadedFiles)) {
                     if (!(fileObject instanceof Blob)) continue; const imagePath = getImagePathForKey(key, fileObject);
                     if (imagePath && !addedFiles.has(imagePath)) { try { imgFolder.file(imagePath.substring(PROJECT_IMAGES_FOLDER.length), fileObject); addedFiles.add(imagePath); imageCount++; } catch (zipAddError) { console.error(`Error adding file ${imagePath} to ZIP:`, zipAddError); } }
                      else if (imagePath && addedFiles.has(imagePath)) { /* Skip duplicate */ } else { console.warn(`Could not determine output filename for key: ${key}`); }
                 }
                 console.log(`   [ZIP Export] Added ${imageCount} images.`); console.log("   [ZIP Export] Generating ZIP blob...");
                 const zipBlob = await zip.generateAsync({ type: "blob", compression: "DEFLATE", compressionOptions: { level: 6 } }); console.log(`   [ZIP Export] ZIP blob generated (Size: ${(zipBlob.size / 1024).toFixed(1)} KB).`);
                 const downloadUrl = URL.createObjectURL(zipBlob); const link = document.createElement('a'); link.href = downloadUrl; link.download = zipFilename; document.body.appendChild(link); link.click(); document.body.removeChild(link); setTimeout(() => URL.revokeObjectURL(downloadUrl), 2000);
                 console.log(`[${new Date().toISOString()}] ZIP export complete.`); alert(`ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå®Œäº†: ${link.download}`);
             } catch (error) { console.error(`[${new Date().toISOString()}] Error during ZIP export:`, error); alert(`ZIPã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}`); } finally { hideLoading(); }
        }
        function generateOutputHtml(dataForExport, uniqueTabs, speakerData, htmlTitle, currentCustomization, embeddedJsContent) {
            console.log("   [generateOutputHtml] Generating HTML for export...");
            const { iconSize, nameBelowIconMode, fontFamily } = currentCustomization; let logBodyContent = '';
            dataForExport.forEach((item, index) => {
                try {
                     if (item.type === 'message' && index > 0) { let prevVisibleItem = null; for (let j = index - 1; j >= 0; j--) { const prevItem = dataForExport[j]; if (prevItem.type !== 'image' || prevItem.afterOriginalIndex !== HEADER_IMAGE_INDEX) { prevVisibleItem = prevItem; break; } } if (prevVisibleItem && prevVisibleItem.type === 'message' && (item.tab || 'main') !== (prevVisibleItem.tab || 'main')) { logBodyContent += '<hr class="tab-separator export">\n'; } }
                    if (item.type === 'message') {
                        const setting = characterSettings[item.speaker] || { displayName: item.speaker, icon: null, expressions: {} }; const speakerName = setting.displayName; const originalSpeaker = item.speaker; const iconKey = item.iconKey || 'default'; const messageId = item.id; let iconRelativePath = ''; let hasIconFile = false; let iconFileKey = null;
                        if (iconKey === 'override') { iconFileKey = `icon_msg_${messageId}`; } else if (iconKey !== 'default') { iconFileKey = `exp_${originalSpeaker}_${iconKey}`; } else { iconFileKey = originalSpeaker; }
                        if (iconFileKey && uploadedFiles[iconFileKey] instanceof Blob) { const file = uploadedFiles[iconFileKey]; iconRelativePath = getImagePathForKey(iconFileKey, file); hasIconFile = !!iconRelativePath; }
                        // Fallback to DataURL if file is missing (e.g., loaded from local storage)
                        if (!hasIconFile) {
                             const messageData = displayLogData.find(d => d.id === messageId);
                             if (iconKey === 'override' && messageData?.overrideIconSrc) iconRelativePath = messageData.overrideIconSrc;
                             else if (iconKey !== 'default' && setting.expressions?.[iconKey]) iconRelativePath = setting.expressions[iconKey];
                             else if (setting.icon) iconRelativePath = setting.icon;
                             else iconRelativePath = ''; // No icon found
                         }
                        const iconBorderColor = item.color || '#000000'; const messageHtmlContent = item.message; const escapedSpeakerName = escapeHtml(speakerName); const placeholderDisplay = !iconRelativePath ? 'inline-block' : 'none'; const imageDisplay = iconRelativePath ? 'block' : 'none'; const iconContainerStyle = `width: ${iconSize}px; height: ${iconSize}px;`; const placeholderChar = escapedSpeakerName.charAt(0) || '?'; const placeholderLineHeight = Math.round(iconSize * 0.9); const placeholderFontSize = Math.round(iconSize * 0.5); const tabDisplay = escapeHtml(item.tab || 'main'); const displayMode = item.displayMode || 'bubble';
                        logBodyContent += `
<div class="message-item export log-item" data-tab="${escapeHtml(item.tab || 'main')}" data-speaker="${escapeHtml(originalSpeaker)}" data-display-mode="${displayMode}">
    <div class="message-container export">
        <div class="icon-container export" style="${iconContainerStyle}">
            <img src="${iconRelativePath}" alt="${escapedSpeakerName} (${iconKey})" class="icon export" style="border-color: ${iconBorderColor}; display: ${imageDisplay};" onerror="this.style.display='none'; this.nextElementSibling.style.display='inline-block';">
            <span class="icon-placeholder export" style="display: ${placeholderDisplay}; border-color: ${iconBorderColor}; line-height: ${placeholderLineHeight}px; font-size: ${placeholderFontSize}px;">${placeholderChar}</span>
            <span class="speaker-name-below-icon export">${escapedSpeakerName}</span>
        </div>
        <div class="content-container export">
            <span class="speaker-name-default export">${escapedSpeakerName} <span class="original-tab export">[${tabDisplay}]</span></span>
            <span class="tab-name-below-icon export">[${tabDisplay}]</span>
            <div class="bubble export bubble-left export bubble-normal export">${messageHtmlContent}</div>
        </div>
    </div>
    <div class="narration-container export">
        <span class="narration-tab">[${tabDisplay}]</span>
        <span class="narration-speaker">${escapedSpeakerName}:</span>
        <span class="narration-message">${messageHtmlContent}</span>
    </div>
</div>\n`;
                    } else if (item.type === 'image') {
                         let imageRelativePath = ''; const imageId = item.id; const isHeader = item.afterOriginalIndex === HEADER_IMAGE_INDEX; const dataTab = isHeader ? 'header' : (findPrecedingMessage(item.afterOriginalIndex)?.tab || 'main'); const dataSpeaker = isHeader ? 'header' : (findPrecedingMessage(item.afterOriginalIndex)?.speaker || 'ä¸æ˜');
                         if (uploadedFiles[imageId] instanceof Blob) { const file = uploadedFiles[imageId]; imageRelativePath = getImagePathForKey(imageId, file); } else { const imgData = displayLogData.find(d => d.id === imageId); imageRelativePath = imgData?.src || ''; }
                         const imageAlt = item.caption ? escapeHtml(item.caption) : `æŒ¿å…¥ç”»åƒ ${imageId}`;
                         logBodyContent += `
<div class="inserted-image-container export log-item" data-tab="${escapeHtml(dataTab)}" data-speaker="${escapeHtml(dataSpeaker)}">
    <img src="${imageRelativePath}" alt="${imageAlt}" class="inserted-image export" ${imageRelativePath ? '' : 'style="display:none;"'} onerror="this.style.display='none'; const p=document.createElement('p'); p.className='image-error-placeholder export'; p.textContent='[ç”»åƒ ${escapeHtml(imageId)} èª­è¾¼å¤±æ•—]'; this.parentNode.appendChild(p);">
    ${!imageRelativePath ? `<p class="image-error-placeholder export">[ç”»åƒ ${escapeHtml(imageId)} ãƒ•ã‚¡ã‚¤ãƒ«ä¸æ˜]</p>` : ''}`;
                         if (item.caption) { logBodyContent += `\n    <p class="image-caption export">${escapeHtml(item.caption)}</p>`; } logBodyContent += `\n</div>\n`;
                    } else if (item.type === 'error') { logBodyContent += `\n<div class="error-message export log-item" data-tab="all" data-speaker="all"><strong>è§£æã‚¨ãƒ©ãƒ¼:</strong> ${escapeHtml(item.message)}<br><small>è©³ç´°: ${escapeHtml(item.details)}...</small></div>\n`; }
                } catch (htmlGenError) { console.error(`Error generating HTML for item ID ${item.id}:`, htmlGenError); logBodyContent += `<div class="export-error">ã‚¢ã‚¤ãƒ†ãƒ (ID: ${item.id})ã®HTMLç”Ÿæˆã‚¨ãƒ©ãƒ¼</div>\n`; }
            });
            let filterControlsHtml = `
<div class="filter-controls export">
    <div class="filter-section"> <label for="export-tab-filter">ã‚¿ãƒ–:</label> <nav id="export-log-tabs" class="tab-nav export" aria-label="Log Tabs"><span class="placeholder">èª­ã¿è¾¼ã¿ä¸­...</span></nav> </div>
    <div class="filter-section"> <label for="export-speaker-filter">ç™ºè¨€è€…:</label> <select id="export-speaker-filter" class="speaker-filter export"><option value="all">ã™ã¹ã¦ã®ç™ºè¨€è€…</option></select> </div>
</div>`;
            const safeHtmlTitle = escapeHtml(htmlTitle); const nameBelowIconBodyClass = nameBelowIconMode ? 'name-below-icon-active' : ''; const fontBodyClass = fontFamily || 'font-noto-sans';
            return `<!DOCTYPE html>
<html lang="ja"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>${safeHtmlTitle}</title><link rel="stylesheet" href="style.css"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Noto+Sans+JP:wght@400;700&family=Noto+Serif+JP:wght@400;700&family=M+PLUS+Rounded+1c:wght@400;700&display=swap" rel="stylesheet"></head>
<body class="${nameBelowIconBodyClass} ${fontBodyClass}"><div class="log-export-container"><h1>${safeHtmlTitle}</h1>${filterControlsHtml}<div id="export-log-display" class="log-display export">${logBodyContent || '<p class="empty-log-message export">ãƒ­ã‚°ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</p>'}</div></div><script>${embeddedJsContent}<\/script></body></html>`;
        }
        function generateEmbeddedJsForExport(speakerDisplayNameMap) {
             const speakerMapString = JSON.stringify(speakerDisplayNameMap || {});
             return `
 (function() { "use strict"; console.log("Exported Log Filter Script Initializing..."); let currentExportTab = 'all'; let currentExportSpeaker = 'all'; const speakerDisplayNames = ${speakerMapString}; const exportLogTabsNav = document.getElementById('export-log-tabs'); const exportSpeakerFilter = document.getElementById('export-speaker-filter'); const exportLogDisplay = document.getElementById('export-log-display'); const allLogItems = exportLogDisplay ? Array.from(exportLogDisplay.querySelectorAll('.log-item')) : []; if (!exportLogTabsNav || !exportSpeakerFilter || !exportLogDisplay || allLogItems.length === 0) { console.error("Required elements for filtering not found or no log items."); return; }
 function initializeExportFilters() { console.log('Found ' + allLogItems.length + ' log items.'); const uniqueTabs = new Set(['all']); const uniqueSpeakers = new Set(['all']); const speakerCounts = {}; allLogItems.forEach(item => { const tab = item.dataset.tab; const speaker = item.dataset.speaker; if (tab && tab !== 'all' && tab !== 'header') uniqueTabs.add(tab); if (speaker && speaker !== 'all' && speaker !== 'ä¸æ˜' && speaker !== 'header') { uniqueSpeakers.add(speaker); speakerCounts[speaker] = (speakerCounts[speaker] || 0) + 1; } }); console.log("Export Unique Tabs:", uniqueTabs); console.log("Export Unique Speakers:", uniqueSpeakers); populateExportTabs(uniqueTabs); populateExportSpeakerFilter(uniqueSpeakers, speakerCounts); exportSpeakerFilter.addEventListener('change', handleExportSpeakerChange); applyExportFilters(); }
 function populateExportTabs(tabsSet) { exportLogTabsNav.innerHTML = ''; const sortedTabs = [...tabsSet].sort((a, b) => a === 'all' ? -1 : b === 'all' ? 1 : a.localeCompare(b)); const fragment = document.createDocumentFragment(); sortedTabs.forEach(tab => { const button = document.createElement('button'); button.textContent = '[' + tab + ']'; button.dataset.tab = tab; button.className = 'tab-button export'; if (tab === currentExportTab) button.classList.add('active'); button.addEventListener('click', () => handleExportTabChange(tab)); fragment.appendChild(button); }); exportLogTabsNav.appendChild(fragment); }
 function populateExportSpeakerFilter(speakersSet, counts) { const sortedSpeakers = [...speakersSet].sort((a, b) => { if (a === 'all') return -1; if (b === 'all') return 1; const countDiff = (counts[b] || 0) - (counts[a] || 0); return countDiff !== 0 ? countDiff : a.localeCompare(b); }); const fragment = document.createDocumentFragment(); if (!sortedSpeakers.includes('all')) sortedSpeakers.unshift('all'); sortedSpeakers.forEach(speaker => { const option = document.createElement('option'); option.value = speaker; if (speaker === 'all') { option.textContent = 'ã™ã¹ã¦ã®ç™ºè¨€è€…'; } else { const displayName = speakerDisplayNames[speaker] || speaker; const count = counts[speaker] || 0; option.textContent = displayName + ' (' + count + 'å›)'; } fragment.appendChild(option); }); exportSpeakerFilter.innerHTML = ''; exportSpeakerFilter.appendChild(fragment); exportSpeakerFilter.value = currentExportSpeaker; exportSpeakerFilter.disabled = sortedSpeakers.length <= 1; }
 function handleExportTabChange(tabName) { if (currentExportTab === tabName) return; console.log('Export Filter - Tab changed to: ' + tabName); currentExportTab = tabName; exportLogTabsNav.querySelectorAll('.tab-button').forEach(btn => { btn.classList.toggle('active', btn.dataset.tab === tabName); }); applyExportFilters(); }
 function handleExportSpeakerChange() { const newSpeaker = exportSpeakerFilter.value; if (currentExportSpeaker === newSpeaker) return; console.log('Export Filter - Speaker changed to: ' + newSpeaker); currentExportSpeaker = newSpeaker; applyExportFilters(); }
 function applyExportFilters() { console.log('Applying export filters - Tab: ' + currentExportTab + ', Speaker: ' + currentExportSpeaker); let visibleCount = 0; allLogItems.forEach(item => { const itemTab = item.dataset.tab; const itemSpeaker = item.dataset.speaker; let isVisible = false; if (itemTab === 'header' || item.classList.contains('error-message')) { isVisible = true; } else { const tabMatch = currentExportTab === 'all' || itemTab === currentExportTab; const speakerMatch = currentExportSpeaker === 'all' || itemSpeaker === currentExportSpeaker; isVisible = tabMatch && speakerMatch; } if (isVisible) { item.classList.remove('hidden-log-item'); visibleCount++; } else { item.classList.add('hidden-log-item'); } }); console.log('Applied filters. ' + visibleCount + ' items visible.'); updateExportTabSeparators(); }
 function updateExportTabSeparators() { const separators = exportLogDisplay.querySelectorAll('.tab-separator.export'); separators.forEach(hr => hr.style.display = 'none'); if (currentExportTab === 'all') { let lastVisibleTab = null; let firstVisibleItemFound = false; const potentialSeparators = Array.from(exportLogDisplay.children); potentialSeparators.forEach((element) => { const isLogItem = element.classList.contains('log-item'); const isVisible = isLogItem && !element.classList.contains('hidden-log-item'); const isHeader = element.dataset.tab === 'header'; if (isVisible && !isHeader) { const currentItemTab = element.dataset.tab; if (firstVisibleItemFound && lastVisibleTab !== null && currentItemTab !== lastVisibleTab && currentItemTab !== 'all') { let previousElement = element.previousElementSibling; while (previousElement) { if (previousElement.classList.contains('tab-separator')) { previousElement.style.display = 'block'; break; } if ((previousElement.classList.contains('log-item') && !previousElement.classList.contains('hidden-log-item') && previousElement.dataset.tab !== 'header') || !previousElement.previousElementSibling) break; previousElement = previousElement.previousElementSibling; } } if (currentItemTab !== 'all' && currentItemTab !== 'header') lastVisibleTab = currentItemTab; firstVisibleItemFound = true; } }); } }
 if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', initializeExportFilters); } else { initializeExportFilters(); } })();`;
         }
        function generateOutputCss(currentCustomization) {
            console.log("   [generateOutputCss] Generating CSS for export...");
             const { iconSize, bubbleMaxWidth, normalBubbleColor, backgroundColor, fontSize, nameBelowIconMode, fontFamily } = currentCustomization; const placeholderLineHeight = Math.round(iconSize * 0.9); const placeholderFontSize = Math.round(iconSize * 0.5); const responsiveIconSize = Math.max(24, Math.round(iconSize * 0.75)); const responsivePlaceholderLineHeight = Math.round(responsiveIconSize * 0.9); const responsivePlaceholderFontSize = Math.round(responsiveIconSize * 0.5); const fontFamilies = { 'font-inter': "'Inter', sans-serif", 'font-noto-sans': "'Noto Sans JP', sans-serif", 'font-noto-serif': "'Noto Serif JP', serif", 'font-mplus-rounded': "'M PLUS Rounded 1c', sans-serif", 'font-system-sans': "sans-serif", 'font-system-serif': "serif", 'font-system-mono': "monospace" }; const selectedFontFamily = fontFamilies[fontFamily] || fontFamilies['font-noto-sans'];
             return `
 :root { --bubble-max-width: ${bubbleMaxWidth}%; --bubble-bg-color: ${normalBubbleColor}; --bubble-arrow-color: ${normalBubbleColor}; --icon-size: ${iconSize}px; }
 body { font-family: ${selectedFontFamily}; margin: 0; padding: 15px; background-color: ${backgroundColor}; font-size: ${fontSize}px; line-height: 1.7; color: #333; }
 .log-export-container { max-width: 900px; margin: 20px auto; background-color: ${logDisplayDiv.style.backgroundColor || '#ffffff'}; padding: 20px 25px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); }
 h1 { font-size: 1.7em; color: #111; border-bottom: 2px solid #eee; padding-bottom: 10px; margin: 0 0 25px 0; text-align: center; }
 .filter-controls.export { background-color: #f8f9fa; padding: 10px 15px; border-radius: 6px; margin-bottom: 20px; border: 1px solid #dee2e6; display: flex; flex-wrap: wrap; gap: 15px; align-items: center; }
 .filter-section { display: flex; align-items: center; gap: 8px; } .filter-section label { font-weight: bold; font-size: 0.9em; color: #495057; }
 .tab-nav.export { display: flex; flex-wrap: wrap; gap: 5px; padding-bottom: 5px; }
 .tab-button.export { background-color: #e9ecef; border: 1px solid #ced4da; color: #495057; padding: 4px 10px; border-radius: 4px; cursor: pointer; font-size: 0.85em; transition: background-color 0.2s, color 0.2s; white-space: nowrap; } .tab-button.export:hover { background-color: #dee2e6; } .tab-button.export.active { background-color: #0d6efd; border-color: #0d6efd; color: white; font-weight: bold; }
 .speaker-filter.export { padding: 5px 8px; border: 1px solid #ced4da; border-radius: 4px; font-size: 0.9em; background-color: white; min-width: 150px; }
 .tab-nav.export .placeholder { font-size: 0.85em; color: #6c757d; }
 .log-display.export { margin-top: 10px; } .hidden-log-item { display: none !important; } .log-item { margin-bottom: 16px; }
 .message-item.export { position: relative; } .message-container.export { display: flex; align-items: flex-start; } .narration-container.export { padding: 2px 4px; line-height: inherit; color: #333; }
 .message-item.export[data-display-mode="narration"] .message-container.export { display: none; } .message-item.export[data-display-mode="bubble"] .narration-container.export { display: none; }
 .icon-container.export { flex-shrink: 0; margin-right: 12px; width: var(--icon-size); height: var(--icon-size); position: relative; border-radius: 50%; }
 .icon.export { display: block; width: 100%; height: 100%; border-radius: 50%; object-fit: cover; object-position: 50% 0%; border: 3px solid; box-sizing: border-box; background-color: #f0f0f0; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2); }
 .icon-placeholder.export { display: none; width: 100%; height: 100%; border-radius: 50%; border: 3px solid; box-sizing: border-box; background-color: #e0e0e0; color: #757575; font-weight: bold; text-align: center; overflow: hidden; text-transform: uppercase; line-height: ${placeholderLineHeight}px; font-size: ${placeholderFontSize}px; }
 .content-container.export { flex-grow: 1; min-width: 0; }
 .speaker-name-default.export { display: block; font-weight: bold; margin-bottom: 4px; color: #1a1a1a; font-size: 0.9em; } .original-tab.export { font-weight: normal; font-size: 0.88em; color: #555; margin-left: 6px; }
 .tab-name-below-icon.export { display: none; font-size: 0.8em; color: #666; margin-bottom: 2px; }
 .speaker-name-below-icon.export { display: none; font-size: 0.85em; font-weight: bold; color: #333; text-shadow: -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff, 1px 1px 0 #fff, -1.5px -1.5px 0 #fff, 1.5px -1.5px 0 #fff, -1.5px 1.5px 0 #fff, 1.5px 1.5px 0 #fff; position: absolute; bottom: -1.5em; left: 50%; transform: translateX(-50%); width: max-content; max-width: calc(var(--icon-size) + 20px); line-height: 1.1; text-align: center; pointer-events: none; }
 .bubble.export { position: relative; padding: 10px 15px; border-radius: 16px; word-wrap: break-word; word-break: break-word; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12); background-color: var(--bubble-bg-color); max-width: var(--bubble-max-width); }
 .bubble-left.export { margin-left: 0; } .bubble-left.export::before { content: ""; position: absolute; top: 10px; left: -8px; width: 0; height: 0; border-style: solid; border-width: 8px 10px 8px 0; border-color: transparent var(--bubble-arrow-color) transparent transparent; }
 .bubble.export a { color: #0066cc; text-decoration: underline; } .bubble.export a:hover { color: #004c99; text-decoration: none; }
 .message-item.export[data-display-mode="narration"] .narration-tab, .message-item.export[data-display-mode="narration"] .narration-speaker { display: none; }
 .narration-tab { font-size: 0.8em; color: #666; margin-right: 0.5em; } .narration-speaker { font-weight: bold; margin-right: 0.25em; } .narration-message { display: inline; }
 body.name-below-icon-active .icon-container.export { margin-bottom: 1.8em; overflow: visible; } body.name-below-icon-active .speaker-name-default.export { display: none; } body.name-below-icon-active .tab-name-below-icon.export { display: block; } body.name-below-icon-active .speaker-name-below-icon.export { display: block; } body.name-below-icon-active .bubble-left.export { margin-left: 0; } body.name-below-icon-active .bubble-left.export::before { left: -8px; } body.name-below-icon-active .action-button-container { margin-left: 0; }
 .inserted-image-container.export { text-align: center; } .inserted-image.export { max-width: 85%; max-height: 550px; border-radius: 6px; box-shadow: 0 3px 8px rgba(0, 0, 0, 0.15); display: block; margin: 0 auto; }
 .image-caption.export { font-size: 0.9em; color: #444; margin-top: 6px; padding: 0 5%; line-height: 1.4; }
 .image-error-placeholder.export { color: #d9534f; font-size: 0.9em; font-weight: bold; margin-top: 8px; padding: 5px; background-color: #f2dede; border: 1px solid #ebccd1; border-radius: 4px; display: inline-block; }
 .tab-separator.export { border: 0; border-top: 2px dashed #cccccc; margin: 25px 5%; display: none; }
 .error-message.export { background-color: #fff3cd; border: 1px solid #ffeeba; color: #856404; padding: 10px 15px; border-radius: 4px; margin: 15px 0; font-size: 0.9em; } .error-message.export strong { font-weight: bold; } .error-message.export small { color: #66512c; display: block; margin-top: 4px; }
 .empty-log-message.export { text-align: center; color: #666; font-style: italic; padding: 30px; }
 .export-error { color: red; font-weight: bold; text-align: center; margin: 10px; padding: 5px; border: 1px solid red; background-color: #ffeeee; }
 @media (max-width: 768px) { body { padding: 10px; font-size: ${Math.max(14, fontSize - 1)}px; } .log-export-container { padding: 15px; } h1 { font-size: 1.5em; margin-bottom: 20px; } .filter-controls.export { flex-direction: column; align-items: stretch; } .filter-section { flex-direction: column; align-items: flex-start; width: 100%; } .tab-nav.export { justify-content: center; } .speaker-filter.export { width: 100%; } .icon-container.export { width: ${responsiveIconSize}px; height: ${responsiveIconSize}px; margin-right: 10px; } .icon-placeholder.export { line-height: ${responsivePlaceholderLineHeight}px; font-size: ${responsivePlaceholderFontSize}px; } .bubble.export { padding: 8px 12px; } .bubble-left.export::before { top: 8px; left: -7px; border-width: 7px 9px 7px 0;} .speaker-name-default.export { font-size: 0.92em; } .original-tab.export { font-size: 0.82em; } .tab-name-below-icon.export { font-size: 0.75em; } .speaker-name-below-icon.export { font-size: 0.8em; max-width: calc(${responsiveIconSize}px + 15px); bottom: -1.3em; } body.name-below-icon-active .icon-container.export { margin-bottom: 1.5em; } .inserted-image.export { max-width: 95%; max-height: 400px; } .image-caption.export { font-size: 0.85em; padding: 0 2%; } .tab-separator.export { margin: 20px 3%; } }
 `;
         }

        // --- Initialization ---
        function initializeApp() {
            console.log(`Initializing Log Formatter App (${APP_VERSION})...`);
            loadCustomization(); updateCustomizationUI();

            // ======[ ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®ç™»éŒ² ]======
            cocofoliaFileInput.addEventListener('change', handleCocofoliaFileSelect);
            tekeyFileInput.addEventListener('change', handleTekeyFileSelect);
            projectLoadInput.addEventListener('change', handleProjectLoadFile);
            // ================================================

            settingsTabButton.addEventListener('click', () => switchSettingsTab('settings'));
            customizeTabButton.addEventListener('click', () => switchSettingsTab('customize'));
            saveSettingsButton.addEventListener('click', saveCharacterSettings);
            loadSettingsButton.addEventListener('click', loadCharacterSettings);
            applyCustomizationButton.addEventListener('click', applyCustomization);
            resetCustomizationButton.addEventListener('click', resetCustomization);
            logTabsNav.addEventListener('click', (e) => { if (e.target.tagName === 'BUTTON' && e.target.dataset.tab) handleTabChange(e.target.dataset.tab); });
            speakerFilterSelect.addEventListener('change', handleSpeakerFilterChange);
            exportButton.addEventListener('click', handleExportZip);
            saveProjectButton.addEventListener('click', saveProject);
            insertImageInput.addEventListener('change', handleInsertImageFile);
            addHeaderImageButton.addEventListener('click', () => triggerImageInsert(HEADER_IMAGE_INDEX));

            // Customization listeners
            fontSizeSlider.addEventListener('input', () => { fontSizeValueSpan.textContent = fontSizeSlider.value; });
            iconSizeSlider.addEventListener('input', () => { iconSizeValueSpan.textContent = iconSizeSlider.value; });
            bubbleWidthSlider.addEventListener('input', () => { bubbleWidthValueSpan.textContent = bubbleWidthSlider.value; });
            logHeightSlider.addEventListener('input', () => { const newHeight = logHeightSlider.value; logHeightValueSpan.textContent = newHeight; logDisplayDiv.style.height = `${newHeight}px`; customizationSettings.logDisplayHeight = parseInt(newHeight, 10); });
            fontSizeSlider.addEventListener('change', applyCustomization);
            iconSizeSlider.addEventListener('change', applyCustomization);
            bubbleWidthSlider.addEventListener('change', applyCustomization);
            logHeightSlider.addEventListener('change', applyCustomization); // Apply on change for height
            nameBelowIconToggle.addEventListener('change', applyCustomization);
            fontFamilySelect.addEventListener('change', applyCustomization);
            normalColorInput.addEventListener('change', applyCustomization);
            backgroundColorInput.addEventListener('change', applyCustomization);
            skipDeleteConfirmToggle.addEventListener('change', applyCustomization);

            switchSettingsTab('settings'); hideLoading(); disableControls();
            console.log("App initialization complete.");
        }

        function switchSettingsTab(tabName) {
            const panels = [settingsPanel, customizePanel]; const buttons = [settingsTabButton, customizeTabButton];
            panels.forEach(panel => panel.classList.add('hidden')); buttons.forEach(button => { button.classList.remove('border-indigo-500', 'text-indigo-600'); button.classList.add('border-transparent', 'text-gray-500', 'hover:text-gray-700', 'hover:border-gray-300'); button.removeAttribute('aria-current'); });
            let activePanel; let activeButton; if (tabName === 'settings') { activePanel = settingsPanel; activeButton = settingsTabButton; } else if (tabName === 'customize') { activePanel = customizePanel; activeButton = customizeTabButton; }
            if (activePanel) activePanel.classList.remove('hidden'); if (activeButton) { activeButton.classList.add('border-indigo-500', 'text-indigo-600'); activeButton.classList.remove('border-transparent', 'text-gray-500', 'hover:text-gray-700', 'hover:border-gray-300'); activeButton.setAttribute('aria-current', 'page'); }
        }

        // --- Run Initialization ---
        if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', initializeApp); else initializeApp();

      })(); // End IIFE
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="ja">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-Q7E160JNKC"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-Q7E160JNKC');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ココフォリア/Tekeyログ整形ツール(画像埋め込み機能付き)</title> <!-- Title updated -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Noto+Sans+JP:wght@400;700&family=Noto+Serif+JP:wght@400;700&family=M+PLUS+Rounded+1c:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* --- Font Definitions --- */
        .font-inter { font-family: 'Inter', sans-serif; }
        .font-noto-sans { font-family: 'Noto Sans JP', sans-serif; }
        .font-noto-serif { font-family: 'Noto Serif JP', serif; }
        .font-mplus-rounded { font-family: "'M PLUS Rounded 1c'", sans-serif; }
        .font-system-sans { font-family: sans-serif; }
        .font-system-serif { font-family: serif; }
        .font-system-mono { font-family: monospace; }

        /* Basic styling */
        body {
            background-color: #f3f4f6; /* bg-gray-100 */
        }
        #log-display {
             line-height: 1.7;
        }

        /* Custom scrollbar for log display */
        #log-display::-webkit-scrollbar { width: 8px; }
        #log-display::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
        #log-display::-webkit-scrollbar-thumb { background: #888; border-radius: 10px; }
        #log-display::-webkit-scrollbar-thumb:hover { background: #555; }
        /* Icon styling */
        .icon-border {
            border-width: 3px;
            border-style: solid;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }
        .message-item .icon-container img.message-icon {
             cursor: pointer;
        }
        .character-icon-preview {
             cursor: pointer;
        }
        /* Chat bubble styling */
        .bubble {
            position: relative;
            padding: 10px 15px;
            border-radius: 15px;
            max-width: var(--bubble-max-width, 80%);
            word-wrap: break-word;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            background-color: var(--bubble-bg-color, #ffffff);
        }
        .bubble::before {
            content: "";
            position: absolute;
            top: 10px;
            width: 0;
            height: 0;
            border-style: solid;
        }
        .bubble-left {
            margin-right: auto;
            margin-left: calc(var(--icon-size, 64px) + 12px); /* Default icon size 64px */
        }
        .bubble-left::before {
            left: -8px;
            border-width: 8px 10px 8px 0;
            border-color: transparent var(--bubble-arrow-color, #ffffff) transparent transparent;
        }

        /* --- Message Display Modes --- */
        .message-item { position: relative; padding-top: 1.5px; padding-bottom: 1.5px; }
        .message-container { display: flex; align-items: flex-start; }
        .icon-container { flex-shrink: 0; position: relative; width: var(--icon-size); height: var(--icon-size); margin-right: 12px; }
        .content-container { flex-grow: 1; min-width: 0; }
        .speaker-name-default { display: block; font-size: 0.9em; font-weight: bold; color: #333; margin-bottom: 2px; }
        .tab-name-below-icon { display: none; font-size: 0.8em; color: #666; margin-bottom: 2px; }
        .speaker-name-below-icon { display: none; font-size: 0.85em; font-weight: bold; color: #333; text-align: center; text-shadow: -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff, 1px 1px 0 #fff, -1.5px -1.5px 0 #fff, 1.5px -1.5px 0 #fff, -1.5px 1.5px 0 #fff, 1.5px 1.5px 0 #fff; position: absolute; bottom: -1.5em; left: 50%; transform: translateX(-50%); width: max-content; max-width: calc(var(--icon-size, 64px) + 20px); line-height: 1.1; pointer-events: none; }

        /* Narration Mode Styles */
        .narration-container { padding: 2px 4px; margin-left: 0; font-size: inherit; line-height: inherit; color: #333; }
        .message-item[data-display-mode="narration"] .narration-tab,
        .message-item[data-display-mode="narration"] .narration-speaker { display: none; }
        .narration-tab { font-size: 0.8em; color: #666; margin-right: 0.5em; }
        .narration-speaker { font-weight: bold; margin-right: 0.25em; }
        .narration-message { display: block; }
        .message-item[data-display-mode="narration"] .message-container { display: none; }
        .message-item[data-display-mode="bubble"] .narration-container { display: none; }

        /* 名前をアイコン下に表示モード 有効時のスタイル */
        .name-below-icon-active .icon-container { margin-bottom: 1.8em; overflow: visible; }
        .name-below-icon-active .speaker-name-default { display: none; }
        .name-below-icon-active .tab-name-below-icon { display: block; }
        .name-below-icon-active .speaker-name-below-icon { display: block; }
        .name-below-icon-active .bubble-left { margin-left: 0; }
        .name-below-icon-active .bubble-left::before { left: -8px; }
        .name-below-icon-active .action-button-container { margin-left: 0; }

        /* Display Mode Toggle Button */
        .display-mode-toggle { position: absolute; top: 1px; right: 1px; padding: 3px 5px; font-size: 1rem; line-height: 1; border-radius: 4px; border: 1px solid #bbb; background-color: #f0f0f0; color: #333; cursor: pointer; opacity: 0.85; transition: opacity 0.2s, background-color 0.2s; z-index: 10; }
        .display-mode-toggle:hover { background-color: #ddd; border-color: #999; }

        /* Icon Selection Dropdown */
        .icon-select-dropdown { position: absolute; background-color: white; border: 1px solid #ccc; box-shadow: 0 2px 5px rgba(0,0,0,0.2); border-radius: 4px; padding: 5px 0; min-width: 150px; z-index: 100; }
        .icon-select-dropdown button { display: block; width: 100%; padding: 6px 12px; text-align: left; background: none; border: none; cursor: pointer; font-size: 0.9em; white-space: nowrap; }
        .icon-select-dropdown button:hover { background-color: #f0f0f0; }
        .icon-select-separator { border-top: 1px solid #eee; margin: 4px 0; }
        .icon-select-dropdown button img { width: 20px; height: 20px; border-radius: 50%; object-fit: cover; margin-right: 8px; vertical-align: middle; border: 1px solid #ddd; }

        /* Character Settings Expression UI */
        .expression-section { margin-top: 1rem; padding-top: 0.75rem; border-top: 1px solid #e5e7eb; }
        .expression-item { display: flex; align-items: center; gap: 0.75rem; padding: 0.5rem 0; border-bottom: 1px solid #f3f4f6; }
        .expression-item:last-child { border-bottom: none; }
        .expression-preview { width: 2rem; height: 2rem; border-radius: 9999px; object-fit: cover; border: 1px solid #d1d5db; }
        .expression-name { flex-grow: 1; font-size: 0.875rem; color: #374151; }
        .expression-delete-btn { flex-shrink: 0; padding: 0.125rem 0.375rem; font-size: 0.75rem; background-color: #fee2e2; color: #dc2626; border-radius: 0.25rem; border: 1px solid #fecaca; cursor: pointer; }
        .expression-delete-btn:hover { background-color: #fecaca; }
        .add-expression-form { display: flex; align-items: center; gap: 0.5rem; margin-top: 0.75rem; }
        .add-expression-form input[type="text"] { flex-grow: 1; padding: 0.375rem 0.625rem; font-size: 0.875rem; border: 1px solid #d1d5db; border-radius: 0.375rem; min-width: 80px; }
        .add-expression-form input[type="file"] { position: absolute; width: 1px; height: 1px; margin: -1px; padding: 0; overflow: hidden; clip: rect(0, 0, 0, 0); border: 0; }
        .add-expression-form label { padding: 0.375rem 0.75rem; font-size: 0.875rem; background-color: #e5e7eb; color: #374151; border: 1px solid #d1d5db; border-radius: 0.375rem; cursor: pointer; white-space: nowrap; }
        .add-expression-form label:hover { background-color: #d1d5db; }

        /* Other Styles */
        .inserted-image-container { margin-top: 8px; margin-bottom: 8px; text-align: center; }
        .inserted-image { max-width: 80%; max-height: 400px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); display: block; margin-left: auto; margin-right: auto; }
        .image-caption { font-size: 0.85em; color: #555; margin-top: 4px; padding: 0 10%; line-height: 1.4; }
        .tab-separator { border: 0; border-top: 2px dotted #ccc; margin: 15px 5%; }
        #loading-overlay { position: fixed; inset: 0; background-color: rgba(0, 0, 0, 0.6); display: flex; justify-content: center; align-items: center; z-index: 9999; opacity: 0; transition: opacity 0.3s ease-out; pointer-events: none; }
        #loading-overlay.visible { opacity: 1; pointer-events: auto; }
        .loader { border: 8px solid #f3f3f3; border-top: 8px solid #3498db; border-radius: 50%; width: 60px; height: 60px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .visually-hidden { position: absolute; width: 1px; height: 1px; margin: -1px; padding: 0; overflow: hidden; clip: rect(0, 0, 0, 0); border: 0; }
        .file-input-label { display: inline-block; padding: 0.5rem 1rem; cursor: pointer; border-radius: 0.375rem; background-color: #4f46e5; color: white; font-weight: 600; transition: background-color 0.2s; }
        .file-input-label:hover { background-color: #4338ca; }
        .action-button-container { margin-top: 4px; display: flex; justify-content: flex-start; gap: 8px; flex-wrap: wrap; }
        .action-button { font-size: 0.75rem; padding: 0.125rem 0.5rem; border-radius: 0.25rem; transition: background-color 0.15s ease-in-out, color 0.15s ease-in-out; border: none; cursor: pointer; line-height: 1.5; }
        .action-button:focus { outline: none; box-shadow: 0 0 0 2px rgba(96, 165, 250, 0.5); }
        .action-button-insert { background-color: #e5e7eb; color: #374151; } .action-button-insert:hover { background-color: #d1d5db; }
        .action-button-delete { background-color: #fee2e2; color: #b91c1c; } .action-button-delete:hover { background-color: #fecaca; }
        .action-button-edit { background-color: #dbeafe; color: #1d4ed8; } .action-button-edit:hover { background-color: #bfdbfe; }
        .switch { position: relative; display: inline-block; width: 50px; height: 24px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 24px; }
        .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #2196F3; } input:checked + .slider:before { transform: translateX(26px); }

        /* Footer Styling */
        .app-footer { margin-top: 2rem; padding-top: 1.5rem; border-top: 1px solid #e5e7eb; font-size: 0.875rem; color: #6b7280; }
        .app-footer h4 { font-size: 1rem; font-weight: 600; color: #4b5563; margin-bottom: 0.5rem; }
        .app-footer ul { list-style-type: disc; list-style-position: inside; margin-bottom: 1rem; padding-left: 0.5rem; }
        .app-footer li { margin-bottom: 0.25rem; }
        .app-footer a { color: #4f46e5; text-decoration: underline; transition: color 0.2s; }
        .app-footer a:hover { color: #4338ca; }
        .footer-credits { margin-top: 1rem; text-align: center; }
    </style>
</head>
<body class="bg-gray-100 p-4 md:p-8">
    <div class="container mx-auto max-w-7xl bg-white rounded-lg shadow-xl p-5 md:p-8">
        <h1 class="text-2xl md:text-3xl font-bold mb-4 text-center text-gray-800">ココフォリア/Tekeyログ整形ツール (プロジェクト保存対応)</h1>
        <div class="mb-6 p-4 border border-blue-200 rounded-lg bg-blue-50 text-sm text-blue-800">
            <h3 class="font-semibold mb-1">使い方:</h3>
            <ol class="list-decimal list-inside space-y-1">
                <li>「ココフォリアログ選択...」または「Tekeyログ選択...」でHTMLログを読み込むか、「プロジェクト(.cclogproj)選択...」で以前保存した作業状態を読み込みます。</li>
                <li>キャラクター設定タブで表示名/アイコン/表情差分を設定します（設定はLocalStorageに一時保存/読込可能）。</li>
                <li>表示カスタマイズタブでフォントや色、表示モードなどを調整します。</li>
                <li>ログ表示エリアで、タブ/発言者フィルタリング、先頭/メッセージ後への画像挿入、表示モード(💬/📝)/アイコン(クリックで選択)の個別変更、メッセージ編集が可能です。</li>
                <li>「プロジェクトを保存 (.cclogproj)」で編集状態全体をファイルに保存できます。</li>
                <li>「整形済みログをZIPで出力」で、閲覧・共有用のHTMLログセットを出力します。</li>
            </ol>
        </div>

        <!-- ======[ ファイル選択セクション ]====== -->
        <div class="mb-6 p-4 border border-dashed border-gray-300 rounded-lg bg-gray-50">
            <div class="flex flex-wrap items-center gap-x-6 gap-y-4">
                <!-- ココフォリアログ選択 -->
                <div>
                    <label for="cocofolia-log-input" class="block text-lg font-semibold mb-1 text-gray-700">1a. ココフォリアログ:</label>
                    <input type="file" id="cocofolia-log-input" accept=".html" class="visually-hidden">
                    <label for="cocofolia-log-input" class="file-input-label">ココフォリアログ選択...</label>
                </div>
                <!-- Tekeyログ選択 -->
                <div>
                    <label for="tekey-log-input" class="block text-lg font-semibold mb-1 text-gray-700">1b. Tekeyログ:</label>
                    <input type="file" id="tekey-log-input" accept=".html" class="visually-hidden">
                    <label for="tekey-log-input" class="file-input-label bg-purple-600 hover:bg-purple-700">Tekeyログ選択...</label>
                </div>
                <!-- プロジェクト読み込み -->
                <div class="border-l pl-4">
                     <label for="project-load-input" class="block text-lg font-semibold mb-1 text-gray-700">1c. またはプロジェクト読込:</label>
                    <input type="file" id="project-load-input" accept=".cclogproj" class="visually-hidden">
                    <label for="project-load-input" class="file-input-label bg-green-600 hover:bg-green-700">プロジェクト(.cclogproj)選択...</label>
                </div>
            </div>
            <div class="mt-3">
                 <span id="file-info" class="text-sm font-medium text-blue-600 align-middle">ファイルが選択されていません</span>
                 <span id="project-load-info" class="ml-3 text-sm font-medium text-green-600 align-middle"></span>
            </div>
             <p class="mt-2 text-sm text-gray-500">ココフォリアHTMLログ、Tekey HTMLログ (v2形式推奨)、または以前保存した整形プロジェクトファイル(.cclogproj)を選択してください。</p>
        </div>
        <!-- ================================ -->

        <div class="mb-6">
             <div class="border-b border-gray-200">
                <nav class="-mb-px flex space-x-6" aria-label="Tabs">
                    <button id="tab-btn-settings" data-tab-target="settings" class="whitespace-nowrap py-3 px-1 border-b-2 font-medium text-sm border-indigo-500 text-indigo-600" aria-current="page">キャラクター設定</button>
                    <button id="tab-btn-customize" data-tab-target="customize" class="whitespace-nowrap py-3 px-1 border-b-2 font-medium text-sm border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300">表示カスタマイズ</button>
                </nav>
            </div>

            <div id="settings-panel-settings" class="mt-4 p-4 border rounded-lg bg-gray-50" role="tabpanel" aria-labelledby="tab-btn-settings">
                <h3 class="text-lg font-semibold mb-3 text-gray-700">2. キャラクター設定:</h3>
                <p class="text-sm text-gray-600 mb-4">ログから検出された発言者名です。デフォルトの表示名/アイコン、表情差分アイコンを設定してください。</p>
                <div id="character-settings" class="space-y-4"><p class="text-gray-500 italic">ログファイルまたはプロジェクトファイルを読み込むと表示されます。</p></div>
                 <button id="save-settings-button" class="mt-4 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed" disabled>設定を一時保存(LocalStorage)</button>
                 <button id="load-settings-button" class="mt-4 ml-2 px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed" disabled>設定を読み込み(LocalStorage)</button>
                 <p class="text-xs text-gray-500 mt-1">※この保存/読込はプロジェクトファイルとは別です。</p>
            </div>

            <div id="settings-panel-customize" class="hidden mt-4 p-4 border rounded-lg bg-gray-50" role="tabpanel" aria-labelledby="tab-btn-customize">
                 <h3 class="text-lg font-semibold mb-3 text-gray-700">表示カスタマイズ:</h3>
                 <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div><label for="bubble-normal-color" class="block text-sm font-medium text-gray-700">吹き出し色:</label><input type="color" id="bubble-normal-color" value="#ffffff" class="mt-1 block w-full h-8 rounded border border-gray-300 cursor-pointer p-0.5"></div>
                    <div><label for="font-size-slider" class="block text-sm font-medium text-gray-700">フォントサイズ: <span id="font-size-value">16</span>px</label><input type="range" id="font-size-slider" min="10" max="24" value="16" class="mt-1 block w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"></div>
                    <div><label for="background-color" class="block text-sm font-medium text-gray-700">背景色:</label><input type="color" id="background-color" value="#f3f4f6" class="mt-1 block w-full h-8 rounded border border-gray-300 cursor-pointer p-0.5"></div>
                    <div><label for="icon-size-slider" class="block text-sm font-medium text-gray-700">アイコンサイズ: <span id="icon-size-value">64</span>px</label><input type="range" id="icon-size-slider" min="24" max="64" value="64" class="mt-1 block w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"></div>
                    <div class="md:col-span-2"><label for="bubble-width-slider" class="block text-sm font-medium text-gray-700">吹き出し最大幅: <span id="bubble-width-value">80</span>%</label><input type="range" id="bubble-width-slider" min="30" max="100" value="80" class="mt-1 block w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"></div>
                    <div class="md:col-span-2"><label for="font-family-select" class="block text-sm font-medium text-gray-700">フォント:</label><select id="font-family-select" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 bg-white focus:border-indigo-500 focus:ring-indigo-500"><option value="font-noto-sans" selected>'Noto Sans JP' (推奨)</option><option value="font-inter">'Inter' (UI標準)</option><option value="font-noto-serif">'Noto Serif JP' (明朝)</option><option value="font-mplus-rounded">'M PLUS Rounded 1c' (丸ゴシック)</option><option value="font-system-sans">システム標準ゴシック</option><option value="font-system-serif">システム標準明朝</option><option value="font-system-mono">システム標準等幅</option></select></div>
                    <div class="md:col-span-2 flex items-center space-x-2"><label for="name-below-icon-toggle" class="text-sm font-medium text-gray-700">名前をアイコン下に表示:</label><label class="switch"><input type="checkbox" id="name-below-icon-toggle"><span class="slider"></span></label></div>
                    <div class="md:col-span-2"><label for="log-height-slider" class="block text-sm font-medium text-gray-700">ログ表示高さ: <span id="log-height-value">384</span>px</label><input type="range" id="log-height-slider" min="200" max="800" value="384" class="mt-1 block w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"></div>
                    <div class="md:col-span-2 flex items-center space-x-2">
                        <label for="skip-delete-confirm-toggle" class="text-sm font-medium text-gray-700">削除確認を省略:</label>
                        <label class="switch">
                            <input type="checkbox" id="skip-delete-confirm-toggle">
                            <span class="slider"></span>
                        </label>
                    </div>
                 </div>
                 <button id="apply-customization" class="mt-4 px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600">カスタマイズ適用</button>
                 <button id="reset-customization" class="mt-4 ml-2 px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600">リセット</button>
            </div>
        </div>

        <div class="mb-6">
            <h3 class="text-lg font-semibold mb-3 text-gray-700">3. ログ表示:</h3>
            <div class="mb-4 p-3 border rounded-lg bg-gray-50 flex flex-wrap items-center justify-between gap-4">
                 <div class="flex flex-wrap items-center gap-x-4 gap-y-2">
                     <div><label for="speaker-filter" class="block text-sm font-medium text-gray-700">発言者:</label><select id="speaker-filter" class="mt-1 block w-full md:w-auto rounded-md border-gray-300 shadow-sm p-2 text-sm bg-white focus:border-indigo-500 focus:ring-indigo-500" disabled><option value="all">すべての発言者</option></select></div>
                     <div><span class="block text-sm font-medium text-gray-700">タブ:</span><nav id="log-tabs" class="mt-1 -mb-px flex space-x-2 overflow-x-auto pb-1" aria-label="Log Tabs"><span class="whitespace-nowrap py-2 px-1 text-gray-500 text-sm italic">ログ読込中</span></nav></div>
                 </div>
                 <div><button id="add-header-image-button" class="mt-2 md:mt-0 px-3 py-1.5 bg-teal-500 text-white text-sm font-medium rounded-md hover:bg-teal-600 disabled:opacity-50 disabled:cursor-not-allowed" disabled>先頭に画像を追加</button></div>
            </div>

            <div id="log-display" class="overflow-y-auto border border-gray-300 rounded-lg p-4 bg-white space-y-1 font-noto-sans" style="--bubble-max-width: 80%; --bubble-bg-color: #ffffff; --bubble-arrow-color: #ffffff; --icon-size: 64px;" aria-live="polite">
                <p class="text-gray-500 text-center italic">ここに整形されたログが表示されます。</p>
            </div>
        </div>

        <div class="mt-8 text-center">
             <h3 class="text-lg font-semibold mb-3 text-gray-700">4. 保存 / エクスポート:</h3>
             <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4 max-w-lg mx-auto text-left">
                 <div>
                     <label for="export-html-title" class="block text-sm font-medium text-gray-700">HTMLタイトル / プロジェクト名:</label>
                     <input type="text" id="export-html-title" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-1.5 focus:border-indigo-500 focus:ring-indigo-500 text-sm" placeholder="例: セッションログ" disabled>
                 </div>
                 <div>
                     <label for="export-zip-filename" class="block text-sm font-medium text-gray-700">ZIPファイル名 / プロジェクトファイル名:</label>
                     <input type="text" id="export-zip-filename" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-1.5 focus:border-indigo-500 focus:ring-indigo-500 text-sm" placeholder="例: log_export" disabled>
                 </div>
             </div>
             <div class="flex flex-wrap justify-center items-center gap-4">
                 <button id="save-project-button" class="px-6 py-3 bg-green-600 text-white font-semibold rounded-lg shadow hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed" disabled>プロジェクトを保存 (.cclogproj)</button>
                 <button id="export-zip-button" class="px-6 py-3 bg-indigo-600 text-white font-semibold rounded-lg shadow hover:bg-indigo-700 disabled:opacity-50 disabled:cursor-not-allowed" disabled>整形済みログをZIPで出力</button>
             </div>
             <p class="mt-2 text-sm text-gray-500">プロジェクトファイルには編集状態全体が保存されます。</p>
             <p class="mt-2 text-sm text-gray-500">整形済みログZIPには、表示用のHTML/CSS/画像が含まれます。</p>
             <p class="text-xs text-gray-500">（注意: Google Fontsはオフラインでは表示されません）</p>
        </div>

        <footer class="app-footer">
            <h4>更新履歴</h4>
            <ul>
                 <li>2025/05/06: 先頭画像挿入機能、差分機能、プロジェクトのエクスポート・インポート機能追加、Tekeyログ読み込み機能追加</li>
                 <li>2025/05/03: 公開</li>
            </ul>
            <div class="footer-credits">
                作成者: しるべ (<a href="https://x.com/qxoiUioxp" target="_blank" rel="noopener noreferrer">@qxoiUioxp</a>)
            </div>
        </footer>
    </div>

    <!-- Hidden Inputs -->
    <input type="file" id="insert-image-input" accept="image/*" class="visually-hidden">
    <input type="file" id="message-icon-change-input" accept="image/*" class="visually-hidden">
    <input type="file" id="expression-icon-input-generic-placeholder" accept="image/*" class="visually-hidden">

    <!-- Loading Overlay -->
    <div id="loading-overlay" aria-hidden="true" aria-label="処理中"><div class="loader"></div></div>

    <!-- Icon Selection Dropdown Placeholder -->
    <div id="icon-select-dropdown" class="icon-select-dropdown hidden"></div>

    <script>
      // Wrap entire script in an IIFE (Immediately Invoked Function Expression)
      (function() {
        "use strict"; // Enable strict mode

        // --- State Variables ---
        let displayLogData = []; // Holds the unified log data being edited
        let characterSettings = {};
        let customizationSettings = {
            normalBubbleColor: '#ffffff', fontSize: 16, backgroundColor: '#f3f4f6',
            iconSize: 64, bubbleMaxWidth: 80, nameBelowIconMode: false,
            fontFamily: 'font-noto-sans', logDisplayHeight: 384,
            skipDeleteConfirm: false
         };
         let currentTabFilter = 'all';
         let currentSpeakerFilter = 'all';
         let uploadedFiles = {}; // key: File object (or Blob)
         let isProcessingFile = false;
         let speakerFrequencies = {};
         let imageInsertTargetIndex = -2;
         let nextUniqueId = 0;
         let logFileNameBase = 'session_log'; // Changed default
         let uniqueTabsFound = new Set();
         let speakerDataForExport = {};
         let messageIconChangeTargetId = null;
         let currentDropdown = null;
         let expressionAddContext = { speaker: null, inputElement: null };

         // Project file constants
         const PROJECT_FILE_EXTENSION = '.cclogproj';
         const PROJECT_DATA_FILENAME = 'project_data.json';
         const PROJECT_IMAGES_FOLDER = 'images/';
         const PROJECT_FILE_FORMAT_VERSION = '1.1'; // Version bump for Tekey support marker (optional)
         const APP_VERSION = '9.0-tekey-support-tabfix'; // Updated version

        // --- DOM Elements ---
        // ======[ ファイル入力要素の取得 ]======
        const cocofoliaFileInput = document.getElementById('cocofolia-log-input');
        const tekeyFileInput = document.getElementById('tekey-log-input');
        const projectLoadInput = document.getElementById('project-load-input');
        const fileInfoSpan = document.getElementById('file-info');
        const projectLoadInfoSpan = document.getElementById('project-load-info');
        // ===================================================
        const characterSettingsDiv = document.getElementById('character-settings');
        const logTabsNav = document.getElementById('log-tabs');
        const speakerFilterSelect = document.getElementById('speaker-filter');
        const logDisplayDiv = document.getElementById('log-display');
        const exportButton = document.getElementById('export-zip-button');
        const saveProjectButton = document.getElementById('save-project-button');
        const loadingOverlay = document.getElementById('loading-overlay');
        const saveSettingsButton = document.getElementById('save-settings-button');
        const loadSettingsButton = document.getElementById('load-settings-button');
        const settingsTabButton = document.getElementById('tab-btn-settings');
        const customizeTabButton = document.getElementById('tab-btn-customize');
        const settingsPanel = document.getElementById('settings-panel-settings');
        const customizePanel = document.getElementById('settings-panel-customize');
        const normalColorInput = document.getElementById('bubble-normal-color');
        const fontSizeSlider = document.getElementById('font-size-slider');
        const fontSizeValueSpan = document.getElementById('font-size-value');
        const backgroundColorInput = document.getElementById('background-color');
        const iconSizeSlider = document.getElementById('icon-size-slider');
        const iconSizeValueSpan = document.getElementById('icon-size-value');
        const bubbleWidthSlider = document.getElementById('bubble-width-slider');
        const bubbleWidthValueSpan = document.getElementById('bubble-width-value');
        const nameBelowIconToggle = document.getElementById('name-below-icon-toggle');
        const fontFamilySelect = document.getElementById('font-family-select');
        const applyCustomizationButton = document.getElementById('apply-customization');
        const resetCustomizationButton = document.getElementById('reset-customization');
        const insertImageInput = document.getElementById('insert-image-input');
        const exportHtmlTitleInput = document.getElementById('export-html-title');
        const exportZipFilenameInput = document.getElementById('export-zip-filename');
        const logHeightSlider = document.getElementById('log-height-slider');
        const logHeightValueSpan = document.getElementById('log-height-value');
        const iconChangeInput = document.getElementById('message-icon-change-input');
        const iconSelectDropdown = document.getElementById('icon-select-dropdown');
        const addHeaderImageButton = document.getElementById('add-header-image-button');
        const skipDeleteConfirmToggle = document.getElementById('skip-delete-confirm-toggle');

        // --- Constants ---
        const PLACEHOLDER_ICON_URL = 'https://placehold.co/64x64/e0e0e0/757575?text=?';
        const LOCALSTORAGE_SETTINGS_KEY = 'logToolSettings_v9.0'; // Version up
        const LOCALSTORAGE_CUSTOMIZATION_KEY = 'logToolCustomization_v9.0'; // Version up
        const FONT_CLASSES = [
             'font-inter', 'font-noto-sans', 'font-noto-serif',
             'font-mplus-rounded', 'font-system-sans', 'font-system-serif',
             'font-system-mono'
        ];
        const MAX_FILE_SIZE_MB = 5;
        const MAX_INSERT_IMAGE_SIZE_MB = 10;
        const MAX_FILE_SIZE_BYTES = MAX_FILE_SIZE_MB * 1024 * 1024;
        const MAX_INSERT_IMAGE_SIZE_BYTES = MAX_INSERT_IMAGE_SIZE_MB * 1024 * 1024;
        const HEADER_IMAGE_INDEX = -1;


        // --- Utility Functions ---
        function escapeHtml(unsafe) { if (typeof unsafe !== 'string') return ''; return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;"); }
        function escapeCssSelector(str) { if (!str) return ''; return str.replace(/([!"#$%&'()*+,.\/:;<=>?@[\\\]^`{|}~])/g, '\\$1'); }
        function showLoading() { if (loadingOverlay) { loadingOverlay.classList.add('visible'); loadingOverlay.setAttribute('aria-hidden', 'false'); } }
        function hideLoading() { if (loadingOverlay) { loadingOverlay.classList.remove('visible'); loadingOverlay.setAttribute('aria-hidden', 'true'); } }
        function readFileAsText(file) { return new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = () => resolve(reader.result); reader.onerror = () => reject(reader.error || new Error(`Failed to read file: ${file.name}`)); reader.readAsText(file, 'UTF-8'); }); }
        function readFileAsDataURL(file) { return new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = () => resolve(reader.result); reader.onerror = () => reject(reader.error || new Error(`Failed to read file as Data URL: ${file.name}`)); reader.readAsDataURL(file); }); }
        function generateUniqueId(prefix = 'item') { return `${prefix}_${nextUniqueId++}`; }
        function generateBaseFilename(filename) {
            if (!filename) return 'session_log';
            let base = filename.replace(/\.[^/.]+$/, "");
            // Remove common log type indicators from filename if present
            base = base.replace(/\[.*?\]/g, '').replace(/\(all\)/i, '').trim();
            base = base.replace(/[\\/:*?"<>|]/g, '_');
            return base || 'session_log';
        }
        function sanitizeForFilename(name) {
             if (!name) return '';
             return String(name).trim().replace(/[\\/:*?"<>|\s#\.\[\]\{\}%&+,;=]/g, '_').replace(/_+/g, '_');
        }
        function getImagePathForKey(key, fileObject) {
            if (!fileObject || !(fileObject instanceof Blob)) { console.warn(`getImagePathForKey: Invalid fileObject for key ${key}`); return null; }
            let outputFilename = null;
            const fileExtension = fileObject.name?.split('.').pop()?.toLowerCase() || 'png';

            if (key.startsWith('img_')) { const safeKeyBase = sanitizeForFilename(key); outputFilename = `${safeKeyBase}.${fileExtension}`; }
            else if (key.startsWith('icon_msg_')) { const msgIdPart = key.substring(9); const safeMsgIdPart = sanitizeForFilename(msgIdPart); outputFilename = `${safeMsgIdPart}_override.${fileExtension}`; } // icon_msg_ instead of icon_
            else if (key.startsWith('exp_')) { const parts = key.match(/^exp_(.+?)_(.+)$/); if (parts && parts.length === 3) { const safeSpeakerName = sanitizeForFilename(parts[1]); const safeExpName = sanitizeForFilename(parts[2]); outputFilename = `${safeSpeakerName}_${safeExpName}.${fileExtension}`; } }
            else { const safeSpeakerName = sanitizeForFilename(key); outputFilename = `${safeSpeakerName}_icon.${fileExtension}`; }
            return outputFilename ? `${PROJECT_IMAGES_FOLDER}${outputFilename}` : null;
        }
        function createFileFromBlob(blob, filename) { try { return new File([blob], filename, { type: blob.type || 'application/octet-stream', lastModified: Date.now() }); } catch (e) { console.warn("File constructor failed, creating simple Blob with name property.", e); try { blob.name = filename; blob.lastModifiedDate = new Date(); return blob; } catch (blobError){ console.error("Could not create File or add name to Blob.", blobError); return null; } } }


        // --- Core Logic Functions ---

        // ======[ ファイル処理開始/終了/ハンドラの分離 ]======
        function startFileProcessing(file, logTypeLabel) {
            if (isProcessingFile) { console.warn("Processing already in progress."); return false; }
            isProcessingFile = true;
            fileInfoSpan.textContent = `読込中 (${logTypeLabel}): ${escapeHtml(file.name)}...`;
            projectLoadInfoSpan.textContent = ''; // Clear project load info
            logFileNameBase = generateBaseFilename(file.name);
            exportHtmlTitleInput.value = logFileNameBase;
            exportZipFilenameInput.value = logFileNameBase;
            console.log(`[${new Date().toISOString()}] Starting ${logTypeLabel} file processing: ${file.name}`);
            showLoading();
            resetAppState();
            return true;
        }

        function endFileProcessing(file, success, errorMessage) {
            hideLoading();
            isProcessingFile = false;
            if (success) {
                fileInfoSpan.textContent = `読込完了: ${escapeHtml(file.name)} (${displayLogData.length}件)`;
                enableControls();
                console.log(`[${new Date().toISOString()}] File processing finished successfully.`);
            } else {
                console.error(`[${new Date().toISOString()}] Error during file processing:`, errorMessage);
                alert(`処理中にエラーが発生しました: ${errorMessage}`);
                fileInfoSpan.textContent = '処理エラーが発生しました';
                logDisplayDiv.innerHTML = '<p class="text-red-500 text-center font-semibold">ログの処理中にエラーが発生しました。</p>';
                disableControls();
                resetAppState();
            }
            // Clear the specific file input that triggered the load
            if (cocofoliaFileInput) cocofoliaFileInput.value = null;
            if (tekeyFileInput) tekeyFileInput.value = null;
        }

        async function handleCocofoliaFileSelect(event) {
            const file = event.target.files?.[0];
            if (!file) { fileInfoSpan.textContent = 'ファイルが選択されていません'; return; }
            if (!file.name.toLowerCase().endsWith('.html')) { alert('ココフォリアHTMLファイルを選択してください。'); fileInfoSpan.textContent = 'HTMLファイルを選択してください'; event.target.value = null; return; }

            if (!startFileProcessing(file, "ココフォリア")) { event.target.value = null; return; }

            let success = false; let errorMessage = '';
            try {
                const fileContent = await readFileAsText(file);
                if (!fileContent || fileContent.trim().length === 0) throw new Error("ファイルが空か、内容を読み取れませんでした。");
                console.log(`   [handleCocofoliaFileSelect] File read complete. Parsing HTML...`);
                await new Promise(resolve => setTimeout(resolve, 50)); // Short delay for UI update

                const parsedData = parseCocofoliaLogHtml(fileContent); // Parse into temporary array
                console.log(`   [handleCocofoliaFileSelect] Parsing complete. Found ${parsedData.length} items.`);
                initializeAfterParse(parsedData); // Initialize state from parsed data
                success = true;

            } catch (error) {
                errorMessage = error.message || '不明なエラー';
                success = false;
            } finally {
                endFileProcessing(file, success, errorMessage);
            }
        }

        async function handleTekeyFileSelect(event) {
            const file = event.target.files?.[0];
            if (!file) { fileInfoSpan.textContent = 'ファイルが選択されていません'; return; }
            if (!file.name.toLowerCase().endsWith('.html')) { alert('Tekey HTMLファイルを選択してください。'); fileInfoSpan.textContent = 'HTMLファイルを選択してください'; event.target.value = null; return; }

            if (!startFileProcessing(file, "Tekey")) { event.target.value = null; return; }

            let success = false; let errorMessage = '';
            try {
                const fileContent = await readFileAsText(file);
                if (!fileContent || fileContent.trim().length === 0) throw new Error("ファイルが空か、内容を読み取れませんでした。");
                console.log(`   [handleTekeyFileSelect] File read complete. Parsing HTML...`);
                await new Promise(resolve => setTimeout(resolve, 50)); // Short delay for UI update

                const parsedData = parseTekeyLogHtml(fileContent); // Parse into temporary array
                console.log(`   [handleTekeyFileSelect] Parsing complete. Found ${parsedData.length} items.`);
                initializeAfterParse(parsedData); // Initialize state from parsed data
                success = true;

            } catch (error) {
                errorMessage = error.message || '不明なエラー';
                success = false;
            } finally {
                endFileProcessing(file, success, errorMessage);
            }
        }

        async function handleProjectLoadFile(event) {
            // This remains mostly the same, but call endFileProcessing at the end
            if (isProcessingFile) { console.warn("Processing already in progress."); event.target.value = null; return; }
            const file = event.target.files?.[0];
            if (!file) { projectLoadInfoSpan.textContent = 'ファイルが選択されていません'; return; }
            if (!file.name.toLowerCase().endsWith(PROJECT_FILE_EXTENSION)) { alert(`プロジェクトファイル (${PROJECT_FILE_EXTENSION}) を選択してください。`); projectLoadInfoSpan.textContent = `プロジェクトファイルを選択してください`; event.target.value = null; return; }

            isProcessingFile = true;
            projectLoadInfoSpan.textContent = `プロジェクト読込中: ${escapeHtml(file.name)}...`;
            fileInfoSpan.textContent = ''; showLoading();
            resetAppState();

            let success = false; let errorMessage = '';
            try {
                await loadProject(file); // Call the project loading function
                projectLoadInfoSpan.textContent = `プロジェクト読込完了: ${escapeHtml(file.name)}`;
                 // Set title/filename inputs based on loaded project name
                 const baseName = file.name.replace(PROJECT_FILE_EXTENSION, '');
                 exportHtmlTitleInput.value = logFileNameBase || baseName; // Use logFileNameBase if available in project data
                 exportZipFilenameInput.value = logFileNameBase || baseName;
                 success = true;

            } catch (error) {
                 errorMessage = error.message || 'プロジェクト読み込みエラー';
                 success = false;
            } finally {
                 hideLoading(); // Hide loading inside endFileProcessing now
                 isProcessingFile = false; // Set inside endFileProcessing now
                 if (projectLoadInput) projectLoadInput.value = null;
                 // Use a slightly different message structure for project load
                 if (success) {
                     enableControls();
                     console.log(`[${new Date().toISOString()}] Project loaded successfully.`);
                 } else {
                     console.error(`[${new Date().toISOString()}] Error loading project:`, errorMessage);
                     alert(`プロジェクトの読み込み中にエラーが発生しました:\n${errorMessage}`);
                     projectLoadInfoSpan.textContent = 'プロジェクト読み込みエラー';
                     logDisplayDiv.innerHTML = '<p class="text-red-500 text-center font-semibold">プロジェクトの読み込みに失敗しました。</p>';
                     disableControls();
                     resetAppState();
                 }
            }
        }
        // ===================================================================

        // ======[ 解析後の共通初期化処理 ]======
        function initializeAfterParse(parsedData) {
             // Calculate frequencies and tabs from parsed data
             speakerFrequencies = {}; uniqueTabsFound = new Set();
             parsedData.forEach(item => {
                 if (item.type === 'message') {
                     if(item.speaker && item.speaker !== 'system' && item.speaker !== '不明') { speakerFrequencies[item.speaker] = (speakerFrequencies[item.speaker] || 0) + 1; }
                     if (item.tab) { uniqueTabsFound.add(item.tab); }
                 } else if (item.type === 'image') {
                     // For newly parsed data, images don't exist yet, so skip tab finding for them
                 }
             });
             if (uniqueTabsFound.size > 0 && !uniqueTabsFound.has('all')) uniqueTabsFound.add('all');
             else if (uniqueTabsFound.size === 0) uniqueTabsFound = new Set(['all']);

             // Initialize displayLogData (crucial step)
             displayLogData = parsedData.map(item => {
                 if (item.type === 'message') {
                     const initialDisplayMode = (item.speaker === 'system') ? 'narration' : 'bubble';
                     return { ...item, displayMode: initialDisplayMode, iconKey: 'default', overrideIconSrc: null };
                 }
                 // Add other types if needed, e.g., handling errors during parsing
                 else if (item.type === 'error') {
                     return { ...item, displayMode: 'narration', iconKey: 'default', overrideIconSrc: null };
                 }
                 return item; // Should only be 'message' or 'error' from parsing functions
             });
             console.log(`   [initializeAfterParse] Initialized displayLogData with ${displayLogData.length} items.`);

             initializeCharacterSettings(); // Based on calculated speakerFrequencies
             updateSpeakerDataForExport();
             populateCharacterSettingsUI();
             populateTabsUI(); // Based on calculated uniqueTabsFound
             populateSpeakerFilterUI(); // Based on calculated speakerFrequencies
             renderLog(); // Apply initial customization and render
         }
         // ===================================================

        function resetAppState() {
             displayLogData = []; characterSettings = {};
             currentTabFilter = 'all'; currentSpeakerFilter = 'all'; uploadedFiles = {};
             speakerFrequencies = {}; uniqueTabsFound = new Set(['all']);
             nextUniqueId = 0; imageInsertTargetIndex = -2; speakerDataForExport = {};
             messageIconChangeTargetId = null; expressionAddContext = { speaker: null, inputElement: null };
             logFileNameBase = 'session_log'; exportHtmlTitleInput.value = logFileNameBase; exportZipFilenameInput.value = logFileNameBase;
             projectLoadInfoSpan.textContent = ''; fileInfoSpan.textContent = 'ファイルが選択されていません';
             characterSettingsDiv.innerHTML = '<p class="text-gray-500 italic">ログファイルまたはプロジェクトファイルを読み込むと表示されます。</p>';
             logTabsNav.innerHTML = '<span class="whitespace-nowrap py-2 px-1 text-gray-500 text-sm italic">ログ読込中</span>';
             speakerFilterSelect.innerHTML = '<option value="all">すべての発言者</option>';
             logDisplayDiv.innerHTML = '<p class="text-gray-500 text-center italic">ここに整形されたログが表示されます。</p>';
             resetCustomizationDefaults(); updateCustomizationUI(); disableControls();
             if (iconChangeInput) iconChangeInput.value = null; if (insertImageInput) insertImageInput.value = null;
             // ======[ ファイル入力のクリア ]======
             if (cocofoliaFileInput) cocofoliaFileInput.value = null;
             if (tekeyFileInput) tekeyFileInput.value = null;
             if (projectLoadInput) projectLoadInput.value = null;
             // ============================================
             closeIconDropdown(); console.log("Application state reset.");
        }

        function enableControls() {
             exportButton.disabled = false; saveProjectButton.disabled = false; saveSettingsButton.disabled = false; loadSettingsButton.disabled = false;
             speakerFilterSelect.disabled = Object.keys(speakerFrequencies).length === 0;
             exportHtmlTitleInput.disabled = false; exportZipFilenameInput.disabled = false; addHeaderImageButton.disabled = false; console.log("Controls enabled.");
        }
        function disableControls() {
            exportButton.disabled = true; saveProjectButton.disabled = true; saveSettingsButton.disabled = true; loadSettingsButton.disabled = true;
            speakerFilterSelect.disabled = true; exportHtmlTitleInput.disabled = true; exportZipFilenameInput.disabled = true; addHeaderImageButton.disabled = true; console.log("Controls disabled.");
        }

        // ======[ ログ解析関数 ]======
        function parseCocofoliaLogHtml(htmlContent) {
            console.log("   [parseCocofoliaLogHtml] Starting HTML parsing...");
            const parser = new DOMParser(); const doc = parser.parseFromString(htmlContent, 'text/html');
            if (!doc || !doc.body) throw new Error("ココフォリアHTMLコンテンツの解析に失敗しました。");
            const paragraphs = doc.body.querySelectorAll('p');
            console.log(`   [parseCocofoliaLogHtml] Found ${paragraphs.length} potential message elements.`);
            const tempData = [];
            let currentUniqueId = 0;
            paragraphs.forEach((p, index) => {
                if (!p.textContent?.trim()) return;
                try {
                    const spans = p.querySelectorAll('span');
                    if (spans.length >= 3) {
                        const tabMatch = spans[0]?.textContent?.match(/\[(.*?)\]/);
                        const tab = tabMatch?.[1]?.trim() || 'main';
                        const speaker = spans[1]?.textContent?.trim().replace(/[:：]$/, '').trim() || '不明';
                        const message = spans[2]?.innerHTML?.trim() ?? ''; // Use innerHTML to keep formatting like <br>
                        const colorMatch = p.getAttribute('style')?.match(/color:\s*(#[0-9a-fA-F]{3,6}|rgba?\([^)]+\)|[a-zA-Z]+)/);
                        const color = colorMatch?.[1]?.trim() || '#000000';
                        tempData.push({
                            type: 'message', id: generateUniqueId('msg'), // Generate ID here
                            originalIndex: index, tab: tab, speaker: speaker, color: color, message: message
                        });
                        currentUniqueId++; // Increment counter for nextUniqueId usage elsewhere
                    } else console.warn(`   [parseCocofoliaLogHtml] Skipping paragraph at index ${index} due to unexpected span count (${spans.length}).`);
                } catch (parseError) {
                    console.error(`   [parseCocofoliaLogHtml] Error parsing paragraph at index ${index}:`, parseError, p.outerHTML);
                    tempData.push({ type: 'error', id: generateUniqueId('err'), originalIndex: index, message: `ログの解析エラー (行 ${index + 1})`, details: p.textContent?.substring(0, 100) || '内容不明' });
                    currentUniqueId++;
                }
            });
            nextUniqueId = currentUniqueId; // Set global counter after parsing
            console.log(`   [parseCocofoliaLogHtml] Parsing finished. Parsed ${tempData.length} items.`);
            return tempData;
        }

        function parseTekeyLogHtml(htmlContent) {
            console.log("   [parseTekeyLogHtml] Starting Tekey HTML parsing...");
            const parser = new DOMParser(); const doc = parser.parseFromString(htmlContent, 'text/html');
            const chatlogDiv = doc.querySelector('.chatlog');
            if (!chatlogDiv) throw new Error("Tekeyログの '.chatlog' 要素が見つかりませんでした。Tekey v2形式か確認してください。");

            // --- 追加: タブ名とIDのマッピングを作成 ---
            const tabNameMap = {};
            const tabLabels = doc.querySelectorAll('.tab-list label.tab-checkbox');
            console.log(`   [parseTekeyLogHtml] Found ${tabLabels.length} tab definitions.`);
            tabLabels.forEach(label => {
                const input = label.querySelector('input[id^="tab"]');
                if (input && input.id) {
                    // input要素を除いたテキスト部分を取得（これがタブ名）
                    // label.textContent だと input の中身まで取ってしまう可能性があるため、より安全な方法に修正
                    let tabName = '';
                    label.childNodes.forEach(node => {
                        if (node.nodeType === Node.TEXT_NODE) {
                            tabName += node.textContent;
                        }
                    });
                    tabName = tabName.trim();

                    if (tabName) {
                         tabNameMap[input.id] = tabName;
                         console.log(`       Mapping tab ID "${input.id}" to name "${tabName}"`);
                    } else {
                         // もしテキストノードがなければ、フォールバックとして要素全体のテキストを使う（inputタグは後で削除されるはず）
                         const fallbackName = label.textContent.trim();
                         if(fallbackName){
                            tabNameMap[input.id] = fallbackName;
                            console.warn(`       Could not extract precise tab name for ID "${input.id}". Using label content "${fallbackName}" as name.`);
                         } else {
                            console.warn(`       Could not extract tab name for ID "${input.id}". Using ID as name.`);
                            tabNameMap[input.id] = input.id; // フォールバックとしてIDを使用
                         }
                    }
                }
            });
            // デフォルトの 'tab1' がマップにない場合（<label> が存在しない場合など）のフォールバック
            if (!tabNameMap['tab1']) {
                 console.log("       No explicit definition for 'tab1' found, defaulting name to 'tab1'.");
                 tabNameMap['tab1'] = 'tab1';
            }
            console.log("   [parseTekeyLogHtml] Final Tab Name Map:", tabNameMap);
            // --- ここまで追加 ---

            const messageDivs = chatlogDiv.querySelectorAll(':scope > div'); // Direct children divs
            console.log(`   [parseTekeyLogHtml] Found ${messageDivs.length} potential message elements.`);
            const tempData = [];
            let currentUniqueId = 0;

            messageDivs.forEach((div, index) => {
                if (!div.textContent?.trim()) return;
                try {
                    // --- 修正: タブIDを特定し、マップからタブ名を取得 ---
                    let tabId = 'tab1'; // デフォルト
                    if (div.classList.contains('tab2')) tabId = 'tab2';
                    else if (div.classList.contains('tab3')) tabId = 'tab3';
                    // 将来的に tab4, tab5... に対応する場合はここに追加
                    // else if (div.classList.contains('tabN')) tabId = 'tabN';

                    // マップから実際のタブ名を取得。見つからなければIDをそのまま使う
                    const tab = tabNameMap[tabId] || tabId;
                    // --- ここまで修正 ---

                    const speakerElement = div.querySelector('b');
                    const speaker = speakerElement?.textContent?.trim().replace(/[:：]$/, '').trim() || '不明';

                    // Clone the div to manipulate it without affecting the original DOM structure during iteration
                    const messageContentContainer = div.cloneNode(true);
                    const bElementToRemove = messageContentContainer.querySelector('b');
                    const spanElementToRemove = messageContentContainer.querySelector('span'); // Tekey timestamp span
                    if (bElementToRemove) messageContentContainer.removeChild(bElementToRemove);
                    if (spanElementToRemove) messageContentContainer.removeChild(spanElementToRemove);
                    const message = messageContentContainer.innerHTML.trim();

                    const colorMatch = div.getAttribute('style')?.match(/color:\s*(#[0-9a-fA-F]{3,6}|rgba?\([^)]+\)|[a-zA-Z]+)/);
                    const color = colorMatch?.[1]?.trim() || '#000000'; // Default to black if no color style

                    const isDiceRoll = div.classList.contains('diceroll');

                    tempData.push({
                        type: 'message', id: generateUniqueId('msg'), // Generate ID here
                        originalIndex: index,
                        tab: tab, // 取得した実際のタブ名を設定
                        speaker: speaker, color: color, message: message,
                        isDiceRoll: isDiceRoll // Store dice roll info (optional)
                    });
                    currentUniqueId++; // Increment counter

                } catch (parseError) {
                    console.error(`   [parseTekeyLogHtml] Error parsing div at index ${index}:`, parseError, div.outerHTML);
                    tempData.push({ type: 'error', id: generateUniqueId('err'), originalIndex: index, message: `Tekeyログの解析エラー (行 ${index + 1})`, details: div.textContent?.substring(0, 100) || '内容不明' });
                    currentUniqueId++;
                }
            });
            nextUniqueId = currentUniqueId; // Set global counter after parsing
            console.log(`   [parseTekeyLogHtml] Parsing finished. Parsed ${tempData.length} items.`);
            return tempData;
        }
        // ===================================================

        function initializeCharacterSettings() {
            characterSettings = {};
            // speakerFrequencies should be calculated *before* calling this
            Object.keys(speakerFrequencies).forEach(speaker => {
                if (speaker !== 'system' && !characterSettings[speaker]) {
                    characterSettings[speaker] = { displayName: speaker, icon: null, expressions: {} };
                }
            });
            console.log("   [initializeCharacterSettings] Initialized settings for:", Object.keys(characterSettings));
        }
        function updateSpeakerDataForExport() { speakerDataForExport = {}; Object.entries(characterSettings).forEach(([original, setting]) => { if (original !== 'system') speakerDataForExport[original] = setting.displayName; }); }

        function populateCharacterSettingsUI() {
            characterSettingsDiv.innerHTML = '';
            const sortedSpeakers = Object.keys(characterSettings).filter(s => s !== 'system').sort((a, b) => (speakerFrequencies[b] || 0) - (speakerFrequencies[a] || 0));
            if (sortedSpeakers.length === 0) { characterSettingsDiv.innerHTML = '<p class="text-gray-500 italic">ログ内に認識可能な発言者がいませんでした。</p>'; return; }

            const fragment = document.createDocumentFragment();
            sortedSpeakers.forEach(speaker => {
                try {
                    const setting = characterSettings[speaker]; if (!setting) { console.warn(`Setting not found for ${speaker}.`); return; }
                    const count = speakerFrequencies[speaker] || 0;
                    const uniqueSpeakerIdSuffix = sanitizeForFilename(speaker);

                    const container = document.createElement('div'); container.className = 'p-3 border rounded-md bg-white shadow-sm';
                    const mainInfoDiv = document.createElement('div'); mainInfoDiv.className = 'flex items-center space-x-4';

                    const iconDiv = document.createElement('div'); iconDiv.className = 'flex-shrink-0';
                    const imgPreview = document.createElement('img'); imgPreview.id = `icon-preview-${uniqueSpeakerIdSuffix}`;
                    imgPreview.src = setting.icon || PLACEHOLDER_ICON_URL.replace('64x64', '40x40'); // Assumes setting.icon is DataURL
                    imgPreview.alt = `${setting.displayName} のデフォルトアイコン`; imgPreview.className = 'w-10 h-10 rounded-full object-cover border border-gray-300 character-icon-preview';
                    imgPreview.loading = 'lazy';
                    imgPreview.onerror = () => { if (imgPreview.src !== PLACEHOLDER_ICON_URL.replace('64x64', '40x40')) imgPreview.src = PLACEHOLDER_ICON_URL.replace('64x64', '40x40'); if (characterSettings[speaker]) characterSettings[speaker].icon = null; };
                    const iconInput = document.createElement('input'); iconInput.type = 'file'; iconInput.accept = 'image/*'; iconInput.id = `icon-input-${uniqueSpeakerIdSuffix}`; iconInput.className = 'visually-hidden'; iconInput.setAttribute('aria-labelledby', `icon-label-${uniqueSpeakerIdSuffix}`);
                    iconInput.addEventListener('change', (e) => handleDefaultIconUpload(e, speaker));
                    const iconLabel = document.createElement('label'); iconLabel.htmlFor = `icon-input-${uniqueSpeakerIdSuffix}`; iconLabel.id = `icon-label-${uniqueSpeakerIdSuffix}`; iconLabel.className = 'cursor-pointer'; iconLabel.setAttribute('title', `クリックして ${setting.displayName} のデフォルトアイコンを変更`); iconLabel.appendChild(imgPreview); iconDiv.appendChild(iconLabel); iconDiv.appendChild(iconInput);

                    const nameDiv = document.createElement('div'); nameDiv.className = 'flex-grow min-w-0';
                    const nameLabel = document.createElement('label'); nameLabel.htmlFor = `name-input-${uniqueSpeakerIdSuffix}`; nameLabel.className = 'block text-sm font-medium text-gray-700 mb-1'; nameLabel.innerHTML = `「${escapeHtml(speaker)}」 <span class="text-xs text-gray-500">(${count}回)</span> 表示名:`;
                    const nameInput = document.createElement('input'); nameInput.type = 'text'; nameInput.id = `name-input-${uniqueSpeakerIdSuffix}`; nameInput.value = setting.displayName; nameInput.className = 'block w-full rounded-md border-gray-300 shadow-sm p-1.5 focus:border-indigo-500 focus:ring-indigo-500 text-sm'; nameInput.setAttribute('aria-label', `${escapeHtml(speaker)} の表示名`);
                    nameInput.addEventListener('input', (e) => {
                        const newDisplayName = e.target.value;
                        if (characterSettings[speaker]) {
                            characterSettings[speaker].displayName = newDisplayName;
                            updateSpeakerFilterOptionText(speaker, newDisplayName);
                            updateSpeakerDataForExport();
                            renderLog();
                        }
                    });
                    nameDiv.appendChild(nameLabel); nameDiv.appendChild(nameInput);
                    mainInfoDiv.appendChild(iconDiv); mainInfoDiv.appendChild(nameDiv);
                    container.appendChild(mainInfoDiv);

                    const expressionSection = document.createElement('div');
                    expressionSection.className = 'expression-section'; expressionSection.id = `expressions-${uniqueSpeakerIdSuffix}`;
                    const expressionTitle = document.createElement('h4'); expressionTitle.textContent = '表情差分アイコン:'; expressionTitle.className = 'text-sm font-medium text-gray-600 mb-2'; expressionSection.appendChild(expressionTitle);
                    const expressionList = document.createElement('div'); expressionList.className = 'space-y-1 mb-3'; expressionSection.appendChild(expressionList);
                    populateExpressionList(expressionList, speaker); // Populate list dynamically

                    const addForm = document.createElement('div'); addForm.className = 'add-expression-form';
                    const expressionNameInput = document.createElement('input'); expressionNameInput.type = 'text'; expressionNameInput.placeholder = '差分名 (例: 笑顔)'; expressionNameInput.className = 'add-expression-name-input'; expressionNameInput.id = `exp-name-input-${uniqueSpeakerIdSuffix}`;
                    const expressionFileLabel = document.createElement('label'); const hiddenInputId = `exp-file-input-${uniqueSpeakerIdSuffix}`; expressionFileLabel.htmlFor = hiddenInputId; expressionFileLabel.textContent = '画像選択';
                    const expressionFileInput = document.createElement('input'); expressionFileInput.type = 'file'; expressionFileInput.accept = 'image/*'; expressionFileInput.className = 'visually-hidden'; expressionFileInput.id = hiddenInputId;
                    expressionFileInput.addEventListener('change', (e) => { expressionAddContext = { speaker: speaker, inputElement: e.target }; handleAddExpressionFile(); });
                    addForm.appendChild(expressionNameInput); addForm.appendChild(expressionFileLabel); addForm.appendChild(expressionFileInput);
                    expressionSection.appendChild(addForm);
                    container.appendChild(expressionSection);

                    fragment.appendChild(container);
                } catch (uiError) { console.error(`Error creating UI element for speaker "${speaker}":`, uiError); const errorDiv = document.createElement('div'); errorDiv.className = 'p-3 border rounded-md bg-red-50 text-red-700'; errorDiv.textContent = `「${escapeHtml(speaker)}」の設定表示中にエラーが発生しました。`; fragment.appendChild(errorDiv); }
            });
            characterSettingsDiv.appendChild(fragment);
        }

        function populateExpressionList(listElement, speaker) {
             listElement.innerHTML = '';
             const expressions = characterSettings[speaker]?.expressions || {};
             const sortedNames = Object.keys(expressions).sort();
             if (sortedNames.length === 0) { listElement.innerHTML = '<p class="text-xs text-gray-500 italic">差分アイコン未登録</p>'; return; }
             sortedNames.forEach(expName => {
                 const expDataUrl = expressions[expName]; // Assumes DataURL
                 const itemDiv = document.createElement('div'); itemDiv.className = 'expression-item';
                 const img = document.createElement('img'); img.src = expDataUrl || PLACEHOLDER_ICON_URL.replace('64x64', '32x32'); img.alt = expName; img.className = 'expression-preview'; img.loading = 'lazy'; img.onerror = () => { img.src = PLACEHOLDER_ICON_URL.replace('64x64', '32x32'); };
                 const nameSpan = document.createElement('span'); nameSpan.className = 'expression-name'; nameSpan.textContent = escapeHtml(expName);
                 const deleteBtn = document.createElement('button'); deleteBtn.textContent = '削除'; deleteBtn.className = 'expression-delete-btn'; deleteBtn.onclick = () => handleDeleteExpression(speaker, expName);
                 itemDiv.appendChild(img); itemDiv.appendChild(nameSpan); itemDiv.appendChild(deleteBtn);
                 listElement.appendChild(itemDiv);
             });
        }

        function updateSpeakerFilterOptionText(originalSpeaker, newDisplayName) { try { const escapedSpeaker = escapeCssSelector(originalSpeaker); const option = speakerFilterSelect.querySelector(`option[value="${escapedSpeaker}"]`); if (option) { const count = speakerFrequencies[originalSpeaker] || 0; const displayName = newDisplayName?.trim() || originalSpeaker; option.textContent = `${escapeHtml(displayName)} (${count}回)`; } } catch (e) { console.error(`Error updating speaker filter option for "${originalSpeaker}":`, e); } }

        async function handleDefaultIconUpload(event, speaker) {
            const file = event.target.files?.[0]; if (!file) return;
            if (!file.type.startsWith('image/')) { alert('画像ファイルを選択してください。'); event.target.value = null; return; }
            if (file.size > MAX_FILE_SIZE_BYTES) { alert(`ファイルサイズが大きすぎます (${(file.size / 1024 / 1024).toFixed(1)}MB)。${MAX_FILE_SIZE_MB}MB以下にしてください。`); event.target.value = null; return; }

            const uniqueSpeakerIdSuffix = sanitizeForFilename(speaker);
            const imgPreview = document.getElementById(`icon-preview-${uniqueSpeakerIdSuffix}`);

            try {
                const dataUrl = await readFileAsDataURL(file);
                if (imgPreview) imgPreview.src = dataUrl;
                if (!characterSettings[speaker]) { characterSettings[speaker] = { displayName: speaker, icon: null, expressions: {} }; }
                characterSettings[speaker].icon = dataUrl; // Store Data URL
                uploadedFiles[speaker] = file; // Store File object
                console.log(`Default icon updated for speaker ${speaker}. Re-rendering log.`);
                renderLog();
            } catch (error) { console.error(`Error processing default speaker icon upload for ${speaker}:`, error); alert(`アイコンの読み込みに失敗しました: ${error.message}`); if (imgPreview && characterSettings[speaker]?.icon) imgPreview.src = characterSettings[speaker].icon; else if (imgPreview) imgPreview.src = PLACEHOLDER_ICON_URL.replace('64x64', '40x40'); }
            finally { if (event.target) event.target.value = null; }
        }

        async function handleAddExpressionFile() {
             const { speaker, inputElement } = expressionAddContext;
             if (!speaker || !inputElement || !inputElement.files || inputElement.files.length === 0) { expressionAddContext = { speaker: null, inputElement: null }; return; }
             const file = inputElement.files[0];
             const uniqueSpeakerIdSuffix = sanitizeForFilename(speaker);
             const nameInput = document.getElementById(`exp-name-input-${uniqueSpeakerIdSuffix}`);
             const expressionName = nameInput ? nameInput.value.trim() : '';

             const currentSpeaker = speaker; // Keep reference
             if (inputElement) inputElement.value = null;
             expressionAddContext = { speaker: null, inputElement: null };

             if (!expressionName) { alert('差分名を入力してください。'); return; }
             if (characterSettings[currentSpeaker]?.expressions?.[expressionName]) { alert(`差分名「${expressionName}」は既に使用されています。`); return; }
             if (!file.type.startsWith('image/')) { alert('画像ファイルを選択してください。'); return; }
             if (file.size > MAX_FILE_SIZE_BYTES) { alert(`ファイルサイズが大きすぎます (${(file.size / 1024 / 1024).toFixed(1)}MB)。${MAX_FILE_SIZE_MB}MB以下にしてください。`); return; }

             showLoading();
             try {
                 const dataUrl = await readFileAsDataURL(file);
                 if (!characterSettings[currentSpeaker]) { characterSettings[currentSpeaker] = { displayName: currentSpeaker, icon: null, expressions: {} }; }
                 if (!characterSettings[currentSpeaker].expressions) { characterSettings[currentSpeaker].expressions = {}; }
                 characterSettings[currentSpeaker].expressions[expressionName] = dataUrl; // Store Data URL

                 const uploadKey = `exp_${currentSpeaker}_${expressionName}`;
                 uploadedFiles[uploadKey] = file; // Store File object

                 if (nameInput) nameInput.value = ''; // Reset name input
                 console.log(`Expression '${expressionName}' added for speaker ${currentSpeaker}.`);
                 const expressionListDiv = document.getElementById(`expressions-${uniqueSpeakerIdSuffix}`)?.querySelector('.space-y-1');
                 if (expressionListDiv) populateExpressionList(expressionListDiv, currentSpeaker);
             } catch (error) { console.error(`Error adding expression icon for ${currentSpeaker}:`, error); alert(`差分アイコンの読み込み/追加に失敗しました: ${error.message}`); }
             finally { hideLoading(); }
        }

        function handleDeleteExpression(speaker, expressionName) {
             if (!characterSettings[speaker]?.expressions?.[expressionName]) return;
             const confirmation = customizationSettings.skipDeleteConfirm || confirm(`「${speaker}」の差分アイコン「${expressionName}」を削除しますか？`);
             if (!confirmation) return;

             delete characterSettings[speaker].expressions[expressionName];
             const uploadKey = `exp_${speaker}_${expressionName}`;
             if (uploadedFiles[uploadKey]) { delete uploadedFiles[uploadKey]; console.log(`Removed file cache for expression ${uploadKey}.`); }

             const uniqueSpeakerIdSuffix = sanitizeForFilename(speaker);
             const expressionListDiv = document.getElementById(`expressions-${uniqueSpeakerIdSuffix}`)?.querySelector('.space-y-1');
             if (expressionListDiv) populateExpressionList(expressionListDiv, speaker);

             let updatedMessages = false;
             displayLogData.forEach(item => {
                 if (item.type === 'message' && item.speaker === speaker && item.iconKey === expressionName) { item.iconKey = 'default'; updatedMessages = true; }
             });
             if (updatedMessages) { console.log(`Reset messages using deleted expression '${expressionName}'. Re-rendering.`); renderLog(); }
             else { console.log(`Expression '${expressionName}' deleted for speaker ${speaker}.`); }
        }

        function saveCharacterSettings() {
            if (Object.keys(characterSettings).length === 0) { alert('保存する設定がありません。'); return; }
            try {
                 const settingsToSave = {};
                 for (const [speaker, setting] of Object.entries(characterSettings)) {
                     settingsToSave[speaker] = { displayName: setting.displayName, icon: setting.icon, expressions: setting.expressions };
                 }
                localStorage.setItem(LOCALSTORAGE_SETTINGS_KEY, JSON.stringify(settingsToSave));
                alert('キャラクター設定（表示名/アイコンDataURL）をLocalStorageに一時保存しました。');
            }
            catch (error) { console.error("Error saving character settings to LocalStorage:", error); alert(`LocalStorageへの設定保存中にエラー: ${error.message}`); }
        }
         function loadCharacterSettings() {
            if (Object.keys(characterSettings).length === 0) { alert('設定を適用するキャラクターがいません。'); return; }
            try {
                const savedSettingsJson = localStorage.getItem(LOCALSTORAGE_SETTINGS_KEY); if (!savedSettingsJson) { alert('LocalStorageに保存された設定が見つかりません。'); return; }
                const loadedSettings = JSON.parse(savedSettingsJson);
                let settingsAppliedCount = 0;
                 Object.keys(characterSettings).forEach(speaker => {
                    if (loadedSettings[speaker]) {
                        const oldIcon = characterSettings[speaker].icon; const oldExpressions = characterSettings[speaker].expressions;
                        characterSettings[speaker].displayName = loadedSettings[speaker].displayName; characterSettings[speaker].icon = loadedSettings[speaker].icon || null; characterSettings[speaker].expressions = loadedSettings[speaker].expressions || {};
                        if (characterSettings[speaker].icon !== oldIcon && uploadedFiles[speaker]) { delete uploadedFiles[speaker]; console.log(`Removed default icon file cache for ${speaker} due to LocalStorage load.`); }
                        const currentExpKeys = new Set(Object.keys(characterSettings[speaker].expressions));
                        if (oldExpressions) { for (const expName in oldExpressions) { if (!currentExpKeys.has(expName)) { const expKey = `exp_${speaker}_${expName}`; if (uploadedFiles[expKey]) { delete uploadedFiles[expKey]; console.log(`Removed expression file cache for ${expKey} due to LocalStorage load.`); } } } }
                        settingsAppliedCount++;
                    }
                });
                if (settingsAppliedCount > 0) { updateSpeakerDataForExport(); populateCharacterSettingsUI(); populateSpeakerFilterUI(); renderLog(); alert(`${settingsAppliedCount}件の設定をLocalStorageから読み込みました。(アイコン実ファイルは復元されません)`); }
                 else alert('LocalStorageに一致する保存設定がありませんでした。');
            } catch (error) { console.error("Error loading character settings from LocalStorage:", error); alert(`LocalStorageからの設定読み込み中にエラー: ${error.message}`); }
        }


        function populateTabsUI() {
            logTabsNav.innerHTML = '';
            const sortedTabs = ['all', ...[...uniqueTabsFound].filter(t=> t !== 'all').sort((a, b) => a.localeCompare(b))];
            if (sortedTabs.length <= 1) { logTabsNav.innerHTML = '<span class="whitespace-nowrap py-2 px-1 text-gray-500 text-sm italic">タブ情報なし</span>'; return; }
            const fragment = document.createDocumentFragment();
            sortedTabs.forEach(tab => {
                const button = document.createElement('button'); button.textContent = `[${escapeHtml(tab)}]`; button.dataset.tab = tab;
                const baseClasses = 'whitespace-nowrap py-2 px-3 border-b-2 font-medium text-sm focus:outline-none focus:ring-2 focus:ring-offset-1 focus:ring-indigo-500 transition-colors duration-150 ease-in-out';
                const activeClasses = 'border-indigo-500 text-indigo-600'; const inactiveClasses = 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300';
                const isActive = tab === currentTabFilter;
                button.className = `${baseClasses} ${isActive ? activeClasses : inactiveClasses}`;
                button.setAttribute('role', 'tab'); button.setAttribute('aria-selected', isActive ? 'true' : 'false');
                fragment.appendChild(button);
            });
            logTabsNav.appendChild(fragment); logTabsNav.setAttribute('role', 'tablist');
        }


        function populateSpeakerFilterUI() {
            speakerFilterSelect.innerHTML = '<option value="all">すべての発言者</option>';
            const sortedSpeakers = Object.keys(speakerFrequencies).filter(s => s !== 'system').sort((a, b) => (speakerFrequencies[b] || 0) - (speakerFrequencies[a] || 0));
            if (sortedSpeakers.length === 0) { speakerFilterSelect.disabled = true; return; }
            const fragment = document.createDocumentFragment();
            sortedSpeakers.forEach(speaker => { const option = document.createElement('option'); option.value = escapeCssSelector(speaker); const count = speakerFrequencies[speaker] || 0; const displayName = characterSettings[speaker]?.displayName || speaker; option.textContent = `${escapeHtml(displayName)} (${count}回)`; fragment.appendChild(option); });
            speakerFilterSelect.appendChild(fragment);
            try { speakerFilterSelect.value = currentSpeakerFilter === 'all' ? 'all' : escapeCssSelector(currentSpeakerFilter); } catch { speakerFilterSelect.value = 'all'; }
            speakerFilterSelect.disabled = false;
        }

        function handleTabChange(tabName) { if (currentTabFilter === tabName) return; console.log(`Switching main display tab to: [${tabName}]`); currentTabFilter = tabName; const baseClasses = 'whitespace-nowrap py-2 px-3 border-b-2 font-medium text-sm focus:outline-none focus:ring-2 focus:ring-offset-1 focus:ring-indigo-500 transition-colors duration-150 ease-in-out'; const activeClasses = 'border-indigo-500 text-indigo-600'; const inactiveClasses = 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'; logTabsNav.querySelectorAll('button').forEach(button => { const isActive = button.dataset.tab === tabName; button.className = `${baseClasses} ${isActive ? activeClasses : inactiveClasses}`; button.setAttribute('aria-selected', isActive ? 'true' : 'false'); }); renderLog(); }
        function handleSpeakerFilterChange() { const selectedValue = speakerFilterSelect.value; const newFilter = selectedValue === 'all' ? 'all' : Object.keys(speakerFrequencies).find(sp => escapeCssSelector(sp) === selectedValue) || 'all'; if (currentSpeakerFilter === newFilter) return; console.log(`Filtering main display by speaker: ${newFilter}`); currentSpeakerFilter = newFilter; renderLog(); }

        function renderLog() {
             console.log(`   [renderLog] Rendering main display. Tab: ${currentTabFilter}, Speaker: ${currentSpeakerFilter}, NameBelowIcon: ${customizationSettings.nameBelowIconMode}, Font: ${customizationSettings.fontFamily}`);
             const startTime = performance.now();
             logDisplayDiv.innerHTML = '';

             FONT_CLASSES.forEach(cls => logDisplayDiv.classList.remove(cls)); logDisplayDiv.classList.add(customizationSettings.fontFamily);
             logDisplayDiv.style.fontSize = `${customizationSettings.fontSize}px`; logDisplayDiv.style.height = `${customizationSettings.logDisplayHeight}px`; logDisplayDiv.style.backgroundColor = customizationSettings.backgroundColor; document.body.style.backgroundColor = customizationSettings.backgroundColor;
             logDisplayDiv.style.setProperty('--bubble-max-width', `${customizationSettings.bubbleMaxWidth}%`); logDisplayDiv.style.setProperty('--bubble-bg-color', customizationSettings.normalBubbleColor); logDisplayDiv.style.setProperty('--bubble-arrow-color', customizationSettings.normalBubbleColor); logDisplayDiv.style.setProperty('--icon-size', `${customizationSettings.iconSize}px`);
             logDisplayDiv.classList.toggle('name-below-icon-active', customizationSettings.nameBelowIconMode);

             let filteredItems = displayLogData.filter(item => {
                 if (item.type === 'image' && item.afterOriginalIndex === HEADER_IMAGE_INDEX) return true;
                 if (item.type === 'error') return currentTabFilter === 'all' && currentSpeakerFilter === 'all';
                 let itemTab = 'main', itemSpeaker = '不明';
                 if (item.type === 'message') { itemTab = item.tab || 'main'; itemSpeaker = item.speaker || '不明'; }
                  else if (item.type === 'image') { const precedingMessage = findPrecedingMessage(item.afterOriginalIndex); if (precedingMessage) { itemTab = precedingMessage.tab || 'main'; itemSpeaker = precedingMessage.speaker || '不明'; } else { return currentTabFilter === 'all' && currentSpeakerFilter === 'all'; } }
                  else { return false; }
                 const tabMatch = currentTabFilter === 'all' || itemTab === currentTabFilter;
                 const speakerMatch = currentSpeakerFilter === 'all' || itemSpeaker === currentSpeakerFilter;
                 return tabMatch && speakerMatch;
             });

             const dataToSort = filteredItems.map(item => ({ ...item, sortIndex: item.type === 'image' ? (item.afterOriginalIndex === HEADER_IMAGE_INDEX ? -Infinity : (item.originalIndex ?? item.afterOriginalIndex ?? -1) + 0.5) : (item.originalIndex ?? -1) })).sort((a, b) => a.sortIndex - b.sortIndex);
             console.log(`   [renderLog] Filtered/Sorted down to ${dataToSort.length} items to render.`);

             if (dataToSort.length === 0) { logDisplayDiv.innerHTML = '<p class="text-gray-500 text-center italic">表示するログがありません。(フィルタ条件を確認してください)</p>'; const endTime = performance.now(); console.log(`   [renderLog] Rendered empty log in ${endTime - startTime} ms.`); return; }

             const fragment = document.createDocumentFragment();
             dataToSort.forEach((item, index) => {
                 try {
                     const isMultiTabView = currentTabFilter === 'all';
                     if (isMultiTabView && item.type === 'message' && index > 0) {
                         let prevMessageItem = null;
                         for (let j = index - 1; j >= 0; j--) { if (dataToSort[j].type === 'message') { prevMessageItem = dataToSort[j]; break; } }
                         if (prevMessageItem && (item.tab || 'main') !== (prevMessageItem.tab || 'main')) {
                             const separator = document.createElement('hr'); separator.className = 'tab-separator'; fragment.appendChild(separator);
                         }
                     }
                     let element;
                     if (item.type === 'message') { element = createMessageElement(item); }
                     else if (item.type === 'image') { element = createInsertedImageElement(item); }
                     else if (item.type === 'error') { element = createErrorElement(item); }
                     if (element) fragment.appendChild(element);
                 } catch (elementError) { console.error(`   [renderLog] Error creating element for item (ID: ${item.id}, Index: ${index}):`, elementError, item); const errorDiv = document.createElement('div'); errorDiv.className = 'p-2 my-1 bg-red-100 border border-red-400 text-red-700 rounded text-sm'; errorDiv.textContent = `表示エラー: アイテム(${item.id})の表示中に問題が発生しました。`; fragment.appendChild(errorDiv); }
             });
             logDisplayDiv.appendChild(fragment);
             const endTime = performance.now(); console.log(`   [renderLog] Rendered ${dataToSort.length} items in ${endTime - startTime} ms.`);
        }

        function findPrecedingMessage(originalIndex) {
             if (typeof originalIndex !== 'number' || originalIndex < 0) return null;
             for (let i = displayLogData.length - 1; i >= 0; i--) { if (displayLogData[i].type === 'message' && displayLogData[i].originalIndex === originalIndex) return displayLogData[i]; }
             return null;
         }

        function createMessageElement(logItem) {
            if (!logItem || logItem.type !== 'message') return null;
            const container = document.createElement('div'); container.className = 'message-item'; container.dataset.itemId = logItem.id; container.dataset.tab = logItem.tab || 'main'; container.dataset.speaker = logItem.speaker || '不明';
            const currentDisplayMode = logItem.displayMode || 'bubble'; container.dataset.displayMode = currentDisplayMode;
            const setting = characterSettings[logItem.speaker] || { displayName: logItem.speaker, icon: null, expressions: {} };
            const placeholderSrc = PLACEHOLDER_ICON_URL.replace('64x64', `${customizationSettings.iconSize}x${customizationSettings.iconSize}`); // Use dynamic size for placeholder
            let currentIconSrc = placeholderSrc; const iconKey = logItem.iconKey || 'default';

            if (iconKey === 'override' && logItem.overrideIconSrc) { currentIconSrc = logItem.overrideIconSrc; }
            else if (iconKey !== 'default' && setting.expressions?.[iconKey]) { currentIconSrc = setting.expressions[iconKey]; }
            else if (setting.icon) { currentIconSrc = setting.icon; }

            const bubbleContainer = document.createElement('div'); bubbleContainer.className = 'message-container';
            const iconContainer = document.createElement('div'); iconContainer.className = 'icon-container';
            const iconImg = document.createElement('img'); iconImg.src = currentIconSrc; iconImg.alt = `${setting.displayName} icon (${iconKey})`; iconImg.className = 'w-full h-full rounded-full object-cover icon-border bg-gray-200 message-icon'; iconImg.style.borderColor = logItem.color || '#000000'; iconImg.loading = 'lazy'; iconImg.style.objectPosition = '50% 0%'; iconImg.title = 'クリックしてアイコンを変更';
            iconImg.onerror = (e) => { const target = e.target; const failedSrc = target.src; if (failedSrc === placeholderSrc) return; let intendedSrc = placeholderSrc; const currentKey = logItem.iconKey || 'default'; if (currentKey === 'override' && logItem.overrideIconSrc) intendedSrc = logItem.overrideIconSrc; else if (currentKey !== 'default' && setting.expressions?.[currentKey]) intendedSrc = setting.expressions[currentKey]; else if (setting.icon) intendedSrc = setting.icon; if (failedSrc === intendedSrc) { if (currentKey === 'override') target.src = setting.icon || placeholderSrc; else if (currentKey !== 'default') target.src = setting.icon || placeholderSrc; else target.src = placeholderSrc; } else { target.src = placeholderSrc; } };
            iconImg.addEventListener('click', (event) => { event.stopPropagation(); triggerIconSelectionDropdown(logItem.id, logItem.speaker, event.currentTarget); });
            iconContainer.appendChild(iconImg);
            const nameBelowIconSpan = document.createElement('span'); nameBelowIconSpan.className = 'speaker-name-below-icon'; nameBelowIconSpan.textContent = escapeHtml(setting.displayName); iconContainer.appendChild(nameBelowIconSpan);
            bubbleContainer.appendChild(iconContainer);

            const contentContainer = document.createElement('div'); contentContainer.className = 'content-container';
            const speakerNameSpan = document.createElement('span'); speakerNameSpan.className = 'speaker-name-default'; speakerNameSpan.innerHTML = `${escapeHtml(setting.displayName)} <span class="text-xs font-normal text-gray-500">[${escapeHtml(logItem.tab || 'main')}]</span>`;
            const tabBelowIconSpan = document.createElement('span'); tabBelowIconSpan.className = 'tab-name-below-icon'; tabBelowIconSpan.textContent = `[${escapeHtml(logItem.tab || 'main')}]`;
            const bubbleDiv = document.createElement('div'); bubbleDiv.className = 'bubble bubble-left bubble-normal'; bubbleDiv.innerHTML = logItem.message; bubbleDiv.contentEditable = "true"; bubbleDiv.dataset.itemId = logItem.id; bubbleDiv.addEventListener('blur', handleMessageEdit);
            contentContainer.appendChild(speakerNameSpan); contentContainer.appendChild(tabBelowIconSpan); contentContainer.appendChild(bubbleDiv);
            const actionButtonContainer = document.createElement('div'); actionButtonContainer.className = 'action-button-container';
            const insertButton = document.createElement('button'); insertButton.textContent = '画像挿入'; insertButton.className = 'action-button action-button-insert'; insertButton.onclick = () => triggerImageInsert(logItem.originalIndex); actionButtonContainer.appendChild(insertButton);
            const deleteButtonBubble = createDeleteButton(logItem.id, 'メッセージ'); actionButtonContainer.appendChild(deleteButtonBubble);
            contentContainer.appendChild(actionButtonContainer);
            bubbleContainer.appendChild(contentContainer);
            container.appendChild(bubbleContainer);

            const narrationContainer = document.createElement('div'); narrationContainer.className = 'narration-container';
            const narrationTab = document.createElement('span'); narrationTab.className = 'narration-tab'; narrationTab.textContent = `[${escapeHtml(logItem.tab || 'main')}]`;
            const narrationSpeaker = document.createElement('span'); narrationSpeaker.className = 'narration-speaker'; narrationSpeaker.textContent = `${escapeHtml(setting.displayName)}:`;
            const narrationMessage = document.createElement('span'); narrationMessage.className = 'narration-message'; narrationMessage.innerHTML = logItem.message; narrationMessage.contentEditable = "true"; narrationMessage.dataset.itemId = logItem.id; narrationMessage.addEventListener('blur', handleMessageEdit);
            narrationContainer.appendChild(narrationTab); narrationContainer.appendChild(narrationSpeaker); narrationContainer.appendChild(narrationMessage);
            const narrationActionButtonContainer = document.createElement('div'); narrationActionButtonContainer.style.display = 'inline-block'; narrationActionButtonContainer.style.marginLeft = '10px';
            const narrationDeleteButton = createDeleteButton(logItem.id, 'メッセージ'); narrationActionButtonContainer.appendChild(narrationDeleteButton);
            narrationContainer.appendChild(narrationActionButtonContainer);
            container.appendChild(narrationContainer);

            const toggleButton = document.createElement('button'); toggleButton.className = 'display-mode-toggle'; toggleButton.title = '表示モード切替 (フキダシ/描写)'; toggleButton.textContent = (currentDisplayMode === 'narration') ? '💬' : '📝'; toggleButton.onclick = () => toggleMessageDisplayMode(logItem.id);
            container.appendChild(toggleButton);
            return container;
        }

        function toggleMessageDisplayMode(itemId) {
            const itemIndex = displayLogData.findIndex(item => item.id === itemId && item.type === 'message'); if (itemIndex === -1) return;
            const currentMode = displayLogData[itemIndex].displayMode || 'bubble'; const newMode = (currentMode === 'bubble') ? 'narration' : 'bubble'; displayLogData[itemIndex].displayMode = newMode;
            const elementToUpdate = logDisplayDiv.querySelector(`.message-item[data-item-id="${itemId}"]`);
            if (elementToUpdate) { elementToUpdate.dataset.displayMode = newMode; const toggleButton = elementToUpdate.querySelector('.display-mode-toggle'); if (toggleButton) toggleButton.textContent = (newMode === 'narration') ? '💬' : '📝'; }
        }

        function createInsertedImageElement(imageItem) {
             if (!imageItem || imageItem.type !== 'image') return null;
             const container = document.createElement('div'); container.className = 'inserted-image-container my-2 image-item'; container.dataset.itemId = imageItem.id;
             const isHeaderImage = imageItem.afterOriginalIndex === HEADER_IMAGE_INDEX; const precedingMessage = isHeaderImage ? null : findPrecedingMessage(imageItem.afterOriginalIndex);
             container.dataset.tab = isHeaderImage ? 'header' : (precedingMessage?.tab || 'main'); container.dataset.speaker = isHeaderImage ? 'header' : (precedingMessage?.speaker || '不明');
             const img = document.createElement('img'); img.src = imageItem.src || ''; img.alt = imageItem.caption ? escapeHtml(imageItem.caption) : `挿入画像 (ID: ${imageItem.id})`; img.className = 'inserted-image'; img.loading = 'lazy';
             img.onerror = (e) => { console.error(`Failed to load inserted image: ${e.target.src}`); container.innerHTML = `<p class="text-red-500 text-xs text-center font-semibold">[画像(ID: ${escapeHtml(imageItem.id)})の読み込みに失敗しました]</p>`; const deleteBtn = createDeleteButton(imageItem.id, '画像'); container.appendChild(deleteBtn); };
             container.appendChild(img);
             if (imageItem.caption) { const captionP = document.createElement('p'); captionP.className = 'image-caption'; captionP.textContent = imageItem.caption; container.appendChild(captionP); }
             const actionButtonContainer = document.createElement('div'); actionButtonContainer.className = 'action-button-container justify-center';
             const editCaptionButton = document.createElement('button'); editCaptionButton.textContent = '説明編集'; editCaptionButton.className = 'action-button action-button-edit'; editCaptionButton.onclick = () => editImageCaption(imageItem.id); actionButtonContainer.appendChild(editCaptionButton);
             const deleteButton = createDeleteButton(imageItem.id, '画像'); actionButtonContainer.appendChild(deleteButton); container.appendChild(actionButtonContainer);
             return container;
         }

        function createErrorElement(errorItem) {
            if (!errorItem || errorItem.type !== 'error') return null;
            const errorDiv = document.createElement('div'); errorDiv.className = 'p-2 my-1 bg-yellow-100 border border-yellow-400 text-yellow-800 rounded text-sm error-item'; errorDiv.dataset.itemId = errorItem.id; errorDiv.dataset.tab = 'all'; errorDiv.dataset.speaker = 'all';
            errorDiv.innerHTML = `<strong>解析エラー:</strong> ${escapeHtml(errorItem.message)}<br><small class="text-gray-600">内容: ${escapeHtml(errorItem.details)}...</small>`;
            const deleteButton = createDeleteButton(errorItem.id, 'エラー表示'); const buttonContainer = document.createElement('div'); buttonContainer.className = 'mt-1'; buttonContainer.appendChild(deleteButton); errorDiv.appendChild(buttonContainer);
            return errorDiv;
        }

        function createDeleteButton(itemId, itemTypeLabel = 'アイテム') {
            const deleteButton = document.createElement('button'); deleteButton.textContent = '削除'; deleteButton.className = 'action-button action-button-delete'; deleteButton.onclick = () => deleteSingleItem(itemId); deleteButton.setAttribute('aria-label', `${itemTypeLabel} (ID: ${itemId}) を削除`);
            return deleteButton;
        }

        function triggerImageInsert(afterIndex) { console.log(`Triggering image insert for index: ${afterIndex}`); if (typeof afterIndex !== 'number' || afterIndex < HEADER_IMAGE_INDEX) return; imageInsertTargetIndex = afterIndex; insertImageInput.click(); }

        async function handleInsertImageFile(event) {
            const file = event.target.files?.[0]; const targetIndex = imageInsertTargetIndex; imageInsertTargetIndex = -2;
            if (event.target) event.target.value = null; if (!file) return; if (targetIndex < HEADER_IMAGE_INDEX) return;
            if (!file.type.startsWith('image/')) { alert('画像ファイルのみ挿入できます。'); return; } if (file.size > MAX_INSERT_IMAGE_SIZE_BYTES) { alert(`ファイルサイズ超過 (${(file.size / 1024 / 1024).toFixed(1)}MB)。${MAX_INSERT_IMAGE_SIZE_MB}MB以下にしてください。`); return; }
            const caption = ""; showLoading();
            try {
                const dataUrl = await readFileAsDataURL(file); const imageId = generateUniqueId('img');
                const newImageEntry = { type: 'image', id: imageId, src: dataUrl, afterOriginalIndex: targetIndex, caption: caption };
                if (targetIndex === HEADER_IMAGE_INDEX) { displayLogData.splice(0, 0, newImageEntry); }
                 else { let insertPos = -1; for (let i = displayLogData.length - 1; i >= 0; i--) { const item = displayLogData[i]; if ((item.type === 'message' && item.originalIndex === targetIndex) || (item.type === 'image' && item.afterOriginalIndex === targetIndex)) { insertPos = i + 1; break; } if ((item.type === 'message' || item.type === 'error') && (item.originalIndex ?? -1) < targetIndex) { if (item.type === 'image' && item.afterOriginalIndex < targetIndex) {} else { insertPos = i + 1; break; } } if (item.type === 'image' && item.afterOriginalIndex < targetIndex) { insertPos = i + 1; } } if (insertPos === -1) { const nextIndex = displayLogData.findIndex(item => (item.originalIndex ?? item.afterOriginalIndex ?? -Infinity) > targetIndex); insertPos = (nextIndex === -1) ? displayLogData.length : nextIndex; } displayLogData.splice(insertPos, 0, newImageEntry); }
                uploadedFiles[imageId] = file; renderLog();
            } catch (error) { console.error("Error inserting image:", error); alert(`画像の挿入中にエラー: ${error.message}`); } finally { hideLoading(); }
        }

        function editImageCaption(itemId) {
            const imageItemIndex = displayLogData.findIndex(item => item.id === itemId && item.type === 'image'); if (imageItemIndex === -1) { alert("キャプション編集対象の画像が見つかりません。"); return; }
            const currentCaption = displayLogData[imageItemIndex].caption || ""; const newCaption = prompt("画像の説明文（キャプション）を編集してください:", currentCaption); if (newCaption !== null) { displayLogData[imageItemIndex].caption = newCaption.trim(); renderLog(); }
        }

        function deleteSingleItem(itemId) {
            if (!itemId) return; const indexToDelete = displayLogData.findIndex(item => item.id === itemId); if (indexToDelete === -1) { alert('削除対象が見つかりません。'); return; }
            const itemToDelete = displayLogData[indexToDelete]; const itemTypeLabel = itemToDelete.type === 'message' ? 'メッセージ' : itemToDelete.type === 'image' ? '画像' : 'エラー表示';
            const proceedToDelete = customizationSettings.skipDeleteConfirm || confirm(`ID: ${itemId} の${itemTypeLabel}を削除しますか？ (元に戻せません)`); if (!proceedToDelete) return;
            displayLogData.splice(indexToDelete, 1);
            let fileKeyToRemove = null;
            if (itemToDelete.type === 'image') { fileKeyToRemove = itemId; }
            else if (itemToDelete.type === 'message' && itemToDelete.iconKey === 'override') { fileKeyToRemove = `icon_${itemId}`; } // ここは icon_itemId ではなく icon_msg_itemId だったはず？確認必要 -> getImagePathForKey と合わせる
             // getImagePathForKey では icon_msg_*** にしているので、ここも合わせる
             else if (itemToDelete.type === 'message' && itemToDelete.iconKey === 'override') { fileKeyToRemove = `icon_msg_${itemId}`; }

            if (fileKeyToRemove && uploadedFiles[fileKeyToRemove]) { delete uploadedFiles[fileKeyToRemove]; console.log(`Removed file cache for ${fileKeyToRemove}.`); }
            const elementToRemove = logDisplayDiv.querySelector(`[data-item-id="${itemId}"]`); if (elementToRemove) { elementToRemove.remove(); } else { renderLog(); }
        }

        function handleMessageEdit(event) {
            const editedElement = event.target; const itemId = editedElement.dataset.itemId; const newContent = editedElement.innerHTML; if (!itemId) return;
            const itemIndex = displayLogData.findIndex(item => item.id === itemId && item.type === 'message'); if (itemIndex === -1) return;
            if (displayLogData[itemIndex].message !== newContent) { displayLogData[itemIndex].message = newContent; console.log(`Message ${itemId} content updated.`); }
        }

        // --- Icon Selection Dropdown Logic ---
        function triggerIconSelectionDropdown(messageId, speaker, clickedIconElement) {
            closeIconDropdown(); const dropdown = iconSelectDropdown; dropdown.innerHTML = ''; messageIconChangeTargetId = messageId;
            const setting = characterSettings[speaker] || { expressions: {}, icon: null }; const fragment = document.createDocumentFragment();
            const defaultBtn = createDropdownButton('default', 'デフォルトアイコン', speaker, 'default'); if (setting.icon) defaultBtn.insertBefore(createDropdownIconPreview(setting.icon), defaultBtn.firstChild); fragment.appendChild(defaultBtn);
            const expressions = setting.expressions || {}; const sortedExpNames = Object.keys(expressions).sort();
            if (sortedExpNames.length > 0) { const separator = document.createElement('div'); separator.className = 'icon-select-separator'; fragment.appendChild(separator); sortedExpNames.forEach(expName => { const btn = createDropdownButton(expName, escapeHtml(expName), speaker, 'expression'); if (expressions[expName]) btn.insertBefore(createDropdownIconPreview(expressions[expName]), btn.firstChild); fragment.appendChild(btn); }); }
            const separator2 = document.createElement('div'); separator2.className = 'icon-select-separator'; fragment.appendChild(separator2);
            const overrideBtn = createDropdownButton('override', 'ファイルから個別設定...', speaker, 'override'); fragment.appendChild(overrideBtn);
            dropdown.appendChild(fragment); const rect = clickedIconElement.getBoundingClientRect();
            dropdown.style.top = `${window.scrollY + rect.bottom + 5}px`; dropdown.style.left = `${window.scrollX + rect.left}px`;
            dropdown.classList.remove('hidden'); currentDropdown = dropdown; document.addEventListener('click', handleClickOutsideDropdown, true);
        }
        function createDropdownButton(key, text, speaker, type) { const button = document.createElement('button'); button.textContent = text; button.dataset.key = key; button.dataset.speaker = speaker; button.dataset.type = type; button.onclick = handleMessageIconSelection; return button; }
        function createDropdownIconPreview(src) { const img = document.createElement('img'); img.src = src; img.alt = ''; img.onerror = (e) => { e.target.style.display = 'none'; }; return img; }
        function handleMessageIconSelection(event) {
            const button = event.currentTarget; const key = button.dataset.key; const type = button.dataset.type; const messageId = messageIconChangeTargetId; closeIconDropdown(); if (!messageId) return;
            const itemIndex = displayLogData.findIndex(item => item.id === messageId && item.type === 'message'); if (itemIndex === -1) return;
            if (type === 'override') { messageIconChangeTargetId = messageId; iconChangeInput.onchange = handleOverrideIconUpload; iconChangeInput.click(); }
            else {
                 displayLogData[itemIndex].iconKey = key;
                 // overrideIconSrc をクリアし、関連ファイルを削除
                 if (displayLogData[itemIndex].overrideIconSrc) {
                     displayLogData[itemIndex].overrideIconSrc = null;
                     const overrideFileKey = `icon_msg_${messageId}`; // deleteSingleItem と合わせる
                     if (uploadedFiles[overrideFileKey]) {
                         delete uploadedFiles[overrideFileKey];
                         console.log(`Removed override file cache for ${overrideFileKey} because icon was changed to default/expression.`);
                     }
                 }
                 messageIconChangeTargetId = null;
                 renderLog();
             }
        }
        async function handleOverrideIconUpload(event) {
            const file = event.target.files?.[0]; const targetMessageId = messageIconChangeTargetId; iconChangeInput.onchange = null; if (event.target) event.target.value = null; if (!file || !targetMessageId) { messageIconChangeTargetId = null; return; }
            if (!file.type.startsWith('image/')) { alert('画像ファイルを選択してください。'); messageIconChangeTargetId = null; return; } if (file.size > MAX_FILE_SIZE_BYTES) { alert(`ファイルサイズが大きすぎます (${(file.size / 1024 / 1024).toFixed(1)}MB)。${MAX_FILE_SIZE_MB}MB以下にしてください。`); messageIconChangeTargetId = null; return; }
            showLoading();
            try {
                const dataUrl = await readFileAsDataURL(file); const messageIndex = displayLogData.findIndex(item => item.id === targetMessageId && item.type === 'message'); if (messageIndex === -1) throw new Error(`Message item ${targetMessageId} not found.`);
                displayLogData[messageIndex].iconKey = 'override'; displayLogData[messageIndex].overrideIconSrc = dataUrl;
                const uploadKey = `icon_msg_${targetMessageId}`; // deleteSingleItem, getImagePathForKey と合わせる
                uploadedFiles[uploadKey] = file;
                console.log(`Override icon for ${targetMessageId} updated. Re-rendering log.`); renderLog();
            } catch (error) { console.error(`Error processing override icon upload for ${targetMessageId}:`, error); alert(`個別アイコンの読み込みに失敗しました: ${error.message}`); const messageIndex = displayLogData.findIndex(item => item.id === targetMessageId); if(messageIndex !== -1 && displayLogData[messageIndex].type === 'message' && displayLogData[messageIndex].iconKey === 'override') { displayLogData[messageIndex].iconKey = 'default'; displayLogData[messageIndex].overrideIconSrc = null; renderLog(); } }
            finally { hideLoading(); messageIconChangeTargetId = null; }
        }
        function closeIconDropdown() { if (currentDropdown) { currentDropdown.classList.add('hidden'); currentDropdown.innerHTML = ''; currentDropdown = null; document.removeEventListener('click', handleClickOutsideDropdown, true); } }
        function handleClickOutsideDropdown(event) { if (currentDropdown && !currentDropdown.contains(event.target)) { const clickedOnIcon = event.target.closest('.message-icon'); if (!clickedOnIcon) closeIconDropdown(); } }

        // --- Customization Functions ---
        function applyCustomization() {
            try {
                customizationSettings.normalBubbleColor = normalColorInput.value; customizationSettings.fontSize = parseInt(fontSizeSlider.value, 10) || 16; customizationSettings.backgroundColor = backgroundColorInput.value; customizationSettings.iconSize = parseInt(iconSizeSlider.value, 10) || 64; customizationSettings.bubbleMaxWidth = parseInt(bubbleWidthSlider.value, 10) || 80; customizationSettings.nameBelowIconMode = nameBelowIconToggle.checked; customizationSettings.fontFamily = fontFamilySelect.value; customizationSettings.logDisplayHeight = parseInt(logHeightSlider.value, 10) || 384; customizationSettings.skipDeleteConfirm = skipDeleteConfirmToggle.checked;
                saveCustomization(); renderLog();
            } catch (error) { console.error("Error applying customization:", error); alert(`カスタマイズ適用エラー: ${error.message}`); }
        }
        function resetCustomizationDefaults() { customizationSettings = { normalBubbleColor: '#ffffff', fontSize: 16, backgroundColor: '#f3f4f6', iconSize: 64, bubbleMaxWidth: 80, nameBelowIconMode: false, fontFamily: 'font-noto-sans', logDisplayHeight: 384, skipDeleteConfirm: false }; }
        function resetCustomization() { resetCustomizationDefaults(); updateCustomizationUI(); applyCustomization(); alert('表示カスタマイズをリセットしました。'); }
        function updateCustomizationUI() {
            try {
                normalColorInput.value = customizationSettings.normalBubbleColor; fontSizeSlider.value = customizationSettings.fontSize; fontSizeValueSpan.textContent = customizationSettings.fontSize; backgroundColorInput.value = customizationSettings.backgroundColor; iconSizeSlider.value = customizationSettings.iconSize; iconSizeValueSpan.textContent = customizationSettings.iconSize; bubbleWidthSlider.value = customizationSettings.bubbleMaxWidth; bubbleWidthValueSpan.textContent = customizationSettings.bubbleMaxWidth; nameBelowIconToggle.checked = customizationSettings.nameBelowIconMode; fontFamilySelect.value = customizationSettings.fontFamily; logHeightSlider.value = customizationSettings.logDisplayHeight; logHeightValueSpan.textContent = customizationSettings.logDisplayHeight; skipDeleteConfirmToggle.checked = customizationSettings.skipDeleteConfirm;
             } catch (error) { console.error("Error updating customization UI:", error); }
         }
         function saveCustomization() { try { localStorage.setItem(LOCALSTORAGE_CUSTOMIZATION_KEY, JSON.stringify(customizationSettings)); } catch (error) { console.error("Error saving customization settings to LocalStorage:", error); } }
         function loadCustomization() {
            let loaded = null; try { const savedJson = localStorage.getItem(LOCALSTORAGE_CUSTOMIZATION_KEY); if (savedJson) loaded = JSON.parse(savedJson); } catch (error) { console.error("Error loading customization settings from LocalStorage:", error); localStorage.removeItem(LOCALSTORAGE_CUSTOMIZATION_KEY); }
            if (loaded) { customizationSettings.normalBubbleColor = loaded.normalBubbleColor || '#ffffff'; customizationSettings.fontSize = parseInt(loaded.fontSize, 10) || 16; customizationSettings.backgroundColor = loaded.backgroundColor || '#f3f4f6'; customizationSettings.iconSize = parseInt(loaded.iconSize, 10) || 64; customizationSettings.bubbleMaxWidth = parseInt(loaded.bubbleMaxWidth, 10) || 80; customizationSettings.nameBelowIconMode = loaded.nameBelowIconMode === true; customizationSettings.fontFamily = loaded.fontFamily || 'font-noto-sans'; customizationSettings.logDisplayHeight = parseInt(loaded.logDisplayHeight, 10) || 384; customizationSettings.skipDeleteConfirm = loaded.skipDeleteConfirm === true; }
            else { resetCustomizationDefaults(); }
        }

        // --- Project Save/Load ---
        async function saveProject() {
            if (displayLogData.length === 0) { alert('保存するログデータがありません。'); return; } if (typeof JSZip === 'undefined') { alert('ZIP作成ライブラリ(JSZip)の読み込みに失敗しました...'); return; }
            const projectName = exportHtmlTitleInput.value.trim() || logFileNameBase || 'log_project'; const zipFilenameBase = exportZipFilenameInput.value.trim() || logFileNameBase || 'log_project'; const projectFilename = `${zipFilenameBase}${PROJECT_FILE_EXTENSION}`;
            console.log(`[${new Date().toISOString()}] Starting project save: ${projectFilename}`); showLoading();
            try {
                const zip = new JSZip(); const imgFolder = zip.folder(PROJECT_IMAGES_FOLDER.replace('/', '')); if (!imgFolder) throw new Error("Failed to create 'images' folder in ZIP.");
                const projectData = { fileFormatVersion: PROJECT_FILE_FORMAT_VERSION, toolVersion: APP_VERSION, createdAt: new Date().toISOString(), logFileNameBase: logFileNameBase, characterSettings: {}, customizationSettings: customizationSettings, displayLogData: [], uploadedFileManifest: {}, nextUniqueId: nextUniqueId, currentFilters: { tab: currentTabFilter, speaker: currentSpeakerFilter } };
                const imagePathMap = new Map(); const addedFiles = new Set();
                for (const [key, fileObject] of Object.entries(uploadedFiles)) {
                     if (!(fileObject instanceof Blob)) { console.warn(`Skipping non-Blob entry in uploadedFiles: ${key}`); continue; }
                    const imagePath = getImagePathForKey(key, fileObject);
                    if (imagePath && !addedFiles.has(imagePath)) { try { imgFolder.file(imagePath.substring(PROJECT_IMAGES_FOLDER.length), fileObject); addedFiles.add(imagePath); imagePathMap.set(key, imagePath); let manifestEntry = { type: 'unknown' }; if (key.startsWith('img_')) manifestEntry = { type: 'insertedImage', imageId: key }; else if (key.startsWith('icon_msg_')) manifestEntry = { type: 'overrideIcon', messageId: key.substring(9) }; else if (key.startsWith('exp_')) { const parts = key.match(/^exp_(.+?)_(.+)$/); if(parts) manifestEntry = { type: 'expressionIcon', speaker: parts[1], expressionName: parts[2] }; } else manifestEntry = { type: 'defaultIcon', speaker: key }; projectData.uploadedFileManifest[imagePath] = manifestEntry; } catch (zipError) { console.error(`Error adding image (key: ${key}, path: ${imagePath}) to zip:`, zipError); } }
                     else if (imagePath && addedFiles.has(imagePath)) { imagePathMap.set(key, imagePath); } else { console.warn(`Could not generate image path for key: ${key}`); }
                }
                console.log(`   [Project Save] Added ${addedFiles.size} unique images to ZIP.`);
                for (const [speaker, setting] of Object.entries(characterSettings)) { const newSetting = { displayName: setting.displayName, iconPath: imagePathMap.get(speaker) || null, expressions: {} }; if (setting.expressions) { for (const [expName, _] of Object.entries(setting.expressions)) { const expKey = `exp_${speaker}_${expName}`; newSetting.expressions[expName] = imagePathMap.get(expKey) || null; } } projectData.characterSettings[speaker] = newSetting; }
                projectData.displayLogData = displayLogData.map(item => { if (item.type === 'message') { const newItem = { ...item }; delete newItem.overrideIconSrc; const overrideKey = `icon_msg_${item.id}`; newItem.overrideIconPath = (item.iconKey === 'override') ? (imagePathMap.get(overrideKey) || null) : null; return newItem; } else if (item.type === 'image') { const newItem = { ...item }; delete newItem.src; newItem.srcPath = imagePathMap.get(item.id) || null; return newItem; } else if (item.type === 'error') { return { ...item }; } return null; }).filter(item => item !== null);
                zip.file(PROJECT_DATA_FILENAME, JSON.stringify(projectData, null, 2));
                console.log("   [Project Save] Generating ZIP blob...");
                const zipBlob = await zip.generateAsync({ type: "blob", compression: "DEFLATE", compressionOptions: { level: 6 } }); console.log(`   [Project Save] ZIP blob generated (Size: ${(zipBlob.size / 1024).toFixed(1)} KB).`);
                const downloadUrl = URL.createObjectURL(zipBlob); const link = document.createElement('a'); link.href = downloadUrl; link.download = projectFilename; document.body.appendChild(link); link.click(); document.body.removeChild(link); setTimeout(() => URL.revokeObjectURL(downloadUrl), 2000);
                console.log(`[${new Date().toISOString()}] Project saved successfully: ${projectFilename}`); alert(`プロジェクトを保存しました。\nファイル名: ${link.download}`);
            } catch (error) { console.error(`[${new Date().toISOString()}] Error saving project:`, error); alert(`プロジェクトの保存中にエラーが発生しました:\n${error.message}`); } finally { hideLoading(); }
        }
        async function loadProject(projectFile) {
            if (typeof JSZip === 'undefined') { throw new Error('ZIPライブラリ(JSZip)が見つかりません。'); } console.log(`[${new Date().toISOString()}] Starting project load: ${projectFile.name}`);
            const zip = await JSZip.loadAsync(projectFile); const projectDataFile = zip.file(PROJECT_DATA_FILENAME); if (!projectDataFile) { throw new Error(`${PROJECT_DATA_FILENAME} が見つかりません。`); }
            const projectDataJson = await projectDataFile.async('string'); let projectData; try { projectData = JSON.parse(projectDataJson); } catch (e) { throw new Error(`${PROJECT_DATA_FILENAME} の解析エラー: ${e.message}`); }
            // Version Check (Allow compatible versions)
            const projectVersion = projectData.fileFormatVersion;
            if (!projectVersion) { console.warn("Project file is missing version info. Trying load anyway."); }
            else if (projectVersion !== PROJECT_FILE_FORMAT_VERSION) { console.warn(`Project file version mismatch. Expected ${PROJECT_FILE_FORMAT_VERSION}, got ${projectVersion}. Trying load.`); }

            logFileNameBase = projectData.logFileNameBase || 'loaded_project'; customizationSettings = projectData.customizationSettings || {}; customizationSettings = { ...{ normalBubbleColor: '#ffffff', fontSize: 16, backgroundColor: '#f3f4f6', iconSize: 64, bubbleMaxWidth: 80, nameBelowIconMode: false, fontFamily: 'font-noto-sans', logDisplayHeight: 384, skipDeleteConfirm: false }, ...customizationSettings}; nextUniqueId = projectData.nextUniqueId || 0; const filters = projectData.currentFilters || { tab: 'all', speaker: 'all' }; currentTabFilter = filters.tab; currentSpeakerFilter = filters.speaker;
            const imageFolder = zip.folder(PROJECT_IMAGES_FOLDER.replace('/', '')); const imageDataUrlMap = new Map(); const newUploadedFiles = {};
            if (imageFolder) {
                const imagePromises = [];
                imageFolder.forEach((relativePath, zipEntry) => {
                    if (zipEntry.dir) return; const fullPath = `${PROJECT_IMAGES_FOLDER}${relativePath}`;
                    const promise = zipEntry.async('blob').then(blob => { const filename = relativePath; const imageFile = createFileFromBlob(blob, filename); if (!imageFile) { throw new Error(`Failed to create File object for ${filename}`); } return readFileAsDataURL(imageFile).then(dataUrl => { imageDataUrlMap.set(fullPath, dataUrl); const manifestEntry = projectData.uploadedFileManifest?.[fullPath]; if (manifestEntry) { let key = null; if (manifestEntry.type === 'defaultIcon') key = manifestEntry.speaker; else if (manifestEntry.type === 'expressionIcon') key = `exp_${manifestEntry.speaker}_${manifestEntry.expressionName}`; else if (manifestEntry.type === 'overrideIcon') key = `icon_msg_${manifestEntry.messageId}`; else if (manifestEntry.type === 'insertedImage') key = manifestEntry.imageId; if (key) newUploadedFiles[key] = imageFile; else console.warn(`Could not determine key for image: ${fullPath}`); } else console.warn(`Manifest entry missing for: ${fullPath}`); }); }).catch(err => { console.error(`Error reading image ${relativePath}:`, err); imageDataUrlMap.set(fullPath, null); });
                    imagePromises.push(promise);
                });
                await Promise.all(imagePromises); uploadedFiles = newUploadedFiles; console.log(`   [Project Load] Loaded ${imageDataUrlMap.size} images, reconstructed ${Object.keys(uploadedFiles).length} uploadedFiles.`);
            } else { console.warn("Images folder not found."); }
            characterSettings = {};
            if (projectData.characterSettings) { for (const [speaker, loadedSetting] of Object.entries(projectData.characterSettings)) { const newSetting = { displayName: loadedSetting.displayName, icon: loadedSetting.iconPath ? (imageDataUrlMap.get(loadedSetting.iconPath) || null) : null, expressions: {} }; if (loadedSetting.expressions) { for (const [expName, expPath] of Object.entries(loadedSetting.expressions)) { newSetting.expressions[expName] = expPath ? (imageDataUrlMap.get(expPath) || null) : null; } } characterSettings[speaker] = newSetting; } }
            displayLogData = [];
            if (projectData.displayLogData) { displayLogData = projectData.displayLogData.map(item => { if (item.type === 'message') { const newItem = { ...item }; if (item.iconKey === 'override' && item.overrideIconPath) { newItem.overrideIconSrc = imageDataUrlMap.get(item.overrideIconPath) || null; } delete newItem.overrideIconPath; return newItem; } else if (item.type === 'image' && item.srcPath) { const newItem = { ...item }; newItem.src = imageDataUrlMap.get(item.srcPath) || null; delete newItem.srcPath; return newItem; } else if (item.type === 'error') { return { ...item }; } return null; }).filter(item => item !== null); }
             // Recalculate frequencies and tabs from loaded displayLogData
             speakerFrequencies = {}; uniqueTabsFound = new Set();
             displayLogData.forEach(item => {
                 if (item.type === 'message') { if(item.speaker && item.speaker !== 'system' && item.speaker !== '不明') { speakerFrequencies[item.speaker] = (speakerFrequencies[item.speaker] || 0) + 1; } if (item.tab) { uniqueTabsFound.add(item.tab); } }
                  else if (item.type === 'image') { const isHeaderImage = item.afterOriginalIndex === HEADER_IMAGE_INDEX; if (!isHeaderImage) { const precedingMessage = findPrecedingMessage(item.afterOriginalIndex); if (precedingMessage?.tab) uniqueTabsFound.add(precedingMessage.tab); } }
             });
             if(uniqueTabsFound.size > 0 && !uniqueTabsFound.has('all')) uniqueTabsFound.add('all'); else if (uniqueTabsFound.size === 0) uniqueTabsFound = new Set(['all']);
            updateSpeakerDataForExport(); populateCharacterSettingsUI(); updateCustomizationUI(); populateTabsUI(); populateSpeakerFilterUI(); renderLog();
            console.log(`[${new Date().toISOString()}] Project loaded successfully.`);
        }

        // --- Export Functions (ZIP for viewing) ---
        async function handleExportZip() {
             const htmlTitle = exportHtmlTitleInput.value.trim() || logFileNameBase || 'session_log_export';
             const zipFilenameBase = exportZipFilenameInput.value.trim() || logFileNameBase || 'session_log_export';
             const zipFilename = `${zipFilenameBase}.zip`;
             const itemsToExport = displayLogData.map(item => { if (item.type === 'message') return { type: item.type, id: item.id, originalIndex: item.originalIndex, tab: item.tab, speaker: item.speaker, color: item.color, message: item.message, displayMode: item.displayMode || 'bubble', iconKey: item.iconKey || 'default' }; if (item.type === 'image') return { type: item.type, id: item.id, afterOriginalIndex: item.afterOriginalIndex, caption: item.caption }; if (item.type === 'error') return { type: item.type, id: item.id, originalIndex: item.originalIndex, message: item.message, details: item.details }; return null; }).filter(item => item !== null);
             const sortedExportData = itemsToExport.map(item => ({ ...item, sortIndex: item.type === 'image' ? (item.afterOriginalIndex === HEADER_IMAGE_INDEX ? -Infinity : (item.originalIndex ?? item.afterOriginalIndex ?? -1) + 0.5) : (item.originalIndex ?? -1) })).sort((a, b) => a.sortIndex - b.sortIndex);
             if (sortedExportData.length === 0) { alert('エクスポートするデータがありません。'); return; } if (typeof JSZip === 'undefined') { alert('ZIP作成ライブラリ(JSZip)の読み込みに失敗しました...'); return; }
             console.log(`[${new Date().toISOString()}] Starting ZIP export...`); showLoading();
             try {
                 const zip = new JSZip(); const outputCss = generateOutputCss(customizationSettings); zip.file("style.css", outputCss); const filterScriptContent = generateEmbeddedJsForExport(speakerDataForExport); const outputHtml = generateOutputHtml(sortedExportData, uniqueTabsFound, speakerDataForExport, htmlTitle, customizationSettings, filterScriptContent); zip.file("log_export.html", outputHtml);
                 console.log("   [ZIP Export] Adding images..."); const imgFolder = zip.folder("images"); if (!imgFolder) throw new Error("Failed to create 'images' folder."); let imageCount = 0; const addedFiles = new Set();
                 for (const [key, fileObject] of Object.entries(uploadedFiles)) {
                     if (!(fileObject instanceof Blob)) continue; const imagePath = getImagePathForKey(key, fileObject);
                     if (imagePath && !addedFiles.has(imagePath)) { try { imgFolder.file(imagePath.substring(PROJECT_IMAGES_FOLDER.length), fileObject); addedFiles.add(imagePath); imageCount++; } catch (zipAddError) { console.error(`Error adding file ${imagePath} to ZIP:`, zipAddError); } }
                      else if (imagePath && addedFiles.has(imagePath)) { /* Skip duplicate */ } else { console.warn(`Could not determine output filename for key: ${key}`); }
                 }
                 console.log(`   [ZIP Export] Added ${imageCount} images.`); console.log("   [ZIP Export] Generating ZIP blob...");
                 const zipBlob = await zip.generateAsync({ type: "blob", compression: "DEFLATE", compressionOptions: { level: 6 } }); console.log(`   [ZIP Export] ZIP blob generated (Size: ${(zipBlob.size / 1024).toFixed(1)} KB).`);
                 const downloadUrl = URL.createObjectURL(zipBlob); const link = document.createElement('a'); link.href = downloadUrl; link.download = zipFilename; document.body.appendChild(link); link.click(); document.body.removeChild(link); setTimeout(() => URL.revokeObjectURL(downloadUrl), 2000);
                 console.log(`[${new Date().toISOString()}] ZIP export complete.`); alert(`エクスポート完了: ${link.download}`);
             } catch (error) { console.error(`[${new Date().toISOString()}] Error during ZIP export:`, error); alert(`ZIPエクスポートエラー: ${error.message}`); } finally { hideLoading(); }
        }
        function generateOutputHtml(dataForExport, uniqueTabs, speakerData, htmlTitle, currentCustomization, embeddedJsContent) {
            console.log("   [generateOutputHtml] Generating HTML for export...");
            const { iconSize, nameBelowIconMode, fontFamily } = currentCustomization; let logBodyContent = '';
            dataForExport.forEach((item, index) => {
                try {
                     if (item.type === 'message' && index > 0) { let prevVisibleItem = null; for (let j = index - 1; j >= 0; j--) { const prevItem = dataForExport[j]; if (prevItem.type !== 'image' || prevItem.afterOriginalIndex !== HEADER_IMAGE_INDEX) { prevVisibleItem = prevItem; break; } } if (prevVisibleItem && prevVisibleItem.type === 'message' && (item.tab || 'main') !== (prevVisibleItem.tab || 'main')) { logBodyContent += '<hr class="tab-separator export">\n'; } }
                    if (item.type === 'message') {
                        const setting = characterSettings[item.speaker] || { displayName: item.speaker, icon: null, expressions: {} }; const speakerName = setting.displayName; const originalSpeaker = item.speaker; const iconKey = item.iconKey || 'default'; const messageId = item.id; let iconRelativePath = ''; let hasIconFile = false; let iconFileKey = null;
                        if (iconKey === 'override') { iconFileKey = `icon_msg_${messageId}`; } else if (iconKey !== 'default') { iconFileKey = `exp_${originalSpeaker}_${iconKey}`; } else { iconFileKey = originalSpeaker; }
                        if (iconFileKey && uploadedFiles[iconFileKey] instanceof Blob) { const file = uploadedFiles[iconFileKey]; iconRelativePath = getImagePathForKey(iconFileKey, file); hasIconFile = !!iconRelativePath; }
                        // Fallback to DataURL if file is missing (e.g., loaded from local storage)
                        if (!hasIconFile) {
                             const messageData = displayLogData.find(d => d.id === messageId);
                             if (iconKey === 'override' && messageData?.overrideIconSrc) iconRelativePath = messageData.overrideIconSrc;
                             else if (iconKey !== 'default' && setting.expressions?.[iconKey]) iconRelativePath = setting.expressions[iconKey];
                             else if (setting.icon) iconRelativePath = setting.icon;
                             else iconRelativePath = ''; // No icon found
                         }
                        const iconBorderColor = item.color || '#000000'; const messageHtmlContent = item.message; const escapedSpeakerName = escapeHtml(speakerName); const placeholderDisplay = !iconRelativePath ? 'inline-block' : 'none'; const imageDisplay = iconRelativePath ? 'block' : 'none'; const iconContainerStyle = `width: ${iconSize}px; height: ${iconSize}px;`; const placeholderChar = escapedSpeakerName.charAt(0) || '?'; const placeholderLineHeight = Math.round(iconSize * 0.9); const placeholderFontSize = Math.round(iconSize * 0.5); const tabDisplay = escapeHtml(item.tab || 'main'); const displayMode = item.displayMode || 'bubble';
                        logBodyContent += `
<div class="message-item export log-item" data-tab="${escapeHtml(item.tab || 'main')}" data-speaker="${escapeHtml(originalSpeaker)}" data-display-mode="${displayMode}">
    <div class="message-container export">
        <div class="icon-container export" style="${iconContainerStyle}">
            <img src="${iconRelativePath}" alt="${escapedSpeakerName} (${iconKey})" class="icon export" style="border-color: ${iconBorderColor}; display: ${imageDisplay};" onerror="this.style.display='none'; this.nextElementSibling.style.display='inline-block';">
            <span class="icon-placeholder export" style="display: ${placeholderDisplay}; border-color: ${iconBorderColor}; line-height: ${placeholderLineHeight}px; font-size: ${placeholderFontSize}px;">${placeholderChar}</span>
            <span class="speaker-name-below-icon export">${escapedSpeakerName}</span>
        </div>
        <div class="content-container export">
            <span class="speaker-name-default export">${escapedSpeakerName} <span class="original-tab export">[${tabDisplay}]</span></span>
            <span class="tab-name-below-icon export">[${tabDisplay}]</span>
            <div class="bubble export bubble-left export bubble-normal export">${messageHtmlContent}</div>
        </div>
    </div>
    <div class="narration-container export">
        <span class="narration-tab">[${tabDisplay}]</span>
        <span class="narration-speaker">${escapedSpeakerName}:</span>
        <span class="narration-message">${messageHtmlContent}</span>
    </div>
</div>\n`;
                    } else if (item.type === 'image') {
                         let imageRelativePath = ''; const imageId = item.id; const isHeader = item.afterOriginalIndex === HEADER_IMAGE_INDEX; const dataTab = isHeader ? 'header' : (findPrecedingMessage(item.afterOriginalIndex)?.tab || 'main'); const dataSpeaker = isHeader ? 'header' : (findPrecedingMessage(item.afterOriginalIndex)?.speaker || '不明');
                         if (uploadedFiles[imageId] instanceof Blob) { const file = uploadedFiles[imageId]; imageRelativePath = getImagePathForKey(imageId, file); } else { const imgData = displayLogData.find(d => d.id === imageId); imageRelativePath = imgData?.src || ''; }
                         const imageAlt = item.caption ? escapeHtml(item.caption) : `挿入画像 ${imageId}`;
                         logBodyContent += `
<div class="inserted-image-container export log-item" data-tab="${escapeHtml(dataTab)}" data-speaker="${escapeHtml(dataSpeaker)}">
    <img src="${imageRelativePath}" alt="${imageAlt}" class="inserted-image export" ${imageRelativePath ? '' : 'style="display:none;"'} onerror="this.style.display='none'; const p=document.createElement('p'); p.className='image-error-placeholder export'; p.textContent='[画像 ${escapeHtml(imageId)} 読込失敗]'; this.parentNode.appendChild(p);">
    ${!imageRelativePath ? `<p class="image-error-placeholder export">[画像 ${escapeHtml(imageId)} ファイル不明]</p>` : ''}`;
                         if (item.caption) { logBodyContent += `\n    <p class="image-caption export">${escapeHtml(item.caption)}</p>`; } logBodyContent += `\n</div>\n`;
                    } else if (item.type === 'error') { logBodyContent += `\n<div class="error-message export log-item" data-tab="all" data-speaker="all"><strong>解析エラー:</strong> ${escapeHtml(item.message)}<br><small>詳細: ${escapeHtml(item.details)}...</small></div>\n`; }
                } catch (htmlGenError) { console.error(`Error generating HTML for item ID ${item.id}:`, htmlGenError); logBodyContent += `<div class="export-error">アイテム(ID: ${item.id})のHTML生成エラー</div>\n`; }
            });
            let filterControlsHtml = `
<div class="filter-controls export">
    <div class="filter-section"> <label for="export-tab-filter">タブ:</label> <nav id="export-log-tabs" class="tab-nav export" aria-label="Log Tabs"><span class="placeholder">読み込み中...</span></nav> </div>
    <div class="filter-section"> <label for="export-speaker-filter">発言者:</label> <select id="export-speaker-filter" class="speaker-filter export"><option value="all">すべての発言者</option></select> </div>
</div>`;
            const safeHtmlTitle = escapeHtml(htmlTitle); const nameBelowIconBodyClass = nameBelowIconMode ? 'name-below-icon-active' : ''; const fontBodyClass = fontFamily || 'font-noto-sans';
            return `<!DOCTYPE html>
<html lang="ja"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>${safeHtmlTitle}</title><link rel="stylesheet" href="style.css"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Noto+Sans+JP:wght@400;700&family=Noto+Serif+JP:wght@400;700&family=M+PLUS+Rounded+1c:wght@400;700&display=swap" rel="stylesheet"></head>
<body class="${nameBelowIconBodyClass} ${fontBodyClass}"><div class="log-export-container"><h1>${safeHtmlTitle}</h1>${filterControlsHtml}<div id="export-log-display" class="log-display export">${logBodyContent || '<p class="empty-log-message export">ログデータがありません。</p>'}</div></div><script>${embeddedJsContent}<\/script></body></html>`;
        }
        function generateEmbeddedJsForExport(speakerDisplayNameMap) {
             const speakerMapString = JSON.stringify(speakerDisplayNameMap || {});
             return `
 (function() { "use strict"; console.log("Exported Log Filter Script Initializing..."); let currentExportTab = 'all'; let currentExportSpeaker = 'all'; const speakerDisplayNames = ${speakerMapString}; const exportLogTabsNav = document.getElementById('export-log-tabs'); const exportSpeakerFilter = document.getElementById('export-speaker-filter'); const exportLogDisplay = document.getElementById('export-log-display'); const allLogItems = exportLogDisplay ? Array.from(exportLogDisplay.querySelectorAll('.log-item')) : []; if (!exportLogTabsNav || !exportSpeakerFilter || !exportLogDisplay || allLogItems.length === 0) { console.error("Required elements for filtering not found or no log items."); return; }
 function initializeExportFilters() { console.log('Found ' + allLogItems.length + ' log items.'); const uniqueTabs = new Set(['all']); const uniqueSpeakers = new Set(['all']); const speakerCounts = {}; allLogItems.forEach(item => { const tab = item.dataset.tab; const speaker = item.dataset.speaker; if (tab && tab !== 'all' && tab !== 'header') uniqueTabs.add(tab); if (speaker && speaker !== 'all' && speaker !== '不明' && speaker !== 'header') { uniqueSpeakers.add(speaker); speakerCounts[speaker] = (speakerCounts[speaker] || 0) + 1; } }); console.log("Export Unique Tabs:", uniqueTabs); console.log("Export Unique Speakers:", uniqueSpeakers); populateExportTabs(uniqueTabs); populateExportSpeakerFilter(uniqueSpeakers, speakerCounts); exportSpeakerFilter.addEventListener('change', handleExportSpeakerChange); applyExportFilters(); }
 function populateExportTabs(tabsSet) { exportLogTabsNav.innerHTML = ''; const sortedTabs = [...tabsSet].sort((a, b) => a === 'all' ? -1 : b === 'all' ? 1 : a.localeCompare(b)); const fragment = document.createDocumentFragment(); sortedTabs.forEach(tab => { const button = document.createElement('button'); button.textContent = '[' + tab + ']'; button.dataset.tab = tab; button.className = 'tab-button export'; if (tab === currentExportTab) button.classList.add('active'); button.addEventListener('click', () => handleExportTabChange(tab)); fragment.appendChild(button); }); exportLogTabsNav.appendChild(fragment); }
 function populateExportSpeakerFilter(speakersSet, counts) { const sortedSpeakers = [...speakersSet].sort((a, b) => { if (a === 'all') return -1; if (b === 'all') return 1; const countDiff = (counts[b] || 0) - (counts[a] || 0); return countDiff !== 0 ? countDiff : a.localeCompare(b); }); const fragment = document.createDocumentFragment(); if (!sortedSpeakers.includes('all')) sortedSpeakers.unshift('all'); sortedSpeakers.forEach(speaker => { const option = document.createElement('option'); option.value = speaker; if (speaker === 'all') { option.textContent = 'すべての発言者'; } else { const displayName = speakerDisplayNames[speaker] || speaker; const count = counts[speaker] || 0; option.textContent = displayName + ' (' + count + '回)'; } fragment.appendChild(option); }); exportSpeakerFilter.innerHTML = ''; exportSpeakerFilter.appendChild(fragment); exportSpeakerFilter.value = currentExportSpeaker; exportSpeakerFilter.disabled = sortedSpeakers.length <= 1; }
 function handleExportTabChange(tabName) { if (currentExportTab === tabName) return; console.log('Export Filter - Tab changed to: ' + tabName); currentExportTab = tabName; exportLogTabsNav.querySelectorAll('.tab-button').forEach(btn => { btn.classList.toggle('active', btn.dataset.tab === tabName); }); applyExportFilters(); }
 function handleExportSpeakerChange() { const newSpeaker = exportSpeakerFilter.value; if (currentExportSpeaker === newSpeaker) return; console.log('Export Filter - Speaker changed to: ' + newSpeaker); currentExportSpeaker = newSpeaker; applyExportFilters(); }
 function applyExportFilters() { console.log('Applying export filters - Tab: ' + currentExportTab + ', Speaker: ' + currentExportSpeaker); let visibleCount = 0; allLogItems.forEach(item => { const itemTab = item.dataset.tab; const itemSpeaker = item.dataset.speaker; let isVisible = false; if (itemTab === 'header' || item.classList.contains('error-message')) { isVisible = true; } else { const tabMatch = currentExportTab === 'all' || itemTab === currentExportTab; const speakerMatch = currentExportSpeaker === 'all' || itemSpeaker === currentExportSpeaker; isVisible = tabMatch && speakerMatch; } if (isVisible) { item.classList.remove('hidden-log-item'); visibleCount++; } else { item.classList.add('hidden-log-item'); } }); console.log('Applied filters. ' + visibleCount + ' items visible.'); updateExportTabSeparators(); }
 function updateExportTabSeparators() { const separators = exportLogDisplay.querySelectorAll('.tab-separator.export'); separators.forEach(hr => hr.style.display = 'none'); if (currentExportTab === 'all') { let lastVisibleTab = null; let firstVisibleItemFound = false; const potentialSeparators = Array.from(exportLogDisplay.children); potentialSeparators.forEach((element) => { const isLogItem = element.classList.contains('log-item'); const isVisible = isLogItem && !element.classList.contains('hidden-log-item'); const isHeader = element.dataset.tab === 'header'; if (isVisible && !isHeader) { const currentItemTab = element.dataset.tab; if (firstVisibleItemFound && lastVisibleTab !== null && currentItemTab !== lastVisibleTab && currentItemTab !== 'all') { let previousElement = element.previousElementSibling; while (previousElement) { if (previousElement.classList.contains('tab-separator')) { previousElement.style.display = 'block'; break; } if ((previousElement.classList.contains('log-item') && !previousElement.classList.contains('hidden-log-item') && previousElement.dataset.tab !== 'header') || !previousElement.previousElementSibling) break; previousElement = previousElement.previousElementSibling; } } if (currentItemTab !== 'all' && currentItemTab !== 'header') lastVisibleTab = currentItemTab; firstVisibleItemFound = true; } }); } }
 if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', initializeExportFilters); } else { initializeExportFilters(); } })();`;
         }
        function generateOutputCss(currentCustomization) {
            console.log("   [generateOutputCss] Generating CSS for export...");
             const { iconSize, bubbleMaxWidth, normalBubbleColor, backgroundColor, fontSize, nameBelowIconMode, fontFamily } = currentCustomization; const placeholderLineHeight = Math.round(iconSize * 0.9); const placeholderFontSize = Math.round(iconSize * 0.5); const responsiveIconSize = Math.max(24, Math.round(iconSize * 0.75)); const responsivePlaceholderLineHeight = Math.round(responsiveIconSize * 0.9); const responsivePlaceholderFontSize = Math.round(responsiveIconSize * 0.5); const fontFamilies = { 'font-inter': "'Inter', sans-serif", 'font-noto-sans': "'Noto Sans JP', sans-serif", 'font-noto-serif': "'Noto Serif JP', serif", 'font-mplus-rounded': "'M PLUS Rounded 1c', sans-serif", 'font-system-sans': "sans-serif", 'font-system-serif': "serif", 'font-system-mono': "monospace" }; const selectedFontFamily = fontFamilies[fontFamily] || fontFamilies['font-noto-sans'];
             return `
 :root { --bubble-max-width: ${bubbleMaxWidth}%; --bubble-bg-color: ${normalBubbleColor}; --bubble-arrow-color: ${normalBubbleColor}; --icon-size: ${iconSize}px; }
 body { font-family: ${selectedFontFamily}; margin: 0; padding: 15px; background-color: ${backgroundColor}; font-size: ${fontSize}px; line-height: 1.7; color: #333; }
 .log-export-container { max-width: 900px; margin: 20px auto; background-color: ${logDisplayDiv.style.backgroundColor || '#ffffff'}; padding: 20px 25px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); }
 h1 { font-size: 1.7em; color: #111; border-bottom: 2px solid #eee; padding-bottom: 10px; margin: 0 0 25px 0; text-align: center; }
 .filter-controls.export { background-color: #f8f9fa; padding: 10px 15px; border-radius: 6px; margin-bottom: 20px; border: 1px solid #dee2e6; display: flex; flex-wrap: wrap; gap: 15px; align-items: center; }
 .filter-section { display: flex; align-items: center; gap: 8px; } .filter-section label { font-weight: bold; font-size: 0.9em; color: #495057; }
 .tab-nav.export { display: flex; flex-wrap: wrap; gap: 5px; padding-bottom: 5px; }
 .tab-button.export { background-color: #e9ecef; border: 1px solid #ced4da; color: #495057; padding: 4px 10px; border-radius: 4px; cursor: pointer; font-size: 0.85em; transition: background-color 0.2s, color 0.2s; white-space: nowrap; } .tab-button.export:hover { background-color: #dee2e6; } .tab-button.export.active { background-color: #0d6efd; border-color: #0d6efd; color: white; font-weight: bold; }
 .speaker-filter.export { padding: 5px 8px; border: 1px solid #ced4da; border-radius: 4px; font-size: 0.9em; background-color: white; min-width: 150px; }
 .tab-nav.export .placeholder { font-size: 0.85em; color: #6c757d; }
 .log-display.export { margin-top: 10px; } .hidden-log-item { display: none !important; } .log-item { margin-bottom: 16px; }
 .message-item.export { position: relative; } .message-container.export { display: flex; align-items: flex-start; } .narration-container.export { padding: 2px 4px; line-height: inherit; color: #333; }
 .message-item.export[data-display-mode="narration"] .message-container.export { display: none; } .message-item.export[data-display-mode="bubble"] .narration-container.export { display: none; }
 .icon-container.export { flex-shrink: 0; margin-right: 12px; width: var(--icon-size); height: var(--icon-size); position: relative; border-radius: 50%; }
 .icon.export { display: block; width: 100%; height: 100%; border-radius: 50%; object-fit: cover; object-position: 50% 0%; border: 3px solid; box-sizing: border-box; background-color: #f0f0f0; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2); }
 .icon-placeholder.export { display: none; width: 100%; height: 100%; border-radius: 50%; border: 3px solid; box-sizing: border-box; background-color: #e0e0e0; color: #757575; font-weight: bold; text-align: center; overflow: hidden; text-transform: uppercase; line-height: ${placeholderLineHeight}px; font-size: ${placeholderFontSize}px; }
 .content-container.export { flex-grow: 1; min-width: 0; }
 .speaker-name-default.export { display: block; font-weight: bold; margin-bottom: 4px; color: #1a1a1a; font-size: 0.9em; } .original-tab.export { font-weight: normal; font-size: 0.88em; color: #555; margin-left: 6px; }
 .tab-name-below-icon.export { display: none; font-size: 0.8em; color: #666; margin-bottom: 2px; }
 .speaker-name-below-icon.export { display: none; font-size: 0.85em; font-weight: bold; color: #333; text-shadow: -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff, 1px 1px 0 #fff, -1.5px -1.5px 0 #fff, 1.5px -1.5px 0 #fff, -1.5px 1.5px 0 #fff, 1.5px 1.5px 0 #fff; position: absolute; bottom: -1.5em; left: 50%; transform: translateX(-50%); width: max-content; max-width: calc(var(--icon-size) + 20px); line-height: 1.1; text-align: center; pointer-events: none; }
 .bubble.export { position: relative; padding: 10px 15px; border-radius: 16px; word-wrap: break-word; word-break: break-word; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12); background-color: var(--bubble-bg-color); max-width: var(--bubble-max-width); }
 .bubble-left.export { margin-left: 0; } .bubble-left.export::before { content: ""; position: absolute; top: 10px; left: -8px; width: 0; height: 0; border-style: solid; border-width: 8px 10px 8px 0; border-color: transparent var(--bubble-arrow-color) transparent transparent; }
 .bubble.export a { color: #0066cc; text-decoration: underline; } .bubble.export a:hover { color: #004c99; text-decoration: none; }
 .message-item.export[data-display-mode="narration"] .narration-tab, .message-item.export[data-display-mode="narration"] .narration-speaker { display: none; }
 .narration-tab { font-size: 0.8em; color: #666; margin-right: 0.5em; } .narration-speaker { font-weight: bold; margin-right: 0.25em; } .narration-message { display: inline; }
 body.name-below-icon-active .icon-container.export { margin-bottom: 1.8em; overflow: visible; } body.name-below-icon-active .speaker-name-default.export { display: none; } body.name-below-icon-active .tab-name-below-icon.export { display: block; } body.name-below-icon-active .speaker-name-below-icon.export { display: block; } body.name-below-icon-active .bubble-left.export { margin-left: 0; } body.name-below-icon-active .bubble-left.export::before { left: -8px; } body.name-below-icon-active .action-button-container { margin-left: 0; }
 .inserted-image-container.export { text-align: center; } .inserted-image.export { max-width: 85%; max-height: 550px; border-radius: 6px; box-shadow: 0 3px 8px rgba(0, 0, 0, 0.15); display: block; margin: 0 auto; }
 .image-caption.export { font-size: 0.9em; color: #444; margin-top: 6px; padding: 0 5%; line-height: 1.4; }
 .image-error-placeholder.export { color: #d9534f; font-size: 0.9em; font-weight: bold; margin-top: 8px; padding: 5px; background-color: #f2dede; border: 1px solid #ebccd1; border-radius: 4px; display: inline-block; }
 .tab-separator.export { border: 0; border-top: 2px dashed #cccccc; margin: 25px 5%; display: none; }
 .error-message.export { background-color: #fff3cd; border: 1px solid #ffeeba; color: #856404; padding: 10px 15px; border-radius: 4px; margin: 15px 0; font-size: 0.9em; } .error-message.export strong { font-weight: bold; } .error-message.export small { color: #66512c; display: block; margin-top: 4px; }
 .empty-log-message.export { text-align: center; color: #666; font-style: italic; padding: 30px; }
 .export-error { color: red; font-weight: bold; text-align: center; margin: 10px; padding: 5px; border: 1px solid red; background-color: #ffeeee; }
 @media (max-width: 768px) { body { padding: 10px; font-size: ${Math.max(14, fontSize - 1)}px; } .log-export-container { padding: 15px; } h1 { font-size: 1.5em; margin-bottom: 20px; } .filter-controls.export { flex-direction: column; align-items: stretch; } .filter-section { flex-direction: column; align-items: flex-start; width: 100%; } .tab-nav.export { justify-content: center; } .speaker-filter.export { width: 100%; } .icon-container.export { width: ${responsiveIconSize}px; height: ${responsiveIconSize}px; margin-right: 10px; } .icon-placeholder.export { line-height: ${responsivePlaceholderLineHeight}px; font-size: ${responsivePlaceholderFontSize}px; } .bubble.export { padding: 8px 12px; } .bubble-left.export::before { top: 8px; left: -7px; border-width: 7px 9px 7px 0;} .speaker-name-default.export { font-size: 0.92em; } .original-tab.export { font-size: 0.82em; } .tab-name-below-icon.export { font-size: 0.75em; } .speaker-name-below-icon.export { font-size: 0.8em; max-width: calc(${responsiveIconSize}px + 15px); bottom: -1.3em; } body.name-below-icon-active .icon-container.export { margin-bottom: 1.5em; } .inserted-image.export { max-width: 95%; max-height: 400px; } .image-caption.export { font-size: 0.85em; padding: 0 2%; } .tab-separator.export { margin: 20px 3%; } }
 `;
         }

        // --- Initialization ---
        function initializeApp() {
            console.log(`Initializing Log Formatter App (${APP_VERSION})...`);
            loadCustomization(); updateCustomizationUI();

            // ======[ イベントリスナーの登録 ]======
            cocofoliaFileInput.addEventListener('change', handleCocofoliaFileSelect);
            tekeyFileInput.addEventListener('change', handleTekeyFileSelect);
            projectLoadInput.addEventListener('change', handleProjectLoadFile);
            // ================================================

            settingsTabButton.addEventListener('click', () => switchSettingsTab('settings'));
            customizeTabButton.addEventListener('click', () => switchSettingsTab('customize'));
            saveSettingsButton.addEventListener('click', saveCharacterSettings);
            loadSettingsButton.addEventListener('click', loadCharacterSettings);
            applyCustomizationButton.addEventListener('click', applyCustomization);
            resetCustomizationButton.addEventListener('click', resetCustomization);
            logTabsNav.addEventListener('click', (e) => { if (e.target.tagName === 'BUTTON' && e.target.dataset.tab) handleTabChange(e.target.dataset.tab); });
            speakerFilterSelect.addEventListener('change', handleSpeakerFilterChange);
            exportButton.addEventListener('click', handleExportZip);
            saveProjectButton.addEventListener('click', saveProject);
            insertImageInput.addEventListener('change', handleInsertImageFile);
            addHeaderImageButton.addEventListener('click', () => triggerImageInsert(HEADER_IMAGE_INDEX));

            // Customization listeners
            fontSizeSlider.addEventListener('input', () => { fontSizeValueSpan.textContent = fontSizeSlider.value; });
            iconSizeSlider.addEventListener('input', () => { iconSizeValueSpan.textContent = iconSizeSlider.value; });
            bubbleWidthSlider.addEventListener('input', () => { bubbleWidthValueSpan.textContent = bubbleWidthSlider.value; });
            logHeightSlider.addEventListener('input', () => { const newHeight = logHeightSlider.value; logHeightValueSpan.textContent = newHeight; logDisplayDiv.style.height = `${newHeight}px`; customizationSettings.logDisplayHeight = parseInt(newHeight, 10); });
            fontSizeSlider.addEventListener('change', applyCustomization);
            iconSizeSlider.addEventListener('change', applyCustomization);
            bubbleWidthSlider.addEventListener('change', applyCustomization);
            logHeightSlider.addEventListener('change', applyCustomization); // Apply on change for height
            nameBelowIconToggle.addEventListener('change', applyCustomization);
            fontFamilySelect.addEventListener('change', applyCustomization);
            normalColorInput.addEventListener('change', applyCustomization);
            backgroundColorInput.addEventListener('change', applyCustomization);
            skipDeleteConfirmToggle.addEventListener('change', applyCustomization);

            switchSettingsTab('settings'); hideLoading(); disableControls();
            console.log("App initialization complete.");
        }

        function switchSettingsTab(tabName) {
            const panels = [settingsPanel, customizePanel]; const buttons = [settingsTabButton, customizeTabButton];
            panels.forEach(panel => panel.classList.add('hidden')); buttons.forEach(button => { button.classList.remove('border-indigo-500', 'text-indigo-600'); button.classList.add('border-transparent', 'text-gray-500', 'hover:text-gray-700', 'hover:border-gray-300'); button.removeAttribute('aria-current'); });
            let activePanel; let activeButton; if (tabName === 'settings') { activePanel = settingsPanel; activeButton = settingsTabButton; } else if (tabName === 'customize') { activePanel = customizePanel; activeButton = customizeTabButton; }
            if (activePanel) activePanel.classList.remove('hidden'); if (activeButton) { activeButton.classList.add('border-indigo-500', 'text-indigo-600'); activeButton.classList.remove('border-transparent', 'text-gray-500', 'hover:text-gray-700', 'hover:border-gray-300'); activeButton.setAttribute('aria-current', 'page'); }
        }

        // --- Run Initialization ---
        if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', initializeApp); else initializeApp();

      })(); // End IIFE
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ココフォリアログ整形ツール (画像埋め込み機能付き)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Noto+Sans+JP:wght@400;700&family=Noto+Serif+JP:wght@400;700&family=M+PLUS+Rounded+1c:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* --- Font Definitions --- */
        .font-inter { font-family: 'Inter', sans-serif; }
        .font-noto-sans { font-family: 'Noto Sans JP', sans-serif; }
        .font-noto-serif { font-family: 'Noto Serif JP', serif; }
        .font-mplus-rounded { font-family: "'M PLUS Rounded 1c'", sans-serif; }
        .font-system-sans { font-family: sans-serif; }
        .font-system-serif { font-family: serif; }
        .font-system-mono { font-family: monospace; }

        /* Basic styling */
        body {
            background-color: #f3f4f6; /* bg-gray-100 */
            /* Default font set by JS */
        }
        #log-display {
             /* Font set by JS */
             line-height: 1.7; /* Slightly increased line height for readability */
        }

        /* Custom scrollbar for log display */
        #log-display::-webkit-scrollbar { width: 8px; }
        #log-display::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
        #log-display::-webkit-scrollbar-thumb { background: #888; border-radius: 10px; }
        #log-display::-webkit-scrollbar-thumb:hover { background: #555; }
        /* Icon styling */
        .icon-border {
            border-width: 3px;
            border-style: solid;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }
        /* Chat bubble styling */
        .bubble {
            position: relative;
            padding: 10px 15px;
            border-radius: 15px;
            max-width: var(--bubble-max-width, 80%);
            word-wrap: break-word;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            background-color: var(--bubble-bg-color, #ffffff);
        }
        .bubble::before {
            content: "";
            position: absolute;
            top: 10px;
            width: 0;
            height: 0;
            border-style: solid;
        }
        .bubble-left {
            margin-right: auto;
            margin-left: calc(var(--icon-size, 64px) + 12px); /* Default icon size 64px */
        }
        .bubble-left::before {
            left: -8px;
            border-width: 8px 10px 8px 0;
            border-color: transparent var(--bubble-arrow-color, #ffffff) transparent transparent;
        }

        /* --- Message Display Modes --- */
        .message-item { /* Base container for each message, handles positioning context */
             position: relative;
             padding-top: 1.5px;
             padding-bottom: 1.5px;
        }
        .message-container { /* Flex container for Bubble mode */
            display: flex;
            align-items: flex-start; /* Ensure vertical alignment starts at the top */
        }
        .icon-container {
            flex-shrink: 0;
            position: relative;
            width: var(--icon-size); /* Use CSS variable */
            height: var(--icon-size); /* Use CSS variable */
            margin-right: 12px;
        }
        .content-container {
             flex-grow: 1;
             min-width: 0;
        }
        .speaker-name-default {
            display: block;
            font-size: 0.9em;
            font-weight: bold;
            color: #333;
            margin-bottom: 2px;
        }
        .tab-name-below-icon {
             display: none; /* Hidden by default */
             font-size: 0.8em;
             color: #666;
             margin-bottom: 2px;
        }
        .speaker-name-below-icon {
            display: none; /* Hidden by default */
            font-size: 0.85em;
            font-weight: bold;
            color: #333;
            text-align: center;
            text-shadow: -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff, 1px 1px 0 #fff, -1.5px -1.5px 0 #fff, 1.5px -1.5px 0 #fff, -1.5px 1.5px 0 #fff, 1.5px 1.5px 0 #fff;
            position: absolute;
            bottom: -1.5em; /* Adjusted position further down */
            left: 50%;
            transform: translateX(-50%);
            width: max-content;
            max-width: calc(var(--icon-size, 64px) + 20px); /* Default icon size 64px */
            line-height: 1.1;
            pointer-events: none;
        }

        /* Narration Mode Styles */
        .narration-container {
            padding: 2px 4px;
            margin-left: 0;
            font-size: inherit;
            line-height: inherit;
            color: #333;
        }
        /* Hide tab and speaker in narration mode */
        .message-item[data-display-mode="narration"] .narration-tab,
        .message-item[data-display-mode="narration"] .narration-speaker {
            display: none;
        }
        .narration-tab { /* Still define base style if needed elsewhere */
            font-size: 0.8em;
            color: #666;
            margin-right: 0.5em;
        }
        .narration-speaker { /* Still define base style if needed elsewhere */
            font-weight: bold;
            margin-right: 0.25em;
        }
        .narration-message {
             /* Ensure message takes full width or aligns left */
             display: block; /* Or inline, depending on desired flow */
        }

        /* Hide elements based on display mode */
        .message-item[data-display-mode="narration"] .message-container { display: none; }
        .message-item[data-display-mode="bubble"] .narration-container { display: none; }

        /* --- 名前をアイコン下に表示モード 有効時のスタイル --- */ 
        .name-below-icon-active .icon-container {
            margin-bottom: 1.8em; /* Increased margin to prevent overlap */
            overflow: visible;
        }
        .name-below-icon-active .speaker-name-default { display: none; }
        .name-below-icon-active .tab-name-below-icon { display: block; } 
        .name-below-icon-active .speaker-name-below-icon { display: block; } 
        .name-below-icon-active .bubble-left { margin-left: 0; }
        .name-below-icon-active .bubble-left::before { left: -8px; }
        .name-below-icon-active .action-button-container { margin-left: 0; }

        /* --- Display Mode Toggle Button --- */
        .display-mode-toggle {
            position: absolute;
            top: 1px; /* Align with top */
            right: 1px;
            padding: 3px 5px; /* Increased padding */
            font-size: 1rem; /* Larger icon size */
            line-height: 1;
            border-radius: 4px;
            border: 1px solid #bbb; /* Slightly darker border */
            background-color: #f0f0f0; /* Light gray background */
            color: #333; /* Darker icon color */
            cursor: pointer;
            opacity: 0.85; /* More visible by default */
            transition: opacity 0.2s, background-color 0.2s;
            z-index: 10;
            /* Remove hover effect that hides it */
        }
        /* .message-item:hover .display-mode-toggle {
            opacity: 1; /* No longer needed */
        /* } */
        .display-mode-toggle:hover {
            background-color: #ddd; /* Darken slightly on hover */
            border-color: #999;
        }


        /* --- Other Styles --- */
        .inserted-image-container { margin-top: 8px; margin-bottom: 8px; text-align: center; }
        .inserted-image { max-width: 80%; max-height: 400px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); display: block; margin-left: auto; margin-right: auto; }
        .image-caption { font-size: 0.85em; color: #555; margin-top: 4px; padding: 0 10%; line-height: 1.4; }
        .tab-separator { border: 0; border-top: 2px dotted #ccc; margin: 15px 5%; }
        #loading-overlay { position: fixed; inset: 0; background-color: rgba(0, 0, 0, 0.6); display: flex; justify-content: center; align-items: center; z-index: 9999; opacity: 0; transition: opacity 0.3s ease-out; pointer-events: none; }
        #loading-overlay.visible { opacity: 1; pointer-events: auto; }
        .loader { border: 8px solid #f3f3f3; border-top: 8px solid #3498db; border-radius: 50%; width: 60px; height: 60px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .visually-hidden { position: absolute; width: 1px; height: 1px; margin: -1px; padding: 0; overflow: hidden; clip: rect(0, 0, 0, 0); border: 0; }
        .file-input-label { display: inline-block; padding: 0.5rem 1rem; cursor: pointer; border-radius: 0.375rem; background-color: #4f46e5; color: white; font-weight: 600; transition: background-color 0.2s; }
        .file-input-label:hover { background-color: #4338ca; }
        .action-button-container { margin-top: 4px; display: flex; justify-content: flex-start; gap: 8px; flex-wrap: wrap; }
        .action-button { font-size: 0.75rem; padding: 0.125rem 0.5rem; border-radius: 0.25rem; transition: background-color 0.15s ease-in-out, color 0.15s ease-in-out; border: none; cursor: pointer; line-height: 1.5; }
        .action-button:focus { outline: none; box-shadow: 0 0 0 2px rgba(96, 165, 250, 0.5); }
        .action-button-insert { background-color: #e5e7eb; color: #374151; }
        .action-button-insert:hover { background-color: #d1d5db; }
        .action-button-delete { background-color: #fee2e2; color: #b91c1c; }
        .action-button-delete:hover { background-color: #fecaca; }
        .action-button-edit { background-color: #dbeafe; color: #1d4ed8; }
        .action-button-edit:hover { background-color: #bfdbfe; }
        .switch { position: relative; display: inline-block; width: 50px; height: 24px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 24px; }
        .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #2196F3; }
        input:checked + .slider:before { transform: translateX(26px); }

        /* Footer Styling */
        .app-footer {
             margin-top: 2rem; /* 32px */
             padding-top: 1.5rem; /* 24px */
             border-top: 1px solid #e5e7eb; /* border-gray-200 */
             font-size: 0.875rem; /* text-sm */
             color: #6b7280; /* text-gray-500 */
        }
        .app-footer h4 {
             font-size: 1rem; /* text-base */
             font-weight: 600; /* font-semibold */
             color: #4b5563; /* text-gray-600 */
             margin-bottom: 0.5rem; /* 8px */
        }
        .app-footer ul {
             list-style-type: disc;
             list-style-position: inside;
             margin-bottom: 1rem; /* 16px */
             padding-left: 0.5rem; /* Add padding for list items */
        }
        .app-footer li {
             margin-bottom: 0.25rem; /* 4px */
        }
        .app-footer a {
             color: #4f46e5; /* text-indigo-600 */
             text-decoration: underline;
             transition: color 0.2s;
        }
        .app-footer a:hover {
             color: #4338ca; /* hover:text-indigo-700 */
        }
        .footer-credits {
             margin-top: 1rem; /* 16px */
             text-align: center;
        }
    </style>
</head>
<body class="bg-gray-100 p-4 md:p-8">
    <div class="container mx-auto max-w-7xl bg-white rounded-lg shadow-xl p-5 md:p-8">
        <h1 class="text-2xl md:text-3xl font-bold mb-4 text-center text-gray-800">ココフォリアログ整形ツール (画像埋め込み機能付き)</h1>
        <div class="mb-6 p-4 border border-blue-200 rounded-lg bg-blue-50 text-sm text-blue-800">
            <h3 class="font-semibold mb-1">使い方:</h3>
            <ol class="list-decimal list-inside space-y-1">
                <li>「ファイルを選択...」ボタンからココフォリアのHTMLログファイル（[all]形式推奨）を読み込みます。</li>
                <li>キャラクター設定タブで、表示名やアイコンを設定します（設定は一時保存/読込可能）。</li>
                <li>表示カスタマイズタブで、フォントや色、表示モード（名前をアイコン下に表示）などを調整します。</li>
                <li>ログ表示エリアで、タブや発言者での絞り込み、画像挿入、表示モードの個別切り替え（💬/📝ボタン）が可能です。</li>
                <li>「整形済みログをZIPで出力」ボタンで、整形結果を保存します。</li>
            </ol>
        </div>

        <div class="mb-6 p-4 border border-dashed border-gray-300 rounded-lg bg-gray-50">
            <label for="log-file-input" class="block text-lg font-semibold mb-2 text-gray-700">1. ログファイルを選択:</label>
            <input type="file" id="log-file-input" accept=".html" class="visually-hidden">
            <label for="log-file-input" class="file-input-label">ファイルを選択...</label>
            <span id="file-info" class="ml-3 text-sm font-medium text-blue-600 align-middle">ファイルが選択されていません</span>
            <p class="mt-2 text-sm text-gray-500">ccfoliaからエクスポートしたHTMLログファイル (`[all]` 形式推奨) を選択してください。</p>
        </div>

        <div class="mb-6">
             <div class="border-b border-gray-200">
                <nav class="-mb-px flex space-x-6" aria-label="Tabs">
                    <button id="tab-btn-settings" data-tab-target="settings" class="whitespace-nowrap py-3 px-1 border-b-2 font-medium text-sm border-indigo-500 text-indigo-600" aria-current="page">キャラクター設定</button>
                    <button id="tab-btn-customize" data-tab-target="customize" class="whitespace-nowrap py-3 px-1 border-b-2 font-medium text-sm border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300">表示カスタマイズ</button>
                </nav>
            </div>

            <div id="settings-panel-settings" class="mt-4 p-4 border rounded-lg bg-gray-50" role="tabpanel" aria-labelledby="tab-btn-settings">
                <h3 class="text-lg font-semibold mb-3 text-gray-700">2. キャラクター設定:</h3>
                <p class="text-sm text-gray-600 mb-4">ログから検出された発言者名です（発言回数が多い順）。表示名とアイコン画像を設定してください。</p>
                <div id="character-settings" class="space-y-4"><p class="text-gray-500 italic">ログファイルを読み込むと表示されます。</p></div>
                 <button id="save-settings-button" class="mt-4 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed" disabled>設定を一時保存</button>
                 <button id="load-settings-button" class="mt-4 ml-2 px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed" disabled>設定を読み込み</button>
                 <p class="text-xs text-gray-500 mt-1">設定はブラウザのLocalStorageに一時的に保存されます。</p>
            </div>

            <div id="settings-panel-customize" class="hidden mt-4 p-4 border rounded-lg bg-gray-50" role="tabpanel" aria-labelledby="tab-btn-customize">
                 <h3 class="text-lg font-semibold mb-3 text-gray-700">表示カスタマイズ:</h3>
                 <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <label for="bubble-normal-color" class="block text-sm font-medium text-gray-700">吹き出し色:</label>
                        <input type="color" id="bubble-normal-color" value="#ffffff" class="mt-1 block w-full h-8 rounded border border-gray-300 cursor-pointer p-0.5">
                    </div>
                    <div>
                        <label for="font-size-slider" class="block text-sm font-medium text-gray-700">フォントサイズ: <span id="font-size-value">16</span>px</label>
                        <input type="range" id="font-size-slider" min="10" max="24" value="16" class="mt-1 block w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div>
                        <label for="background-color" class="block text-sm font-medium text-gray-700">背景色:</label>
                        <input type="color" id="background-color" value="#f3f4f6" class="mt-1 block w-full h-8 rounded border border-gray-300 cursor-pointer p-0.5">
                    </div>
                    <div>
                        <label for="icon-size-slider" class="block text-sm font-medium text-gray-700">アイコンサイズ: <span id="icon-size-value">64</span>px</label>
                        <input type="range" id="icon-size-slider" min="24" max="64" value="64" class="mt-1 block w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div class="md:col-span-2">
                        <label for="bubble-width-slider" class="block text-sm font-medium text-gray-700">吹き出し最大幅: <span id="bubble-width-value">80</span>%</label>
                        <input type="range" id="bubble-width-slider" min="30" max="100" value="80" class="mt-1 block w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                    </div>
                     <div class="md:col-span-2">
                         <label for="font-family-select" class="block text-sm font-medium text-gray-700">フォント:</label>
                         <select id="font-family-select" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 bg-white focus:border-indigo-500 focus:ring-indigo-500">
                             <option value="font-noto-sans" selected>'Noto Sans JP' (推奨)</option>
                             <option value="font-inter">'Inter' (UI標準)</option>
                             <option value="font-noto-serif">'Noto Serif JP' (明朝)</option>
                             <option value="font-mplus-rounded">'M PLUS Rounded 1c' (丸ゴシック)</option>
                             <option value="font-system-sans">システム標準ゴシック</option>
                             <option value="font-system-serif">システム標準明朝</option>
                             <option value="font-system-mono">システム標準等幅</option>
                         </select>
                     </div>
                    <div class="md:col-span-2 flex items-center space-x-2">
                        <label for="name-below-icon-toggle" class="text-sm font-medium text-gray-700">名前をアイコン下に表示:</label>
                        <label class="switch">
                            <input type="checkbox" id="name-below-icon-toggle">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="md:col-span-2">
                        <label for="log-height-slider" class="block text-sm font-medium text-gray-700">ログ表示高さ: <span id="log-height-value">384</span>px</label>
                        <input type="range" id="log-height-slider" min="200" max="800" value="384" class="mt-1 block w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                    </div>
                 </div>
                 <button id="apply-customization" class="mt-4 px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600">カスタマイズ適用</button>
                 <button id="reset-customization" class="mt-4 ml-2 px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600">リセット</button>
            </div>
        </div>

        <div class="mb-6">
            <h3 class="text-lg font-semibold mb-3 text-gray-700">3. ログ表示:</h3>
            <div class="mb-4 border-b border-gray-200">
                <nav id="log-tabs" class="-mb-px flex space-x-4 overflow-x-auto pb-1" aria-label="Log Tabs">
                    <span class="whitespace-nowrap py-3 px-2 text-gray-500 text-sm italic">ログを読み込んでください</span>
                </nav>
            </div>
            <div class="mb-4">
                <label for="speaker-filter" class="block text-sm font-medium text-gray-700">発言者で絞り込み:</label>
                <select id="speaker-filter" class="mt-1 block w-full md:w-1/3 rounded-md border-gray-300 shadow-sm p-2 bg-white focus:border-indigo-500 focus:ring-indigo-500" disabled>
                    <option value="all">すべての発言者</option>
                </select>
            </div>
            <div id="log-display" class="overflow-y-auto border border-gray-300 rounded-lg p-4 bg-white space-y-1 font-noto-sans" style="--bubble-max-width: 80%; --bubble-bg-color: #ffffff; --bubble-arrow-color: #ffffff; --icon-size: 64px;" aria-live="polite">
                <p class="text-gray-500 text-center italic">ここに整形されたログが表示されます。</p>
            </div>
        </div>

        <div class="mt-8 text-center">
             <h3 class="text-lg font-semibold mb-3 text-gray-700">4. エクスポート:</h3>
             <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4 max-w-lg mx-auto text-left">
                 <div>
                     <label for="export-html-title" class="block text-sm font-medium text-gray-700">HTMLタイトル:</label>
                     <input type="text" id="export-html-title" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-1.5 focus:border-indigo-500 focus:ring-indigo-500 text-sm" placeholder="例: セッションログ">
                 </div>
                 <div>
                     <label for="export-zip-filename" class="block text-sm font-medium text-gray-700">ZIPファイル名:</label>
                     <input type="text" id="export-zip-filename" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-1.5 focus:border-indigo-500 focus:ring-indigo-500 text-sm" placeholder="例: log_export">
                 </div>
             </div>
            <button id="export-zip-button" class="px-6 py-3 bg-indigo-600 text-white font-semibold rounded-lg shadow hover:bg-indigo-700 disabled:opacity-50 disabled:cursor-not-allowed" disabled>整形済みログをZIPで出力</button>
             <p class="mt-2 text-sm text-gray-500">整形済みログ(HTML)、CSS、挿入画像、アイコン画像をZIPファイルで保存します。</p>
             <p class="text-xs text-gray-500">（注意: Google Fontsはオフラインでは表示されません）</p>
        </div>

        <footer class="app-footer">
            <h4>更新履歴</h4>
            <ul>
                 <li>2025/05/03: 公開</li>
            </ul>
            <div class="footer-credits">
                作成者: しるべ (<a href="https://x.com/qxoiUioxp" target="_blank" rel="noopener noreferrer">@qxoiUioxp</a>)
            </div>
        </footer>

    </div>
    <input type="file" id="insert-image-input" accept="image/*" class="visually-hidden">

    <div id="loading-overlay" aria-hidden="true" aria-label="処理中">
        <div class="loader"></div>
    </div>

    <script>
      // Wrap entire script in an IIFE (Immediately Invoked Function Expression)
      (function() {
        "use strict"; // Enable strict mode

        // --- State Variables ---
        let originalLogData = [];
        let displayLogData = []; // Now includes displayMode for each message
        let characterSettings = {};
        let customizationSettings = {
            normalBubbleColor: '#ffffff',
            fontSize: 16,
            backgroundColor: '#f3f4f6',
            iconSize: 64, // Default icon size updated
            bubbleMaxWidth: 80,
            nameBelowIconMode: false, 
            fontFamily: 'font-noto-sans',
            logDisplayHeight: 384 // Added log display height
         };
         let currentTabFilter = 'all';
         let currentSpeakerFilter = 'all';
        let uploadedFiles = {};
        let isProcessingFile = false;
        let speakerFrequencies = {};
        let imageInsertTargetIndex = -1;
        let nextUniqueId = 0;
        let logFileNameBase = 'ccfolia_log';
        let uniqueTabsFound = new Set();
        let speakerDataForExport = {};

        // --- DOM Elements ---
        const fileInput = document.getElementById('log-file-input');
        const fileInfoSpan = document.getElementById('file-info');
        const characterSettingsDiv = document.getElementById('character-settings');
        const logTabsNav = document.getElementById('log-tabs');
        const speakerFilterSelect = document.getElementById('speaker-filter');
        const logDisplayDiv = document.getElementById('log-display');
        const exportButton = document.getElementById('export-zip-button');
        const loadingOverlay = document.getElementById('loading-overlay');
        const saveSettingsButton = document.getElementById('save-settings-button');
        const loadSettingsButton = document.getElementById('load-settings-button');
        const settingsTabButton = document.getElementById('tab-btn-settings');
        const customizeTabButton = document.getElementById('tab-btn-customize');
        const settingsPanel = document.getElementById('settings-panel-settings');
        const customizePanel = document.getElementById('settings-panel-customize');
        const normalColorInput = document.getElementById('bubble-normal-color');
        const fontSizeSlider = document.getElementById('font-size-slider');
        const fontSizeValueSpan = document.getElementById('font-size-value');
        const backgroundColorInput = document.getElementById('background-color');
        const iconSizeSlider = document.getElementById('icon-size-slider');
        const iconSizeValueSpan = document.getElementById('icon-size-value');
        const bubbleWidthSlider = document.getElementById('bubble-width-slider');
        const bubbleWidthValueSpan = document.getElementById('bubble-width-value');
        const nameBelowIconToggle = document.getElementById('name-below-icon-toggle'); 
        const fontFamilySelect = document.getElementById('font-family-select'); // Font select dropdown
        const applyCustomizationButton = document.getElementById('apply-customization');
        const resetCustomizationButton = document.getElementById('reset-customization');
        const insertImageInput = document.getElementById('insert-image-input');
        const exportHtmlTitleInput = document.getElementById('export-html-title');
        const exportZipFilenameInput = document.getElementById('export-zip-filename');
        const logHeightSlider = document.getElementById('log-height-slider'); // Added log height slider
        const logHeightValueSpan = document.getElementById('log-height-value'); // Added log height value span

        // --- Constants ---
        const PLACEHOLDER_ICON_URL = 'https://placehold.co/64x64/e0e0e0/757575?text=?';
        const LOCALSTORAGE_SETTINGS_KEY = 'ccfoliaLogToolSettings_v5'; // Keep version consistent
        const LOCALSTORAGE_CUSTOMIZATION_KEY = 'ccfoliaLogToolCustomization_v5'; // Keep version consistent
        const FONT_CLASSES = [ // List of available font classes
             'font-inter', 'font-noto-sans', 'font-noto-serif',
             'font-mplus-rounded', 'font-system-sans', 'font-system-serif',
             'font-system-mono'
        ];

        // --- Utility Functions ---
        function escapeHtml(unsafe) { if (typeof unsafe !== 'string') return ''; return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;"); }
        function escapeCssSelector(str) { if (!str) return ''; return str.replace(/([!"#$%&'()*+,.\/:;<=>?@[\\\]^`{|}~])/g, '\\$1'); }
        function showLoading() { if (loadingOverlay) { loadingOverlay.classList.add('visible'); loadingOverlay.setAttribute('aria-hidden', 'false'); } }
        function hideLoading() { if (loadingOverlay) { loadingOverlay.classList.remove('visible'); loadingOverlay.setAttribute('aria-hidden', 'true'); } }
        function readFileAsText(file) { return new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = () => resolve(reader.result); reader.onerror = () => reject(reader.error || new Error(`Failed to read file: ${file.name}`)); reader.readAsText(file, 'UTF-8'); }); }
        function readFileAsDataURL(file) { return new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = () => resolve(reader.result); reader.onerror = () => reject(reader.error || new Error(`Failed to read file as Data URL: ${file.name}`)); reader.readAsDataURL(file); }); }
        function generateUniqueId(prefix = 'item') { return `${prefix}_${nextUniqueId++}`; }
        function generateBaseFilename(filename) {
            if (!filename) return 'ccfolia_log';
            let base = filename.replace(/\.[^/.]+$/, "");
            base = base.replace(/\[.*?\]/g, '').trim();
            base = base.replace(/[\\/:*?"<>|]/g, '_');
            return base || 'ccfolia_log';
        }

        // --- Core Logic Functions ---
        async function handleFileSelect(event) {
            if (isProcessingFile) { console.warn("Processing already in progress."); event.target.value = null; return; }
            const file = event.target.files?.[0];
            if (!file) { fileInfoSpan.textContent = 'ファイルが選択されていません'; return; }
            if (!file.name.toLowerCase().endsWith('.html')) { alert('HTMLファイルを選択してください。'); fileInfoSpan.textContent = 'HTMLファイルを選択してください'; event.target.value = null; return; }

            isProcessingFile = true;
            fileInfoSpan.textContent = `読込中: ${escapeHtml(file.name)}...`;
            logFileNameBase = generateBaseFilename(file.name);
            exportHtmlTitleInput.value = logFileNameBase;
            exportZipFilenameInput.value = logFileNameBase;
            console.log(`[${new Date().toISOString()}] Starting file processing: ${file.name}`);
            console.log(`[${new Date().toISOString()}] Default export base name set to: ${logFileNameBase}`);
            showLoading();
            resetAppState();

            try {
                const fileContent = await readFileAsText(file);
                if (!fileContent || fileContent.trim().length === 0) throw new Error("ファイルが空か、内容を読み取れませんでした。");
                console.log(`[${new Date().toISOString()}] File read complete. Parsing HTML...`);
                await new Promise(resolve => setTimeout(resolve, 50));
                parseLogHtml(fileContent); // Parses and sets originalLogData
                console.log(`[${new Date().toISOString()}] Parsing complete. Populating UI elements...`);

                // Initialize displayLogData with displayMode based on speaker
                displayLogData = originalLogData.map(item => {
                    if (item.type === 'message') {
                        // Set displayMode to 'narration' if speaker is 'system', otherwise 'bubble'
                        const initialDisplayMode = (item.speaker === 'system') ? 'narration' : 'bubble';
                        return { ...item, displayMode: initialDisplayMode };
                    }
                    return item; // Keep other types as is
                });

                initializeCharacterSettings();
                updateSpeakerDataForExport();
                populateCharacterSettingsUI();
                populateTabsUI();
                populateSpeakerFilterUI();
                renderLog(); // Apply initial customization
                fileInfoSpan.textContent = `読込完了: ${escapeHtml(file.name)} (${originalLogData.length}件)`;
                enableControls();
                console.log(`[${new Date().toISOString()}] Processing finished successfully.`);
            } catch (error) {
                console.error(`[${new Date().toISOString()}] Error during file processing:`, error);
                alert(`処理中にエラーが発生しました: ${error.message}`);
                fileInfoSpan.textContent = '処理エラーが発生しました';
                logDisplayDiv.innerHTML = '<p class="text-red-500 text-center font-semibold">ログの処理中にエラーが発生しました。</p>';
                disableControls();
            } finally {
                hideLoading();
                isProcessingFile = false;
                if (fileInput) fileInput.value = null;
            }
        }

        function resetAppState() {
            originalLogData = []; displayLogData = []; characterSettings = {};
            currentTabFilter = 'all'; currentSpeakerFilter = 'all'; uploadedFiles = {};
            speakerFrequencies = {}; uniqueTabsFound = new Set(); nextUniqueId = 0;
            imageInsertTargetIndex = -1; speakerDataForExport = {};
            logFileNameBase = 'ccfolia_log';
            exportHtmlTitleInput.value = logFileNameBase;
            exportZipFilenameInput.value = logFileNameBase;
            characterSettingsDiv.innerHTML = '<p class="text-gray-500 italic">ログファイルを読み込むと表示されます。</p>';
            logTabsNav.innerHTML = '<span class="whitespace-nowrap py-3 px-2 text-gray-500 text-sm italic">ログを読み込んでください</span>';
            speakerFilterSelect.innerHTML = '<option value="all">すべての発言者</option>';
            logDisplayDiv.innerHTML = '<p class="text-gray-500 text-center italic">ここに整形されたログが表示されます。</p>';
            // Reset customization state and UI
            resetCustomizationDefaults(); // Resets iconSize to 64 and log height
            updateCustomizationUI();
            disableControls();
        }

        function enableControls() { exportButton.disabled = false; saveSettingsButton.disabled = false; loadSettingsButton.disabled = false; speakerFilterSelect.disabled = Object.keys(speakerFrequencies).length === 0; exportHtmlTitleInput.disabled = false; exportZipFilenameInput.disabled = false; }
        function disableControls() { exportButton.disabled = true; saveSettingsButton.disabled = true; loadSettingsButton.disabled = true; speakerFilterSelect.disabled = true; exportHtmlTitleInput.disabled = true; exportZipFilenameInput.disabled = true; }

        function parseLogHtml(htmlContent) {
            console.log("   [parseLogHtml] Starting HTML parsing...");
            const parser = new DOMParser(); const doc = parser.parseFromString(htmlContent, 'text/html');
            if (!doc || !doc.body) throw new Error("HTMLコンテンツの解析に失敗しました。");
            const paragraphs = doc.body.querySelectorAll('p');
            console.log(`   [parseLogHtml] Found ${paragraphs.length} potential message elements.`);
            const tempData = []; const tempSpeakerFreq = {}; const tempUniqueTabs = new Set();
            let currentUniqueId = 0;
            paragraphs.forEach((p, index) => {
                if (!p.textContent?.trim()) return;
                try {
                    const spans = p.querySelectorAll('span');
                    if (spans.length >= 3) {
                        const tabMatch = spans[0]?.textContent?.match(/\[(.*?)\]/);
                        const tab = tabMatch?.[1]?.trim() || 'main';
                        const speaker = spans[1]?.textContent?.trim().replace(/[:：]$/, '').trim() || '不明';
                        const message = spans[2]?.innerHTML?.trim() ?? '';
                        const colorMatch = p.getAttribute('style')?.match(/color:\s*(#[0-9a-fA-F]{3,6}|rgba?\([^)]+\)|[a-zA-Z]+)/);
                        const color = colorMatch?.[1]?.trim() || '#000000';
                        // Don't count 'system' speaker frequency
                        if (speaker !== '不明' && speaker !== 'system') tempSpeakerFreq[speaker] = (tempSpeakerFreq[speaker] || 0) + 1;
                        tempUniqueTabs.add(tab);
                        tempData.push({ type: 'message', id: `msg_${currentUniqueId++}`, originalIndex: index, tab: tab, speaker: speaker, color: color, message: message });
                    } else console.warn(`   [parseLogHtml] Skipping paragraph at index ${index} due to unexpected span count (${spans.length}).`);
                } catch (parseError) {
                    console.error(`   [parseLogHtml] Error parsing paragraph at index ${index}:`, parseError, p.outerHTML);
                    tempData.push({ type: 'error', id: `err_${currentUniqueId++}`, originalIndex: index, message: `ログの解析エラー (行 ${index + 1})`, details: p.textContent?.substring(0, 100) || '内容不明' });
                }
            });
            // Set originalLogData but don't initialize displayLogData here yet
            originalLogData = tempData;
            speakerFrequencies = tempSpeakerFreq;
            uniqueTabsFound = tempUniqueTabs;
            nextUniqueId = currentUniqueId;
            console.log(`   [parseLogHtml] Parsing finished. Parsed ${originalLogData.length} items.`);
            console.log("   [parseLogHtml] Speaker Frequencies:", speakerFrequencies);
            console.log("   [parseLogHtml] Unique Tabs Found:", uniqueTabsFound);
        }

        function initializeCharacterSettings() { characterSettings = {}; Object.keys(speakerFrequencies).forEach(speaker => { if (speaker !== 'system' && !characterSettings[speaker]) characterSettings[speaker] = { displayName: speaker, icon: null }; }); console.log("   [initializeCharacterSettings] Initialized settings for:", Object.keys(characterSettings)); }
        function updateSpeakerDataForExport() { speakerDataForExport = {}; Object.entries(characterSettings).forEach(([original, setting]) => { if (original !== 'system') speakerDataForExport[original] = setting.displayName; }); }

        function populateCharacterSettingsUI() {
            characterSettingsDiv.innerHTML = '';
            // Filter out 'system' speaker before sorting and displaying
            const sortedSpeakers = Object.keys(characterSettings).filter(s => s !== 'system').sort((a, b) => (speakerFrequencies[b] || 0) - (speakerFrequencies[a] || 0));
            if (sortedSpeakers.length === 0) { characterSettingsDiv.innerHTML = '<p class="text-gray-500 italic">ログ内に認識可能な発言者がいませんでした。</p>'; return; }
            const fragment = document.createDocumentFragment();
            sortedSpeakers.forEach(speaker => {
                try {
                    const setting = characterSettings[speaker]; if (!setting) { console.warn(`Setting not found for ${speaker}.`); return; }
                    const count = speakerFrequencies[speaker] || 0; const uniqueSpeakerId = escapeCssSelector(speaker);
                    const container = document.createElement('div'); container.className = 'p-3 border rounded-md bg-white flex items-center space-x-4 shadow-sm';
                    const iconDiv = document.createElement('div'); iconDiv.className = 'flex-shrink-0';
                    const imgPreview = document.createElement('img'); imgPreview.id = `icon-preview-${uniqueSpeakerId}`; imgPreview.src = setting.icon || PLACEHOLDER_ICON_URL.replace('64x64', '40x40'); imgPreview.alt = `${setting.displayName} のアイコン`; imgPreview.className = 'w-10 h-10 rounded-full object-cover border border-gray-300 cursor-pointer'; imgPreview.loading = 'lazy';
                    imgPreview.onerror = () => { if (imgPreview.src !== PLACEHOLDER_ICON_URL.replace('64x64', '40x40')) imgPreview.src = PLACEHOLDER_ICON_URL.replace('64x64', '40x40'); if (characterSettings[speaker]) characterSettings[speaker].icon = null; };
                    const iconInput = document.createElement('input'); iconInput.type = 'file'; iconInput.accept = 'image/*'; iconInput.id = `icon-input-${uniqueSpeakerId}`; iconInput.className = 'visually-hidden'; iconInput.setAttribute('aria-labelledby', `icon-label-${uniqueSpeakerId}`); iconInput.addEventListener('change', (e) => handleIconUpload(e, speaker));
                    const iconLabel = document.createElement('label'); iconLabel.htmlFor = `icon-input-${uniqueSpeakerId}`; iconLabel.id = `icon-label-${uniqueSpeakerId}`; iconLabel.className = 'cursor-pointer'; iconLabel.setAttribute('title', `クリックして ${setting.displayName} のアイコンを変更`); iconLabel.appendChild(imgPreview); iconDiv.appendChild(iconLabel); iconDiv.appendChild(iconInput);
                    const nameDiv = document.createElement('div'); nameDiv.className = 'flex-grow min-w-0';
                    const nameLabel = document.createElement('label'); nameLabel.htmlFor = `name-input-${uniqueSpeakerId}`; nameLabel.className = 'block text-sm font-medium text-gray-700 mb-1'; nameLabel.innerHTML = `「${escapeHtml(speaker)}」 <span class="text-xs text-gray-500">(${count}回)</span> 表示名:`;
                    const nameInput = document.createElement('input'); nameInput.type = 'text'; nameInput.id = `name-input-${uniqueSpeakerId}`; nameInput.value = setting.displayName; nameInput.className = 'block w-full rounded-md border-gray-300 shadow-sm p-1.5 focus:border-indigo-500 focus:ring-indigo-500 text-sm'; nameInput.setAttribute('aria-label', `${escapeHtml(speaker)} の表示名`);
                    nameInput.addEventListener('input', (e) => {
                        const newDisplayName = e.target.value;
                        if (characterSettings[speaker]) {
                            characterSettings[speaker].displayName = newDisplayName;
                            updateSpeakerFilterOptionText(speaker, newDisplayName);
                            updateSpeakerDataForExport();
                            renderLog();
                        }
                    });
                    nameDiv.appendChild(nameLabel); nameDiv.appendChild(nameInput); container.appendChild(iconDiv); container.appendChild(nameDiv); fragment.appendChild(container);
                } catch (uiError) { console.error(`Error creating UI element for speaker "${speaker}":`, uiError); const errorDiv = document.createElement('div'); errorDiv.className = 'p-3 border rounded-md bg-red-50 text-red-700'; errorDiv.textContent = `「${escapeHtml(speaker)}」の設定表示中にエラーが発生しました。`; fragment.appendChild(errorDiv); }
            });
            characterSettingsDiv.appendChild(fragment);
        }

        function updateSpeakerFilterOptionText(originalSpeaker, newDisplayName) { try { const escapedSpeaker = escapeCssSelector(originalSpeaker); const option = speakerFilterSelect.querySelector(`option[value="${escapedSpeaker}"]`); if (option) { const count = speakerFrequencies[originalSpeaker] || 0; const displayName = newDisplayName?.trim() || originalSpeaker; option.textContent = `${escapeHtml(displayName)} (${count}回)`; } } catch (e) { console.error(`Error updating speaker filter option for "${originalSpeaker}":`, e); } }

        async function handleIconUpload(event, speaker) {
            const file = event.target.files?.[0]; if (!file) return;
            if (!file.type.startsWith('image/')) { alert('画像ファイルを選択してください。'); event.target.value = null; return; }
            const maxSize = 5 * 1024 * 1024; if (file.size > maxSize) { alert(`ファイルサイズが大きすぎます (${(file.size / 1024 / 1024).toFixed(1)}MB)。5MB以下にしてください。`); event.target.value = null; return; }
            const uniqueSpeakerId = escapeCssSelector(speaker); const imgPreview = document.getElementById(`icon-preview-${uniqueSpeakerId}`);
            try {
                const dataUrl = await readFileAsDataURL(file);
                if (imgPreview) imgPreview.src = dataUrl;
                if (!characterSettings[speaker]) { characterSettings[speaker] = { displayName: speaker, icon: null }; console.warn(`Character setting for ${speaker} was missing.`); }
                characterSettings[speaker].icon = dataUrl; uploadedFiles[speaker] = file;
                console.log(`Icon updated for ${speaker}. Re-rendering log.`); renderLog();
            } catch (error) { console.error(`Error processing icon upload for ${speaker}:`, error); alert(`アイコンの読み込みに失敗しました: ${error.message}`); if (imgPreview && characterSettings[speaker]?.icon) imgPreview.src = characterSettings[speaker].icon; else if (imgPreview) imgPreview.src = PLACEHOLDER_ICON_URL.replace('64x64', '40x40'); }
            finally { if (event.target) event.target.value = null; }
        }

        function saveCharacterSettings() {
            if (Object.keys(characterSettings).length === 0) { alert('保存する設定がありません。'); return; }
            try { const settingsToSave = {}; Object.entries(characterSettings).forEach(([speaker, settings]) => { settingsToSave[speaker] = { displayName: settings.displayName, icon: settings.icon }; }); localStorage.setItem(LOCALSTORAGE_SETTINGS_KEY, JSON.stringify(settingsToSave)); alert('キャラクター設定を保存しました。'); }
            catch (error) { console.error("Error saving character settings:", error); if (error.name === 'QuotaExceededError') alert('設定の保存に失敗しました。ブラウザの保存容量超過の可能性があります。'); else alert(`設定の保存中にエラー: ${error.message}`); }
        }

        function loadCharacterSettings() {
            if (Object.keys(characterSettings).length === 0) { alert('設定を適用するキャラクターがいません。'); return; }
            try { const savedSettingsJson = localStorage.getItem(LOCALSTORAGE_SETTINGS_KEY); if (!savedSettingsJson) { alert('保存された設定が見つかりません。'); return; }
                const loadedSettings = JSON.parse(savedSettingsJson); let settingsAppliedCount = 0; uploadedFiles = {};
                Object.keys(characterSettings).forEach(speaker => { if (loadedSettings[speaker]) { characterSettings[speaker].displayName = loadedSettings[speaker].displayName; characterSettings[speaker].icon = loadedSettings[speaker].icon || null; settingsAppliedCount++; } else console.log(`Speaker "${speaker}" not in saved settings.`); });
                if (settingsAppliedCount > 0) {
                    updateSpeakerDataForExport();
                    populateCharacterSettingsUI();
                    populateSpeakerFilterUI();
                    renderLog();
                    alert(`${settingsAppliedCount}件の設定を読み込みました。`);
                } else alert('一致する保存設定がありませんでした。');
            } catch (error) { console.error("Error loading character settings:", error); alert(`設定の読み込み中にエラー: ${error.message}`); }
        }

        function populateTabsUI() {
            logTabsNav.innerHTML = '';
            const sortedTabs = ['all', ...[...uniqueTabsFound].sort((a, b) => a.localeCompare(b))];
            if (sortedTabs.length <= 1) { logTabsNav.innerHTML = '<span class="whitespace-nowrap py-3 px-2 text-gray-500 text-sm italic">タブ情報なし</span>'; return; }
            const fragment = document.createDocumentFragment();
            sortedTabs.forEach(tab => {
                const button = document.createElement('button'); button.textContent = `[${escapeHtml(tab)}]`; button.dataset.tab = tab; button.className = `whitespace-nowrap py-3 px-3 border-b-2 font-medium text-sm focus:outline-none focus:ring-2 focus:ring-offset-1 focus:ring-indigo-500 transition-colors duration-150 ease-in-out`;
                const isActive = tab === currentTabFilter; button.classList.toggle('border-indigo-500', isActive); button.classList.toggle('text-indigo-600', isActive); button.classList.toggle('border-transparent', !isActive); button.classList.toggle('text-gray-500', !isActive); button.classList.toggle('hover:text-gray-700', !isActive); button.classList.toggle('hover:border-gray-300', !isActive); button.setAttribute('role', 'tab'); button.setAttribute('aria-selected', isActive ? 'true' : 'false');
                fragment.appendChild(button);
            });
            logTabsNav.appendChild(fragment); logTabsNav.setAttribute('role', 'tablist');
        }

        function populateSpeakerFilterUI() {
            speakerFilterSelect.innerHTML = '<option value="all">すべての発言者</option>';
            // Filter out 'system' speaker before sorting and displaying
            const sortedSpeakers = Object.keys(speakerFrequencies).filter(s => s !== 'system').sort((a, b) => speakerFrequencies[b] - speakerFrequencies[a]);
            if (sortedSpeakers.length === 0) { speakerFilterSelect.disabled = true; return; }
            const fragment = document.createDocumentFragment();
            sortedSpeakers.forEach(speaker => { const option = document.createElement('option'); option.value = escapeCssSelector(speaker); const count = speakerFrequencies[speaker]; const displayName = characterSettings[speaker]?.displayName || speaker; option.textContent = `${escapeHtml(displayName)} (${count}回)`; fragment.appendChild(option); });
            speakerFilterSelect.appendChild(fragment); speakerFilterSelect.value = currentSpeakerFilter === 'all' ? 'all' : escapeCssSelector(currentSpeakerFilter); speakerFilterSelect.disabled = false;
        }

        function handleTabChange(tabName) {
            if (currentTabFilter === tabName) return; console.log(`Switching main display tab to: [${tabName}]`); currentTabFilter = tabName;
            logTabsNav.querySelectorAll('button').forEach(button => { const isActive = button.dataset.tab === tabName; button.classList.toggle('border-indigo-500', isActive); button.classList.toggle('text-indigo-600', isActive); button.classList.toggle('border-transparent', !isActive); button.classList.toggle('text-gray-500', !isActive); button.classList.toggle('hover:text-gray-700', !isActive); button.classList.toggle('hover:border-gray-300', !isActive); button.setAttribute('aria-selected', isActive ? 'true' : 'false'); });
            renderLog();
        }

        function handleSpeakerFilterChange() {
            const selectedValue = speakerFilterSelect.value; const newFilter = selectedValue === 'all' ? 'all' : Object.keys(speakerFrequencies).find(sp => escapeCssSelector(sp) === selectedValue) || 'all';
            if (currentSpeakerFilter === newFilter) return; console.log(`Filtering main display by speaker: ${newFilter}`); currentSpeakerFilter = newFilter; renderLog();
        }

        /** Renders the main log display area based on current filters and customization */
        function renderLog() {
             // Renamed log message variable
             console.log(`   [renderLog] Rendering main display. Tab Filter: ${currentTabFilter}, Speaker Filter: ${currentSpeakerFilter}, NameBelowIcon: ${customizationSettings.nameBelowIconMode}, Font: ${customizationSettings.fontFamily}`);
             const startTime = performance.now();
             logDisplayDiv.innerHTML = ''; // Clear previous content

             // Apply customization settings
             // Font
             FONT_CLASSES.forEach(cls => logDisplayDiv.classList.remove(cls)); // Remove old font classes
             logDisplayDiv.classList.add(customizationSettings.fontFamily); // Add current font class
             // Other styles via CSS variables
             logDisplayDiv.style.fontSize = `${customizationSettings.fontSize}px`;
             logDisplayDiv.style.height = `${customizationSettings.logDisplayHeight}px`; // Set log display height
             logDisplayDiv.style.backgroundColor = customizationSettings.backgroundColor;
             document.body.style.backgroundColor = customizationSettings.backgroundColor; // Sync body background
             logDisplayDiv.style.setProperty('--bubble-max-width', `${customizationSettings.bubbleMaxWidth}%`);
             logDisplayDiv.style.setProperty('--bubble-bg-color', customizationSettings.normalBubbleColor);
             logDisplayDiv.style.setProperty('--bubble-arrow-color', customizationSettings.normalBubbleColor);
             logDisplayDiv.style.setProperty('--icon-size', `${customizationSettings.iconSize}px`); // Apply icon size
             // Name Below Icon mode class 
             logDisplayDiv.classList.toggle('name-below-icon-active', customizationSettings.nameBelowIconMode);

             // Filter data
             let filteredItems = displayLogData.filter(item => {
                 if (item.type === 'error') { return currentTabFilter === 'all' && currentSpeakerFilter === 'all'; }
                 if (item.type === 'image') {
                     const precedingMessage = findPrecedingMessage(item.afterOriginalIndex);
                     if (!precedingMessage) return currentTabFilter === 'all' && currentSpeakerFilter === 'all';
                     const tabMatch = currentTabFilter === 'all' || (precedingMessage.tab || 'main') === currentTabFilter;
                     const speakerMatch = currentSpeakerFilter === 'all' || precedingMessage.speaker === currentSpeakerFilter;
                     return tabMatch && speakerMatch;
                 }
                 // Ensure message items have a displayMode, default if missing
                 if (item.type === 'message' && !item.displayMode) {
                     item.displayMode = 'bubble';
                 }
                 const tabMatch = currentTabFilter === 'all' || (item.tab || 'main') === currentTabFilter;
                 const speakerMatch = currentSpeakerFilter === 'all' || item.speaker === currentSpeakerFilter;
                 return tabMatch && speakerMatch;
             });

             // Sort data
             const dataToSort = filteredItems.map(item => ({ ...item, sortIndex: item.type === 'image' ? (item.afterOriginalIndex ?? -1) + 0.5 : (item.originalIndex ?? -1) })).sort((a, b) => a.sortIndex - b.sortIndex);
             console.log(`   [renderLog] Filtered/Sorted down to ${dataToSort.length} items to render.`);

             if (dataToSort.length === 0) {
                 logDisplayDiv.innerHTML = '<p class="text-gray-500 text-center italic">表示するログがありません。(フィルタ条件を確認してください)</p>';
                 const endTime = performance.now(); console.log(`   [renderLog] Rendered empty log in ${endTime - startTime} ms.`);
                 return;
             }

             // Create and append elements
             const fragment = document.createDocumentFragment();
             dataToSort.forEach((item, index) => {
                 try {
                     // Add tab separator if needed
                     const isMultiTabView = currentTabFilter === 'all';
                     if (isMultiTabView && item.type === 'message' && index > 0) {
                         let prevMessageItem = null;
                         for (let j = index - 1; j >= 0; j--) { if (dataToSort[j].type === 'message') { prevMessageItem = dataToSort[j]; break; } }
                         if (prevMessageItem && (item.tab || 'main') !== (prevMessageItem.tab || 'main')) {
                             const separator = document.createElement('hr'); separator.className = 'tab-separator'; fragment.appendChild(separator);
                         }
                     }

                     let element;
                     if (item.type === 'message') { element = createMessageElement(item); }
                     else if (item.type === 'image') { element = createInsertedImageElement(item); }
                     else if (item.type === 'error') { element = createErrorElement(item); }

                     if (element) fragment.appendChild(element);
                 } catch (elementError) {
                     console.error(`   [renderLog] Error creating element for item (ID: ${item.id}, Index: ${index}):`, elementError, item);
                     const errorDiv = document.createElement('div'); errorDiv.className = 'p-2 my-1 bg-red-100 border border-red-400 text-red-700 rounded text-sm';
                     errorDiv.textContent = `表示エラー: ${item.type === 'message' ? `メッセージ(${escapeHtml(item.speaker || '不明')})` : (item.type === 'image' ? '画像' : '不明なアイテム')} の表示中に問題が発生しました。`;
                     fragment.appendChild(errorDiv);
                 }
             });

             logDisplayDiv.appendChild(fragment);
             const endTime = performance.now(); console.log(`   [renderLog] Rendered ${dataToSort.length} items in ${endTime - startTime} ms.`);
        }

        function findPrecedingMessage(originalIndex) {
            // Search backwards in displayLogData first (more likely)
            for (let i = displayLogData.length - 1; i >= 0; i--) {
                if (displayLogData[i].type === 'message' && displayLogData[i].originalIndex === originalIndex) {
                    return displayLogData[i];
                }
            }
            // Fallback to originalLogData if not found (e.g., message was deleted)
            for (let i = originalLogData.length - 1; i >= 0; i--) {
                if (originalLogData[i].type === 'message' && originalLogData[i].originalIndex === originalIndex) {
                    return originalLogData[i];
                }
            }
            console.warn(`Could not find preceding message for originalIndex: ${originalIndex}`); return null;
        }

        /** Creates the HTML element for a single message log item, handling display modes */
        function createMessageElement(logItem) {
            if (!logItem || logItem.type !== 'message') return null;

            const container = document.createElement('div');
            container.className = 'message-item'; // Base class
            container.dataset.itemId = logItem.id;
            container.dataset.tab = logItem.tab || 'main';
            container.dataset.speaker = logItem.speaker || '不明';
            // Ensure displayMode exists, default to 'bubble'
            const currentDisplayMode = logItem.displayMode || 'bubble';
            container.dataset.displayMode = currentDisplayMode;

            const setting = characterSettings[logItem.speaker] || { displayName: logItem.speaker, icon: null };
            const iconSizePx = `var(--icon-size)`; // Use CSS variable directly

            // --- Bubble Mode Elements ---
            const bubbleContainer = document.createElement('div');
            bubbleContainer.className = 'message-container'; // Flex container for bubble

            const iconContainer = document.createElement('div');
            iconContainer.className = 'icon-container';
            // Width/Height set by CSS variable via parent style
            const iconImg = document.createElement('img');
            const placeholderSrc = PLACEHOLDER_ICON_URL.replace('64x64', '40x40'); // Placeholder size doesn't need variable
            iconImg.src = setting.icon || placeholderSrc; iconImg.alt = `${setting.displayName} icon`;
            iconImg.className = 'w-full h-full rounded-full object-cover icon-border bg-gray-200';
            iconImg.style.borderColor = logItem.color || '#000000'; iconImg.loading = 'lazy';
            iconImg.style.objectPosition = '50% 0%'; // Set object-position to top-center
            iconImg.onerror = (e) => { if (e.target.src !== placeholderSrc) e.target.src = placeholderSrc; };
            iconContainer.appendChild(iconImg);

            const nameBelowIconSpan = document.createElement('span');
            nameBelowIconSpan.className = 'speaker-name-below-icon';
            nameBelowIconSpan.textContent = escapeHtml(setting.displayName);
            iconContainer.appendChild(nameBelowIconSpan);
            bubbleContainer.appendChild(iconContainer);

            const contentContainer = document.createElement('div');
            contentContainer.className = 'content-container';
            const speakerNameSpan = document.createElement('span');
            speakerNameSpan.className = 'speaker-name-default';
            speakerNameSpan.innerHTML = `${escapeHtml(setting.displayName)} <span class="text-xs font-normal text-gray-500">[${escapeHtml(logItem.tab || 'main')}]</span>`;

            const tabBelowIconSpan = document.createElement('span');
            tabBelowIconSpan.className = 'tab-name-below-icon';
            tabBelowIconSpan.textContent = `[${escapeHtml(logItem.tab || 'main')}]`;

            const bubbleDiv = document.createElement('div');
            bubbleDiv.className = 'bubble bubble-left bubble-normal';
            bubbleDiv.innerHTML = logItem.message;
            contentContainer.appendChild(speakerNameSpan);
            contentContainer.appendChild(tabBelowIconSpan); 
            contentContainer.appendChild(bubbleDiv);
            const actionButtonContainer = document.createElement('div');
            actionButtonContainer.className = 'action-button-container';
            const insertButton = document.createElement('button');
            insertButton.textContent = '画像挿入'; insertButton.className = 'action-button action-button-insert';
            insertButton.onclick = () => triggerImageInsert(logItem.originalIndex);
            actionButtonContainer.appendChild(insertButton);
            // Removed edit button for bubble
            const deleteButtonBubble = createDeleteButton(logItem.id, 'メッセージ');
            actionButtonContainer.appendChild(deleteButtonBubble);
            // Make bubble editable
            bubbleDiv.contentEditable = "true";
            bubbleDiv.dataset.itemId = logItem.id; // Add itemId for blur event
            bubbleDiv.addEventListener('blur', handleMessageEdit);

            contentContainer.appendChild(actionButtonContainer);
            bubbleContainer.appendChild(contentContainer);
            container.appendChild(bubbleContainer);

            // --- Narration Mode Elements ---
            const narrationContainer = document.createElement('div');
            narrationContainer.className = 'narration-container';
            const narrationTab = document.createElement('span');
            narrationTab.className = 'narration-tab'; // Class for potential styling/hiding
            narrationTab.textContent = `[${escapeHtml(logItem.tab || 'main')}]`;
            const narrationSpeaker = document.createElement('span');
            narrationSpeaker.className = 'narration-speaker'; // Class for potential styling/hiding
            narrationSpeaker.textContent = `${escapeHtml(setting.displayName)}:`;
            const narrationMessage = document.createElement('span');
            narrationMessage.className = 'narration-message';
            narrationMessage.innerHTML = logItem.message;
            // Make narration message editable
            narrationMessage.contentEditable = "true";
            narrationMessage.dataset.itemId = logItem.id; // Add itemId for blur event
            narrationMessage.addEventListener('blur', handleMessageEdit);

            narrationContainer.appendChild(narrationTab); // Always add, CSS will hide if needed
            narrationContainer.appendChild(narrationSpeaker); // Always add, CSS will hide if needed
            narrationContainer.appendChild(narrationMessage);
            const narrationActionButtonContainer = document.createElement('div'); // Container for narration buttons
            narrationActionButtonContainer.style.display = 'inline-block'; // Keep buttons on the same line
            narrationActionButtonContainer.style.marginLeft = '10px';
            // Removed edit button for narration
            const narrationDeleteButton = createDeleteButton(logItem.id, 'メッセージ');
            narrationActionButtonContainer.appendChild(narrationDeleteButton);
            narrationContainer.appendChild(narrationActionButtonContainer); // Add button container
            container.appendChild(narrationContainer);

            // --- Display Mode Toggle Button ---
            const toggleButton = document.createElement('button');
            toggleButton.className = 'display-mode-toggle';
            toggleButton.title = '表示モード切替 (フキダシ/描写)';
            toggleButton.textContent = (currentDisplayMode === 'narration') ? '💬' : '📝'; // Use clearer icons
            toggleButton.onclick = () => toggleMessageDisplayMode(logItem.id);
            container.appendChild(toggleButton); // Append directly to the main container

            return container;
        }

        /** Toggles the display mode of a specific message */
        function toggleMessageDisplayMode(itemId) {
            const itemIndex = displayLogData.findIndex(item => item.id === itemId && item.type === 'message');
            if (itemIndex === -1) {
                console.error(`Message item with ID ${itemId} not found in displayLogData.`);
                return;
            }
            const currentMode = displayLogData[itemIndex].displayMode || 'bubble';
            const newMode = (currentMode === 'bubble') ? 'narration' : 'bubble';
            displayLogData[itemIndex].displayMode = newMode;
            console.log(`Toggled display mode for ${itemId} to ${newMode}.`);

            // Update the specific element in the DOM
            const elementToUpdate = logDisplayDiv.querySelector(`.message-item[data-item-id="${itemId}"]`);
            if (elementToUpdate) {
                elementToUpdate.dataset.displayMode = newMode; // Update data attribute for CSS styling
                const toggleButton = elementToUpdate.querySelector('.display-mode-toggle');
                if (toggleButton) {
                    toggleButton.textContent = (newMode === 'narration') ? '💬' : '📝'; // Update button icon
                }
                console.log(`Updated DOM for ${itemId} to display mode: ${newMode}`);
            } else {
                console.warn(`Element for ${itemId} not found in DOM, full re-render might be needed if issues arise.`);
                // Optionally trigger full renderLog() here if partial update fails often
            }
        }


        function createInsertedImageElement(imageItem) {
            if (!imageItem || imageItem.type !== 'image') return null;
            const container = document.createElement('div'); container.className = 'inserted-image-container my-2 image-item'; container.dataset.itemId = imageItem.id;
            const precedingMessage = findPrecedingMessage(imageItem.afterOriginalIndex);
            container.dataset.tab = precedingMessage?.tab || 'main'; container.dataset.speaker = precedingMessage?.speaker || '不明';
            const img = document.createElement('img'); img.src = imageItem.src; img.alt = imageItem.caption ? escapeHtml(imageItem.caption) : `挿入画像 (ID: ${imageItem.id})`; img.className = 'inserted-image'; img.loading = 'lazy';
            img.onerror = (e) => { console.error(`Failed to load inserted image: ${e.target.src}`); container.innerHTML = `<p class="text-red-500 text-xs text-center font-semibold">[画像(ID: ${escapeHtml(imageItem.id)})の読み込みに失敗しました]</p>`; const deleteBtn = createDeleteButton(imageItem.id, '画像'); container.appendChild(deleteBtn); };
            container.appendChild(img);
            if (imageItem.caption) { const captionP = document.createElement('p'); captionP.className = 'image-caption'; captionP.textContent = imageItem.caption; container.appendChild(captionP); }
            const actionButtonContainer = document.createElement('div'); actionButtonContainer.className = 'action-button-container justify-center'; // Center buttons under image
            const editCaptionButton = document.createElement('button'); editCaptionButton.textContent = '説明編集'; editCaptionButton.className = 'action-button action-button-edit'; editCaptionButton.onclick = () => editImageCaption(imageItem.id); actionButtonContainer.appendChild(editCaptionButton);
            const deleteButton = createDeleteButton(imageItem.id, '画像'); actionButtonContainer.appendChild(deleteButton); container.appendChild(actionButtonContainer);
            return container;
        }

        function createErrorElement(errorItem) {
            if (!errorItem || errorItem.type !== 'error') return null;
            const errorDiv = document.createElement('div'); errorDiv.className = 'p-2 my-1 bg-yellow-100 border border-yellow-400 text-yellow-800 rounded text-sm error-item'; errorDiv.dataset.itemId = errorItem.id;
            errorDiv.dataset.tab = 'all'; errorDiv.dataset.speaker = 'all';
            errorDiv.innerHTML = `<strong>解析エラー:</strong> ${escapeHtml(errorItem.message)}<br><small class="text-gray-600">内容: ${escapeHtml(errorItem.details)}...</small>`;
            const deleteButton = createDeleteButton(errorItem.id, 'エラー表示');
            const buttonContainer = document.createElement('div'); buttonContainer.className = 'mt-1'; buttonContainer.appendChild(deleteButton); errorDiv.appendChild(buttonContainer);
            return errorDiv;
        }

        function createDeleteButton(itemId, itemTypeLabel = 'アイテム') {
            const deleteButton = document.createElement('button'); deleteButton.textContent = '削除'; deleteButton.className = 'action-button action-button-delete'; deleteButton.onclick = () => deleteSingleItem(itemId); deleteButton.setAttribute('aria-label', `${itemTypeLabel} (ID: ${itemId}) を削除`);
            return deleteButton;
        }

        // Removed createEditButton function

        function triggerImageInsert(afterIndex) { console.log(`Triggering image insert after originalIndex: ${afterIndex}`); if (typeof afterIndex !== 'number' || afterIndex < 0) { console.error("Invalid index for image insertion."); return; } imageInsertTargetIndex = afterIndex; insertImageInput.click(); }

        async function handleInsertImageFile(event) {
            const file = event.target.files?.[0]; const targetIndex = imageInsertTargetIndex;
            imageInsertTargetIndex = -1; if (event.target) event.target.value = null;
            if (!file) { console.log("No file selected."); return; }
            if (targetIndex < 0) { console.error("Invalid image insertion target index."); return; }
            if (!file.type.startsWith('image/')) { alert('画像ファイルのみ挿入できます。'); return; }
            const maxSize = 10 * 1024 * 1024; if (file.size > maxSize) { alert(`ファイルサイズ超過 (${(file.size / 1024 / 1024).toFixed(1)}MB)。10MB以下にしてください。`); return; }
            const caption = ""; // Insert with empty caption initially
            showLoading();
            try {
                const dataUrl = await readFileAsDataURL(file); const imageId = generateUniqueId('img');
                const newImageEntry = { type: 'image', id: imageId, src: dataUrl, afterOriginalIndex: targetIndex, caption: caption, file: file };
                let insertPos = -1;
                for (let i = displayLogData.length - 1; i >= 0; i--) { const item = displayLogData[i]; if ((item.type === 'message' && item.originalIndex === targetIndex) || (item.type === 'image' && item.afterOriginalIndex === targetIndex)) { insertPos = i + 1; break; } }
                if (insertPos === -1) { insertPos = displayLogData.length; console.warn(`Target message index ${targetIndex} not found in current display. Appending image.`); }
                displayLogData.splice(insertPos, 0, newImageEntry);
                uploadedFiles[imageId] = file;
                console.log(`Image ${imageId} inserted (no caption prompt). Re-rendering.`);
                renderLog();
            } catch (error) { console.error("Error inserting image:", error); alert(`画像の挿入中にエラー: ${error.message}`); }
            finally { hideLoading(); }
        }

        function editImageCaption(itemId) {
            const imageItemIndex = displayLogData.findIndex(item => item.id === itemId && item.type === 'image');
            if (imageItemIndex === -1) { alert("キャプション編集対象の画像が見つかりません。"); return; }
            const currentCaption = displayLogData[imageItemIndex].caption || ""; const newCaption = prompt("画像の説明文（キャプション）を編集してください:", currentCaption);
            if (newCaption !== null) { displayLogData[imageItemIndex].caption = newCaption.trim(); console.log(`Caption for image ${itemId} updated. Re-rendering.`); renderLog(); }
            else console.log(`Caption edit cancelled for image ${itemId}.`);
        }

        function deleteSingleItem(itemId) {
             if (!itemId) { console.warn("Invalid ID for deletion."); return; }
             const confirmation = confirm(`ID: ${itemId} のアイテムを削除しますか？ (元に戻せません)`);
             if (!confirmation) { console.log(`Deletion cancelled for ${itemId}.`); return; }
             const indexToDelete = displayLogData.findIndex(item => item.id === itemId);
             if (indexToDelete !== -1) {
                 const itemToDelete = displayLogData[indexToDelete]; console.log(`Deleting item ${itemId} (Type: ${itemToDelete.type}) from displayLogData.`); displayLogData.splice(indexToDelete, 1);
                 if (itemToDelete.type === 'image' && uploadedFiles[itemId]) { delete uploadedFiles[itemId]; console.log(`Removed file cache for image ${itemId}.`); }
                 // Optimization: Remove element directly instead of full re-render
                 const elementToRemove = logDisplayDiv.querySelector(`[data-item-id="${itemId}"]`);
                 if (elementToRemove) {
                     elementToRemove.remove();
                     console.log(`Removed element ${itemId} from DOM.`);
                 } else {
                     renderLog(); // Fallback if element not found
                 }
             } else { console.warn(`Item ${itemId} not found for deletion.`); alert('削除対象が見つかりません。'); }
         }

        /** Handles saving the edited message content when focus is lost */
        function handleMessageEdit(event) {
            const editedElement = event.target;
            const itemId = editedElement.dataset.itemId;
            const newContent = editedElement.innerHTML; // Use innerHTML to preserve formatting

            if (!itemId) {
                console.error("Missing item ID on edited element:", editedElement);
                return;
            }

            const itemIndex = displayLogData.findIndex(item => item.id === itemId && item.type === 'message');
            if (itemIndex === -1) {
                console.error(`Message item with ID ${itemId} not found in displayLogData for saving edit.`);
                // Optionally revert the change in the DOM here
                // editedElement.innerHTML = originalContent; // Need to store original content somewhere if revert is needed
                return;
            }

            // Save the change if content is different
            if (displayLogData[itemIndex].message !== newContent) {
                displayLogData[itemIndex].message = newContent;
                console.log(`Message ${itemId} content updated via inline edit.`);
                // No need to re-render, the DOM is already updated.
                // If other parts of the app depend on this data, update them here.
            } else {
                console.log(`Message ${itemId} content unchanged.`);
            }
        }

        // Removed editMessageContent function

         // --- Customization Functions ---
        function applyCustomization() {
            try {
                customizationSettings.normalBubbleColor = normalColorInput.value;
                customizationSettings.fontSize = parseInt(fontSizeSlider.value, 10) || 16;
                customizationSettings.backgroundColor = backgroundColorInput.value;
                customizationSettings.iconSize = parseInt(iconSizeSlider.value, 10) || 64; // Use updated default
                customizationSettings.bubbleMaxWidth = parseInt(bubbleWidthSlider.value, 10) || 80;
                customizationSettings.nameBelowIconMode = nameBelowIconToggle.checked; // Renamed variable and element ID
                customizationSettings.fontFamily = fontFamilySelect.value; // Get selected font
                customizationSettings.logDisplayHeight = parseInt(logHeightSlider.value, 10) || 384; // Get log height
                saveCustomization();
                renderLog(); // Re-render with all new settings
                alert('表示カスタマイズを適用しました。');
            } catch (error) { console.error("Error applying customization:", error); alert(`カスタマイズ適用エラー: ${error.message}`); }
        }
        function resetCustomization() {
            resetCustomizationDefaults(); // Reset state object
            updateCustomizationUI(); // Update UI
            applyCustomization(); // Apply and re-render (will use defaults)
            alert('表示カスタマイズをリセットしました。');
        }
        function updateCustomizationUI() {
            try {
                normalColorInput.value = customizationSettings.normalBubbleColor;
                fontSizeSlider.value = customizationSettings.fontSize;
                fontSizeValueSpan.textContent = customizationSettings.fontSize;
                backgroundColorInput.value = customizationSettings.backgroundColor;
                iconSizeSlider.value = customizationSettings.iconSize; // Set icon size slider
                iconSizeValueSpan.textContent = customizationSettings.iconSize; // Set icon size value display
                bubbleWidthSlider.value = customizationSettings.bubbleMaxWidth;
                bubbleWidthValueSpan.textContent = customizationSettings.bubbleMaxWidth;
                nameBelowIconToggle.checked = customizationSettings.nameBelowIconMode; // Renamed variable and element ID
                fontFamilySelect.value = customizationSettings.fontFamily; // Set font dropdown
                logHeightSlider.value = customizationSettings.logDisplayHeight; // Set log height slider
                logHeightValueSpan.textContent = customizationSettings.logDisplayHeight; // Set log height value display
             } catch (error) { console.error("Error updating customization UI:", error); }
         }
        function saveCustomization() { try { localStorage.setItem(LOCALSTORAGE_CUSTOMIZATION_KEY, JSON.stringify(customizationSettings)); } catch (error) { console.error("Error saving customization settings:", error); } }
        function loadCustomization() {
            try {
                const savedJson = localStorage.getItem(LOCALSTORAGE_CUSTOMIZATION_KEY);
                if (savedJson) {
                    const loaded = JSON.parse(savedJson);
                    customizationSettings.normalBubbleColor = loaded.normalBubbleColor || '#ffffff';
                    customizationSettings.fontSize = parseInt(loaded.fontSize, 10) || 16;
                    customizationSettings.backgroundColor = loaded.backgroundColor || '#f3f4f6';
                    customizationSettings.iconSize = parseInt(loaded.iconSize, 10) || 64; // Load icon size, default 64
                    customizationSettings.bubbleMaxWidth = parseInt(loaded.bubbleMaxWidth, 10) || 80;
                    // Load renamed setting, fall back to old name if necessary for backward compatibility (optional)
                    customizationSettings.nameBelowIconMode = loaded.nameBelowIconMode === true || loaded.omokoroMode === true;
                    customizationSettings.fontFamily = loaded.fontFamily || 'font-noto-sans'; // Load font
                } else {
                     resetCustomizationDefaults(); // Reset if loading fails
                }
                // Load log display height
                customizationSettings.logDisplayHeight = parseInt(loaded.logDisplayHeight, 10) || 384;
             } catch (error) {
                console.error("Error loading customization settings:", error);
                resetCustomizationDefaults(); // Reset if loading fails
                resetCustomizationDefaults();
                localStorage.removeItem(LOCALSTORAGE_CUSTOMIZATION_KEY);
            }
        }
        function resetCustomizationDefaults() {
             customizationSettings = {
                 normalBubbleColor: '#ffffff', fontSize: 16, backgroundColor: '#f3f4f6',
                 iconSize: 64, bubbleMaxWidth: 80, nameBelowIconMode: false, fontFamily: 'font-noto-sans', // Renamed variable
                 logDisplayHeight: 384 // Added default log height
             };
         }

        // --- Export Functions ---
        async function handleExportZip() {
            const htmlTitle = exportHtmlTitleInput.value.trim() || logFileNameBase || 'ccfolia_log_export';
            const zipFilenameBase = exportZipFilenameInput.value.trim() || logFileNameBase || 'ccfolia_log_export';
            const zipFilename = `${zipFilenameBase}.zip`;

            // Include displayMode in exported data
            const itemsToExport = displayLogData.map(item => {
                 if (item.type === 'message') {
                     return {
                         type: item.type, id: item.id, originalIndex: item.originalIndex,
                         tab: item.tab, speaker: item.speaker, color: item.color,
                         message: item.message, displayMode: item.displayMode || 'bubble'
                     };
                 } else if (item.type === 'image') {
                     return {
                         type: item.type, id: item.id, afterOriginalIndex: item.afterOriginalIndex,
                         caption: item.caption
                     };
                 } else if (item.type === 'error') {
                     return {
                         type: item.type, id: item.id, originalIndex: item.originalIndex,
                         message: item.message, details: item.details
                     };
                 }
                 return null;
            }).filter(item => item !== null);


            const sortedExportData = itemsToExport
                .map(item => ({ ...item, sortIndex: item.type === 'image' ? (item.afterOriginalIndex ?? -1) + 0.5 : (item.originalIndex ?? -1) }))
                .sort((a, b) => a.sortIndex - b.sortIndex);

            if (sortedExportData.length === 0) { alert('エクスポートするデータがありません。'); return; }
            // JSZip is loaded via CDN in the main tool, check if it exists
            if (typeof JSZip === 'undefined') {
                 alert('ZIP作成ライブラリ(JSZip)の読み込みに失敗しました。ページを再読み込みしてみてください。');
                 console.error("JSZip library not found.");
                 return;
            }
            console.log(`[${new Date().toISOString()}] Starting ZIP export of ${sortedExportData.length} items...`);
            console.log(`   [ZIP Export] HTML Title: "${htmlTitle}", ZIP Filename: "${zipFilename}"`);
            showLoading();
            try {
                const zip = new JSZip();

                // 1. Generate CSS
                const outputCss = generateOutputCss(customizationSettings);
                zip.file("style.css", outputCss);

                // 2. Generate Filter JS (no JSZip needed here)
                const filterScriptContent = generateEmbeddedJsForExport(speakerDataForExport);

                // 3. Generate HTML (links to local CSS, embeds filter JS)
                const outputHtml = generateOutputHtml(sortedExportData, uniqueTabsFound, speakerDataForExport, htmlTitle, customizationSettings, filterScriptContent); // Pass JS content
                zip.file("log_export.html", outputHtml);


                // 4. Add Images
                console.log("   [ZIP Export] Adding images...");
                const imgFolder = zip.folder("images"); if (!imgFolder) throw new Error("Failed to create 'images' folder.");
                let iconCount = 0; let insertedImageCount = 0; const addedFiles = new Set();
                for (const [fileIdOrSpeaker, fileObject] of Object.entries(uploadedFiles)) {
                    if (!(fileObject instanceof File)) continue;
                    let outputFilename;
                    const fileExtension = fileObject.name.split('.').pop()?.toLowerCase() || 'png';
                    // Use fileIdOrSpeaker directly for filename base, replacing invalid characters
                    const safeFilenameBase = fileIdOrSpeaker.replace(/[\\/:*?"<>|]/g, '_');

                    if (fileIdOrSpeaker.startsWith('img_')) { // Inserted image
                        outputFilename = `${safeFilenameBase}.${fileExtension}`;
                        insertedImageCount++;
                    } else { // Speaker icon
                        // Use the original speaker name (which is the key) for the icon filename
                        outputFilename = `${safeFilenameBase}_icon.${fileExtension}`;
                        iconCount++;
                    }

                    if (!addedFiles.has(outputFilename)) {
                        try {
                            imgFolder.file(outputFilename, fileObject);
                            addedFiles.add(outputFilename);
                        } catch (zipAddError) {
                            console.error(`Error adding ${outputFilename} to ZIP:`, zipAddError);
                        }
                    } else {
                        console.warn(`Duplicate filename skipped: ${outputFilename}`);
                    }
                }
                console.log(`   [ZIP Export] Added ${iconCount} icons, ${insertedImageCount} inserted images.`);

                // 5. Generate and Download ZIP
                console.log("   [ZIP Export] Generating ZIP blob...");
                const zipBlob = await zip.generateAsync({ type: "blob", compression: "DEFLATE", compressionOptions: { level: 6 } });
                console.log(`   [ZIP Export] ZIP blob generated (Size: ${(zipBlob.size / 1024).toFixed(1)} KB).`);
                const downloadUrl = URL.createObjectURL(zipBlob); const link = document.createElement('a'); link.href = downloadUrl;
                link.download = zipFilename;
                document.body.appendChild(link); link.click(); document.body.removeChild(link); setTimeout(() => URL.revokeObjectURL(downloadUrl), 2000);
                console.log(`[${new Date().toISOString()}] ZIP export complete.`);
                alert(`エクスポート完了。\nファイル名: ${link.download}\n(HTML: 1, CSS: 1, アイコン: ${iconCount}, 挿入画像: ${insertedImageCount})`); // Updated count
            } catch (error) { console.error(`[${new Date().toISOString()}] Error during ZIP export:`, error); alert(`ZIPエクスポートエラー: ${error.message}`); }
            finally { hideLoading(); }
        }

        /** Generates the HTML content for the exported log file */
        function generateOutputHtml(dataForExport, uniqueTabs, speakerData, htmlTitle, currentCustomization, embeddedJsContent) { // Added embeddedJsContent param
            console.log("   [generateOutputHtml] Generating HTML for export...");
            // Renamed variable
            const { iconSize, nameBelowIconMode, fontFamily } = currentCustomization;
            let logBodyContent = '';
            let previousMessageTab = null;

            dataForExport.forEach((item, index) => {
                try {
                    // Add Separator Logic (only in multi-tab view, handled by JS filter)
                    if (item.type === 'message' && index > 0) { let prevMessageItem = null; for (let j = index - 1; j >= 0; j--) { if (dataForExport[j].type === 'message') { prevMessageItem = dataForExport[j]; break; } } if (prevMessageItem && (item.tab || 'main') !== (prevMessageItem.tab || 'main')) logBodyContent += '<hr class="tab-separator export">\n'; }

                    if (item.type === 'message') {
                        const setting = characterSettings[item.speaker] || { displayName: item.speaker, icon: null }; const speakerName = setting.displayName; const originalSpeaker = item.speaker; let iconRelativePath = ''; let hasUploadedIcon = false;
                        // Use originalSpeaker directly for filename lookup in uploadedFiles and path generation
                        if (uploadedFiles[originalSpeaker] instanceof File) {
                            const file = uploadedFiles[originalSpeaker];
                            const fileExtension = file.name.split('.').pop()?.toLowerCase() || 'png';
                            const safeSpeakerFilenameBase = originalSpeaker.replace(/[\\/:*?"<>|]/g, '_'); // Use original speaker name for file path
                            iconRelativePath = `images/${safeSpeakerFilenameBase}_icon.${fileExtension}`;
                            hasUploadedIcon = true;
                        }
                        const iconBorderColor = item.color || '#000000';
                        const messageHtmlContent = item.message; const escapedSpeakerName = escapeHtml(speakerName); const placeholderDisplay = hasUploadedIcon ? 'none' : 'inline-block'; const imageDisplay = hasUploadedIcon ? 'block' : 'none'; const iconContainerStyle = `width: ${iconSize}px; height: ${iconSize}px;`; const placeholderChar = escapedSpeakerName.charAt(0) || '?'; const placeholderLineHeight = Math.round(iconSize * 0.9); const placeholderFontSize = Math.round(iconSize * 0.5); const tabDisplay = escapeHtml(item.tab || 'main');
                        const displayMode = item.displayMode || 'bubble'; // Get display mode

                        // Removed comments { /* Renamed class */ } from the template literal below
                        logBodyContent += `
<div class="message-item export log-item" data-tab="${escapeHtml(item.tab || 'main')}" data-speaker="${escapeHtml(originalSpeaker)}" data-display-mode="${displayMode}">
    <div class="message-container export">
        <div class="icon-container export" style="${iconContainerStyle}">
            <img src="${iconRelativePath}" alt="${escapedSpeakerName}" class="icon export" style="border-color: ${iconBorderColor}; display: ${imageDisplay};" onerror="this.style.display='none'; this.nextElementSibling.style.display='inline-block';">
            <span class="icon-placeholder export" style="display: ${placeholderDisplay}; border-color: ${iconBorderColor}; line-height: ${placeholderLineHeight}px; font-size: ${placeholderFontSize}px;">${placeholderChar}</span>
            <span class="speaker-name-below-icon export">${escapedSpeakerName}</span>
        </div>
        <div class="content-container export">
            <span class="speaker-name-default export">${escapedSpeakerName} <span class="original-tab export">[${tabDisplay}]</span></span>
            <span class="tab-name-below-icon export">[${tabDisplay}]</span>
            <div class="bubble export bubble-left export bubble-normal export">
                ${messageHtmlContent}
            </div>
        </div>
    </div>
    <div class="narration-container export">
        <span class="narration-tab">[${tabDisplay}]</span>
        <span class="narration-speaker">${escapedSpeakerName}:</span>
        <span class="narration-message">${messageHtmlContent}</span>
    </div>
    </div>\n`; // Removed toggle button from export
                    } else if (item.type === 'image') {
                        let imageRelativePath = ''; let hasUploadedImage = false; const imageId = item.id;
                        if (uploadedFiles[imageId] instanceof File) { const file = uploadedFiles[imageId]; const fileExtension = file.name.split('.').pop()?.toLowerCase() || 'png'; const safeImageName = imageId.replace(/[^a-z0-9_-]/gi, '_').toLowerCase(); imageRelativePath = `images/${safeImageName}.${fileExtension}`; hasUploadedImage = true; }
                        const imageAlt = item.caption ? escapeHtml(item.caption) : `挿入画像 ${imageId}`;
                        const precedingMsg = findPrecedingMessage(item.afterOriginalIndex);
                        const imgTab = precedingMsg?.tab || 'main';
                        const imgSpeaker = precedingMsg?.speaker || '不明';
                        logBodyContent += `
<div class="inserted-image-container export log-item" data-tab="${escapeHtml(imgTab)}" data-speaker="${escapeHtml(imgSpeaker)}">
    <img src="${imageRelativePath}" alt="${imageAlt}" class="inserted-image export" ${hasUploadedImage ? '' : 'style="display:none;"'} onerror="this.style.display='none'; const p=document.createElement('p'); p.className='image-error-placeholder export'; p.textContent='[画像 ${escapeHtml(imageId)} 読込失敗]'; this.parentNode.appendChild(p);">
    ${!hasUploadedImage ? `<p class="image-error-placeholder export">[画像 ${escapeHtml(imageId)} ファイル不明]</p>` : ''}`;
                        if (item.caption) { logBodyContent += `\n    <p class="image-caption export">${escapeHtml(item.caption)}</p>`; }
                        logBodyContent += `\n</div>\n`;
                    } else if (item.type === 'error') {
                         logBodyContent += `
<div class="error-message export log-item" data-tab="all" data-speaker="all">
    <strong>解析エラー:</strong> ${escapeHtml(item.message)}<br>
    <small>詳細: ${escapeHtml(item.details)}...</small>
</div>\n`;
                    }
                } catch (htmlGenError) { console.error(`Error generating HTML for item ID ${item.id}:`, htmlGenError); logBodyContent += `<div class="export-error">アイテム(ID: ${item.id})のHTML生成エラー</div>\n`; }
            });

            let filterControlsHtml = `
<div class="filter-controls export">
    <div class="filter-section">
        <label for="export-tab-filter">タブ:</label>
        <nav id="export-log-tabs" class="tab-nav export" aria-label="Log Tabs">
            <span class="placeholder">読み込み中...</span>
        </nav>
    </div>
    <div class="filter-section">
        <label for="export-speaker-filter">発言者:</label>
        <select id="export-speaker-filter" class="speaker-filter export">
            <option value="all">すべての発言者</option>
            </select>
    </div>
</div>`;

            const safeHtmlTitle = escapeHtml(htmlTitle);
            // Renamed body class variable
            const nameBelowIconBodyClass = nameBelowIconMode ? 'name-below-icon-active' : '';
            const fontBodyClass = fontFamily || 'font-noto-sans'; // Get font class

            // Link to local CSS, embed JS directly
            return `<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${safeHtmlTitle}</title>
    <link rel="stylesheet" href="style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Noto+Sans+JP:wght@400;700&family=Noto+Serif+JP:wght@400;700&family=M+PLUS+Rounded+1c:wght@400;700&display=swap" rel="stylesheet">
</head>
<body class="${nameBelowIconBodyClass} ${fontBodyClass}"> 
    <div class="log-export-container">
        <h1>${safeHtmlTitle}</h1>
        ${filterControlsHtml}
        <div id="export-log-display" class="log-display export">
            ${logBodyContent || '<p class="empty-log-message export">ログデータがありません。</p>'}
        </div>
    </div>
    <script>
        ${embeddedJsContent} /* Embed the filter JS */
    <\/script>
</body>
</html>`;
        }

        /** Generates the JavaScript code to be embedded in the exported HTML */
        function generateEmbeddedJsForExport(speakerDisplayNameMap) {
            const speakerMapString = JSON.stringify(speakerDisplayNameMap || {});
            // JSZip is no longer included here

            return `
// --- Filter Script ---
(function() {
    "use strict";
    console.log("Exported Log Filter Script Initializing...");

    let currentExportTab = 'all';
    let currentExportSpeaker = 'all';
    const speakerDisplayNames = ${speakerMapString};

    const exportLogTabsNav = document.getElementById('export-log-tabs');
    const exportSpeakerFilter = document.getElementById('export-speaker-filter');
    const exportLogDisplay = document.getElementById('export-log-display');
    const allLogItems = exportLogDisplay ? Array.from(exportLogDisplay.querySelectorAll('.log-item')) : [];

    if (!exportLogTabsNav || !exportSpeakerFilter || !exportLogDisplay || allLogItems.length === 0) {
        console.error("Required elements for filtering not found in exported HTML or no log items found.");
        return;
    }

    function initializeExportFilters() {
        console.log('Found ' + allLogItems.length + ' log items to filter.');
        const uniqueTabs = new Set(['all']);
        const uniqueSpeakers = new Set(['all']);
        const speakerCounts = {};

        allLogItems.forEach(item => {
            const tab = item.dataset.tab;
            const speaker = item.dataset.speaker;
            if (tab && tab !== 'all') uniqueTabs.add(tab);
            if (speaker && speaker !== 'all' && speaker !== '不明') {
                 uniqueSpeakers.add(speaker);
                 speakerCounts[speaker] = (speakerCounts[speaker] || 0) + 1;
            }
            // CSS handles display mode based on [data-display-mode]
        });


        console.log("Export Unique Tabs:", uniqueTabs);
        console.log("Export Unique Speakers:", uniqueSpeakers);

        populateExportTabs(uniqueTabs);
        populateExportSpeakerFilter(uniqueSpeakers, speakerCounts);

        exportSpeakerFilter.addEventListener('change', handleExportSpeakerChange);
        // Tab listeners added during population

        // Initial filter application
        applyExportFilters();
    }

    function populateExportTabs(tabsSet) {
        exportLogTabsNav.innerHTML = '';
        const sortedTabs = [...tabsSet].sort((a, b) => a === 'all' ? -1 : b === 'all' ? 1 : a.localeCompare(b));
        const fragment = document.createDocumentFragment();
        sortedTabs.forEach(tab => {
            const button = document.createElement('button');
            button.textContent = '[' + tab + ']';
            button.dataset.tab = tab;
            button.className = 'tab-button export';
            if (tab === currentExportTab) button.classList.add('active');
            button.addEventListener('click', () => handleExportTabChange(tab));
            fragment.appendChild(button);
        });
        exportLogTabsNav.appendChild(fragment);
    }

    function populateExportSpeakerFilter(speakersSet, counts) {
        const sortedSpeakers = [...speakersSet].sort((a, b) => {
            if (a === 'all') return -1; if (b === 'all') return 1;
            const countDiff = (counts[b] || 0) - (counts[a] || 0);
            return countDiff !== 0 ? countDiff : a.localeCompare(b);
        });
        const fragment = document.createDocumentFragment();
        if (!sortedSpeakers.includes('all')) sortedSpeakers.unshift('all');
        sortedSpeakers.forEach(speaker => {
            const option = document.createElement('option');
            option.value = speaker;
            if (speaker === 'all') {
                option.textContent = 'すべての発言者';
            } else {
                const displayName = speakerDisplayNames[speaker] || speaker;
                const count = counts[speaker] || 0;
                option.textContent = displayName + ' (' + count + '回)';
            }
            fragment.appendChild(option);
        });
        exportSpeakerFilter.innerHTML = '';
        exportSpeakerFilter.appendChild(fragment);
        exportSpeakerFilter.value = currentExportSpeaker;
        exportSpeakerFilter.disabled = sortedSpeakers.length <= 1;
    }

    function handleExportTabChange(tabName) {
        if (currentExportTab === tabName) return;
        console.log('Export Filter - Tab changed to: ' + tabName);
        currentExportTab = tabName;
        exportLogTabsNav.querySelectorAll('.tab-button').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.tab === tabName);
        });
        applyExportFilters();
    }

    function handleExportSpeakerChange() {
        const newSpeaker = exportSpeakerFilter.value;
        if (currentExportSpeaker === newSpeaker) return;
        console.log('Export Filter - Speaker changed to: ' + newSpeaker);
        currentExportSpeaker = newSpeaker;
        applyExportFilters();
    }

    function applyExportFilters() {
        console.log('Applying export filters - Tab: ' + currentExportTab + ', Speaker: ' + currentExportSpeaker);
        let visibleCount = 0;
        allLogItems.forEach(item => {
            const itemTab = item.dataset.tab;
            const itemSpeaker = item.dataset.speaker;
            let isVisible = false;
            if (item.classList.contains('error-message')) {
                 isVisible = (currentExportTab === 'all' && currentExportSpeaker === 'all');
            } else {
                const tabMatch = currentExportTab === 'all' || itemTab === currentExportTab;
                const speakerMatch = currentExportSpeaker === 'all' || itemSpeaker === currentExportSpeaker;
                isVisible = tabMatch && speakerMatch;
            }
            if (isVisible) {
                item.classList.remove('hidden-log-item');
                visibleCount++;
            } else {
                item.classList.add('hidden-log-item');
            }
        });
        console.log('Applied filters. ' + visibleCount + ' items visible.');
        updateExportTabSeparators();
    }

    function updateExportTabSeparators() {
        const separators = exportLogDisplay.querySelectorAll('.tab-separator.export');
        separators.forEach(hr => hr.style.display = 'none');
        if (currentExportTab === 'all') {
            let lastVisibleTab = null;
            let firstVisibleItemFound = false;
            const potentialSeparators = Array.from(exportLogDisplay.children);
            potentialSeparators.forEach((element) => {
                const isLogItem = element.classList.contains('log-item');
                const isVisible = isLogItem && !element.classList.contains('hidden-log-item');
                if (isVisible) {
                    const currentItemTab = element.dataset.tab;
                    if (firstVisibleItemFound && lastVisibleTab !== null && currentItemTab !== lastVisibleTab && currentItemTab !== 'all') {
                        let previousElement = element.previousElementSibling;
                        while (previousElement) {
                             if (previousElement.classList.contains('tab-separator')) {
                                 previousElement.style.display = 'block';
                                 break;
                             }
                             if (previousElement.classList.contains('log-item') && !previousElement.classList.contains('hidden-log-item')) {
                                 break;
                             }
                             previousElement = previousElement.previousElementSibling;
                        }
                    }
                    if(currentItemTab !== 'all') {
                       lastVisibleTab = currentItemTab;
                    }
                    firstVisibleItemFound = true;
                }
            });
        }
    }

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeExportFilters);
    } else {
        initializeExportFilters();
    }

})();
            `;
        }


        /** Generates the CSS content for the exported log file */
        function generateOutputCss(currentCustomization) {
             console.log("   [generateOutputCss] Generating CSS for export...");
             // Renamed variable
             const { iconSize, bubbleMaxWidth, normalBubbleColor, backgroundColor, fontSize, nameBelowIconMode, fontFamily } = currentCustomization;
             const placeholderLineHeight = Math.round(iconSize * 0.9);
             const placeholderFontSize = Math.round(iconSize * 0.5);
             const responsiveIconSize = Math.max(24, Math.round(iconSize * 0.75));
             const responsivePlaceholderLineHeight = Math.round(responsiveIconSize * 0.9);
             const responsivePlaceholderFontSize = Math.round(responsiveIconSize * 0.5);

             // Map font class to font-family value
             const fontFamilies = {
                'font-inter': "'Inter', sans-serif",
                'font-noto-sans': "'Noto Sans JP', sans-serif",
                'font-noto-serif': "'Noto Serif JP', serif",
                'font-mplus-rounded': "'M PLUS Rounded 1c', sans-serif",
                'font-system-sans': "sans-serif",
                'font-system-serif': "serif",
                'font-system-mono': "monospace"
             };
             const selectedFontFamily = fontFamilies[fontFamily] || fontFamilies['font-noto-sans']; // Default to Noto Sans JP

             let css = `
/* --- Generated CSS for ccfolia Log Export (v5.1 - NameBelowIcon) --- */ /* Updated comment */
:root {
    --bubble-max-width: ${bubbleMaxWidth}%;
    --bubble-bg-color: ${normalBubbleColor};
    --bubble-arrow-color: ${normalBubbleColor};
    --icon-size: ${iconSize}px;
}
body {
    font-family: ${selectedFontFamily};
    margin: 0; padding: 15px; background-color: ${backgroundColor};
    font-size: ${fontSize}px; line-height: 1.7; color: #333;
}
.log-export-container { max-width: 900px; margin: 20px auto; background-color: ${logDisplayDiv.style.backgroundColor || '#ffffff'}; padding: 20px 25px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); }
h1 { font-size: 1.7em; color: #111; border-bottom: 2px solid #eee; padding-bottom: 10px; margin: 0 0 25px 0; text-align: center; }

/* Filter Controls */
.filter-controls.export { background-color: #f8f9fa; padding: 10px 15px; border-radius: 6px; margin-bottom: 20px; border: 1px solid #dee2e6; display: flex; flex-wrap: wrap; gap: 15px; align-items: center; }
.filter-section { display: flex; align-items: center; gap: 8px; }
.filter-section label { font-weight: bold; font-size: 0.9em; color: #495057; }
.tab-nav.export { display: flex; flex-wrap: wrap; gap: 5px; padding-bottom: 5px; }
.tab-button.export { background-color: #e9ecef; border: 1px solid #ced4da; color: #495057; padding: 4px 10px; border-radius: 4px; cursor: pointer; font-size: 0.85em; transition: background-color 0.2s, color 0.2s; white-space: nowrap; }
.tab-button.export:hover { background-color: #dee2e6; }
.tab-button.export.active { background-color: #0d6efd; border-color: #0d6efd; color: white; font-weight: bold; }
.speaker-filter.export { padding: 5px 8px; border: 1px solid #ced4da; border-radius: 4px; font-size: 0.9em; background-color: white; min-width: 150px; }
.tab-nav.export .placeholder { font-size: 0.85em; color: #6c757d; }

/* Log Display */
.log-display.export { margin-top: 10px; }
.hidden-log-item { display: none !important; }

/* --- Log Item Base Styles --- */
.message-item.export { position: relative; /* Needed for toggle button positioning */ }
/* Bubble mode container */
.message-container.export { display: flex; align-items: flex-start; margin-bottom: 16px; }
/* Narration mode container */
.narration-container.export { padding: 2px 4px; line-height: inherit; color: #333; }

/* Hide elements based on display mode */
.message-item.export[data-display-mode="narration"] .message-container.export { display: none; }
.message-item.export[data-display-mode="bubble"] .narration-container.export { display: none; }

/* Bubble Mode Specific Styles */
.icon-container.export { flex-shrink: 0; margin-right: 12px; width: var(--icon-size); height: var(--icon-size); position: relative; border-radius: 50%; }
.icon.export { display: block; width: 100%; height: 100%; border-radius: 50%; object-fit: cover; object-position: 50% 0%; border: 3px solid; box-sizing: border-box; background-color: #f0f0f0; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2); }
.icon-placeholder.export { display: none; width: 100%; height: 100%; border-radius: 50%; border: 3px solid; box-sizing: border-box; background-color: #e0e0e0; color: #757575; font-weight: bold; text-align: center; overflow: hidden; text-transform: uppercase; line-height: ${placeholderLineHeight}px; font-size: ${placeholderFontSize}px; }
.content-container.export { flex-grow: 1; min-width: 0; }
.speaker-name-default.export { display: block; font-weight: bold; margin-bottom: 4px; color: #1a1a1a; font-size: 0.9em; }
.original-tab.export { font-weight: normal; font-size: 0.88em; color: #555; margin-left: 6px; }
.tab-name-below-icon.export { display: none; font-size: 0.8em; color: #666; margin-bottom: 2px; } /* Renamed class */
.speaker-name-below-icon.export { display: none; font-size: 0.85em; font-weight: bold; color: #333; text-shadow: -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff, 1px 1px 0 #fff, -1.5px -1.5px 0 #fff, 1.5px -1.5px 0 #fff, -1.5px 1.5px 0 #fff, 1.5px 1.5px 0 #fff; position: absolute; bottom: -1.5em; /* Adjusted position */ left: 50%; transform: translateX(-50%); width: max-content; max-width: calc(var(--icon-size) + 20px); line-height: 1.1; text-align: center; pointer-events: none; } /* Renamed class */
.bubble.export { position: relative; padding: 10px 15px; border-radius: 16px; word-wrap: break-word; word-break: break-word; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12); background-color: var(--bubble-bg-color); max-width: var(--bubble-max-width); }
.bubble-left.export { margin-left: 0; }
.bubble-left.export::before { content: ""; position: absolute; top: 10px; left: -8px; width: 0; height: 0; border-style: solid; border-width: 8px 10px 8px 0; border-color: transparent var(--bubble-arrow-color) transparent transparent; }
.bubble.export a { color: #0066cc; text-decoration: underline; } .bubble.export a:hover { color: #004c99; text-decoration: none; }

/* Narration Mode Specific Styles */
.message-item.export[data-display-mode="narration"] .narration-tab,
.message-item.export[data-display-mode="narration"] .narration-speaker {
    display: none; /* Hide prefix in narration mode */
}
.narration-tab { font-size: 0.8em; color: #666; margin-right: 0.5em; }
.narration-speaker { font-weight: bold; margin-right: 0.25em; }
.narration-message { display: block; /* Ensure it takes block space */ }

/* --- 名前をアイコン下に表示モード 有効時のスタイル (Applied via body class) --- */ /* Renamed comment */
/* Renamed class */
body.name-below-icon-active .icon-container.export {
    margin-bottom: 1.8em; /* Increased margin */ overflow: visible;
}
body.name-below-icon-active .speaker-name-default.export { display: none; }
body.name-below-icon-active .tab-name-below-icon.export { display: block; } /* Renamed class */
body.name-below-icon-active .speaker-name-below-icon.export { display: block; } /* Renamed class */
body.name-below-icon-active .bubble-left.export { margin-left: 0; }
body.name-below-icon-active .bubble-left.export::before { left: -8px; }
body.name-below-icon-active .action-button-container { margin-left: 0; }


/* Other elements */
.inserted-image-container.export { margin: 18px 0; text-align: center; }
.inserted-image.export { max-width: 85%; max-height: 550px; border-radius: 6px; box-shadow: 0 3px 8px rgba(0, 0, 0, 0.15); display: block; margin: 0 auto; }
.image-caption.export { font-size: 0.9em; color: #444; margin-top: 6px; padding: 0 5%; line-height: 1.4; }
.image-error-placeholder.export { color: #d9534f; font-size: 0.9em; font-weight: bold; margin-top: 8px; padding: 5px; background-color: #f2dede; border: 1px solid #ebccd1; border-radius: 4px; display: inline-block; }
.tab-separator.export { border: 0; border-top: 2px dashed #cccccc; margin: 25px 5%; display: none; }
.error-message.export { background-color: #fff3cd; border: 1px solid #ffeeba; color: #856404; padding: 10px 15px; border-radius: 4px; margin: 15px 0; font-size: 0.9em; } .error-message.export strong { font-weight: bold; } .error-message.export small { color: #66512c; display: block; margin-top: 4px; }
.empty-log-message.export { text-align: center; color: #666; font-style: italic; padding: 30px; }
.export-error { color: red; font-weight: bold; text-align: center; margin: 10px; padding: 5px; border: 1px solid red; background-color: #ffeeee; }

/* Responsive Styles */
@media (max-width: 768px) {
    body { padding: 10px; font-size: ${Math.max(14, fontSize - 1)}px; }
    .log-export-container { padding: 15px; } h1 { font-size: 1.5em; margin-bottom: 20px; }
    .filter-controls.export { flex-direction: column; align-items: stretch; }
    .filter-section { flex-direction: column; align-items: flex-start; width: 100%; }
    .tab-nav.export { justify-content: center; }
    .speaker-filter.export { width: 100%; }
    .message-container.export { margin-bottom: 12px; }
    .icon-container.export { width: ${responsiveIconSize}px; height: ${responsiveIconSize}px; margin-right: 10px; }
    .icon-placeholder.export { line-height: ${responsivePlaceholderLineHeight}px; font-size: ${responsivePlaceholderFontSize}px; }
    .bubble.export { padding: 8px 12px; }
    .bubble-left.export::before { top: 8px; left: -7px; border-width: 7px 9px 7px 0;}
    .speaker-name-default.export { font-size: 0.92em; } .original-tab.export { font-size: 0.82em; }
    .tab-name-below-icon.export { font-size: 0.75em; } /* Renamed class */
    .speaker-name-below-icon.export { font-size: 0.8em; max-width: calc(${responsiveIconSize}px + 15px); bottom: -1.3em; /* Adjusted */ } /* Renamed class */
    body.name-below-icon-active .icon-container.export { margin-bottom: 1.5em; /* Adjusted */ } /* Renamed class */
    .inserted-image.export { max-width: 95%; max-height: 400px; }
    .image-caption.export { font-size: 0.85em; padding: 0 2%; }
    .tab-separator.export { margin: 20px 3%; }
}`;
            return css;
        }

        // --- Initialization ---
        function initializeApp() {
            console.log("Initializing ccfolia Log Formatter App (v5.1 - NameBelowIcon)..."); // Updated version/name
            loadCustomization();
            updateCustomizationUI();

            // Event Listeners
            fileInput.addEventListener('change', handleFileSelect);
            settingsTabButton.addEventListener('click', () => switchSettingsTab('settings'));
            customizeTabButton.addEventListener('click', () => switchSettingsTab('customize'));
            saveSettingsButton.addEventListener('click', saveCharacterSettings);
            loadSettingsButton.addEventListener('click', loadCharacterSettings);
            applyCustomizationButton.addEventListener('click', applyCustomization);
            resetCustomizationButton.addEventListener('click', resetCustomization);
            logTabsNav.addEventListener('click', (e) => { if (e.target.tagName === 'BUTTON' && e.target.dataset.tab) handleTabChange(e.target.dataset.tab); });
            speakerFilterSelect.addEventListener('change', handleSpeakerFilterChange);
            exportButton.addEventListener('click', handleExportZip);
            insertImageInput.addEventListener('change', handleInsertImageFile);
            fontSizeSlider.addEventListener('input', () => { fontSizeValueSpan.textContent = fontSizeSlider.value; });
            iconSizeSlider.addEventListener('input', () => { // Add listener for icon size slider
                iconSizeValueSpan.textContent = iconSizeSlider.value;
                // Apply icon size change immediately for preview (optional)
                // customizationSettings.iconSize = parseInt(iconSizeSlider.value, 10) || 64; // Use updated default
                // renderLog();
            });
            bubbleWidthSlider.addEventListener('input', () => { bubbleWidthValueSpan.textContent = bubbleWidthSlider.value; });
            nameBelowIconToggle.addEventListener('change', applyCustomization); // Renamed element ID
            fontFamilySelect.addEventListener('change', applyCustomization); // Apply font change immediately
            logHeightSlider.addEventListener('input', () => { // Add listener for log height slider input
                const newHeight = logHeightSlider.value;
                logHeightValueSpan.textContent = newHeight;
                // Apply height change immediately for preview
                logDisplayDiv.style.height = `${newHeight}px`;
                // Update the setting value, but don't save/apply fully yet
                customizationSettings.logDisplayHeight = parseInt(newHeight, 10);
            });
            logHeightSlider.addEventListener('change', applyCustomization); // Save and apply height when slider interaction ends

            switchSettingsTab('settings');
            hideLoading();
            disableControls();
            console.log("App initialization complete.");
        }

        function switchSettingsTab(tabName) {
            const panels = [settingsPanel, customizePanel]; const buttons = [settingsTabButton, customizeTabButton];
            panels.forEach(panel => panel.classList.add('hidden')); buttons.forEach(button => { button.classList.remove('border-indigo-500', 'text-indigo-600'); button.classList.add('border-transparent', 'text-gray-500', 'hover:text-gray-700', 'hover:border-gray-300'); button.removeAttribute('aria-current'); });
            let activePanel; let activeButton;
            if (tabName === 'settings') { activePanel = settingsPanel; activeButton = settingsTabButton; } else if (tabName === 'customize') { activePanel = customizePanel; activeButton = customizeTabButton; }
            if (activePanel) activePanel.classList.remove('hidden'); if (activeButton) { activeButton.classList.add('border-indigo-500', 'text-indigo-600'); activeButton.classList.remove('border-transparent', 'text-gray-500', 'hover:text-gray-700', 'hover:border-gray-300'); activeButton.setAttribute('aria-current', 'page'); }
            console.log(`Switched settings tab to: ${tabName}`);
        }

        // --- Run Initialization ---
        if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', initializeApp); else initializeApp();
      })(); // End IIFE
    </script>
</body>
</html>
